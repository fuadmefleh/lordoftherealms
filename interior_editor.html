<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Interior Editor</title>
<style>
*{box-sizing:border-box;margin:0;padding:0}
:root{
  --bg:#0d1117;--panel:#161b22;--panel2:#1c2129;
  --border:#21262d;--border2:#30363d;
  --text:#c9d1d9;--text-dim:#8b949e;
  --blue:#58a6ff;--green:#3fb950;--red:#f85149;--gold:#e6a817;--purple:#a371f7;
  --hover:#1c2129;
}
html,body{height:100%;overflow:hidden;background:var(--bg);color:var(--text);font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;font-size:13px}
body{display:flex;flex-direction:column}

/* ‚îÄ‚îÄ‚îÄ Toolbar ‚îÄ‚îÄ‚îÄ */
#toolbar{display:flex;align-items:center;gap:6px;padding:4px 10px;background:var(--panel);border-bottom:2px solid var(--border);height:40px;flex-shrink:0;overflow-x:auto}
#toolbar h1{font-size:13px;font-weight:700;color:var(--gold);margin-right:8px;white-space:nowrap}
#tool-btns{display:flex;gap:3px}
.tb-sep{width:1px;height:22px;background:var(--border2);margin:0 2px;flex-shrink:0}
button{background:#21262d;border:1px solid var(--border2);color:var(--text);padding:3px 9px;border-radius:5px;cursor:pointer;font-size:12px;transition:background .12s,border-color .12s}
button:hover{background:#2d333b;border-color:#484f58}
button.active{background:#0b2a4a;border-color:var(--blue);color:var(--blue)}
button.green{background:#0e2a17;border-color:var(--green);color:var(--green)}
button.gold{background:#2a1f00;border-color:var(--gold);color:var(--gold)}
button.danger{background:#2a0d0d;border-color:var(--red);color:var(--red)}
button.purple{background:#1e0f3a;border-color:var(--purple);color:var(--purple)}
input[type="text"],input[type="number"],select,textarea{background:#0d1117;border:1px solid var(--border2);color:var(--text);padding:3px 7px;border-radius:4px;font-size:12px}
input[type="text"]:focus,input[type="number"]:focus,select:focus{outline:none;border-color:var(--blue)}

/* ‚îÄ‚îÄ‚îÄ Main 3-col layout ‚îÄ‚îÄ‚îÄ */
#main{display:flex;flex:1;overflow:hidden;min-height:0}

/* LEFT: Palette */
#palette-panel{width:300px;min-width:180px;max-width:600px;background:var(--panel);border-right:1px solid var(--border);display:flex;flex-direction:column;overflow:hidden;position:relative;flex-shrink:0}
#pal-resizer{position:absolute;right:0;top:0;bottom:0;width:5px;cursor:col-resize;z-index:10}
#pal-header{display:flex;align-items:center;justify-content:space-between;padding:7px 10px;border-bottom:1px solid var(--border);flex-shrink:0}
#pal-header h2{font-size:11px;font-weight:600;color:var(--text-dim);text-transform:uppercase;letter-spacing:.06em}
#palette-cats{display:flex;flex-wrap:wrap;gap:3px;padding:6px 8px;border-bottom:1px solid var(--border);flex-shrink:0}
.cat-btn{font-size:10px;padding:3px 7px;border-radius:4px;white-space:nowrap}
.cat-btn.active{background:#0b2a4a;border-color:var(--blue);color:var(--blue)}
#palette-sheets{flex:1;overflow-y:auto;overflow-x:auto;min-height:0;padding:6px}
.sheet-block{margin-bottom:10px}
.sheet-name{font-size:10px;color:var(--text-dim);padding:2px 4px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.sheet-canvas-wrap{position:relative;overflow:hidden;border:1px solid var(--border);border-radius:3px;cursor:crosshair}
.palette-canvas{display:block;image-rendering:pixelated}
.stamp-highlight{position:absolute;border:2px solid var(--gold);background:rgba(230,168,23,.15);pointer-events:none;border-radius:2px}

/* CENTER: Canvas */
#canvas-area{flex:1;display:flex;flex-direction:column;overflow:hidden}
#canvas-toolbar{display:flex;align-items:center;gap:4px;padding:4px 8px;background:var(--panel);border-bottom:1px solid var(--border);flex-shrink:0;flex-wrap:wrap}
.layer-btn{font-size:11px;padding:3px 8px;border-radius:4px}
.layer-btn.active{background:#0b2a4a;border-color:var(--blue);color:var(--blue)}
#canvas-wrap{flex:1;position:relative;overflow:hidden;background:#0a0e17}
#build-canvas{position:absolute;image-rendering:pixelated}

/* RIGHT: Properties */
#props-panel{width:280px;flex-shrink:0;background:var(--panel);border-left:1px solid var(--border);display:flex;flex-direction:column;overflow-y:auto;padding:10px}
.rp-section{margin-bottom:14px}
.rp-section h3{font-size:10px;font-weight:600;color:var(--text-dim);text-transform:uppercase;letter-spacing:.06em;margin-bottom:8px}
.rp-field{display:flex;flex-direction:column;gap:3px;margin-bottom:8px}
.rp-field label{font-size:11px;color:var(--text-dim)}
.rp-field input,.rp-field select{width:100%}
.rp-row{display:flex;gap:8px}
.rp-row .rp-field{flex:1}
.item-list{border-top:1px solid var(--border);padding-top:8px}
.item-card{display:flex;align-items:center;gap:6px;padding:5px 7px;border:1px solid var(--border);border-radius:5px;cursor:pointer;margin-bottom:4px;transition:background .1s,border-color .1s}
.item-card:hover{background:var(--hover)}
.item-card.selected{background:#0b2a4a;border-color:var(--blue)}
.item-card .ic-name{flex:1;font-size:12px;font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.item-card .ic-type{font-size:10px;color:var(--text-dim)}
.item-card .ic-del{font-size:11px;color:var(--red);cursor:pointer;padding:2px 4px;border-radius:3px;opacity:.6}
.item-card .ic-del:hover{opacity:1;background:rgba(248,81,73,.15)}
#stamp-preview{height:60px;border:1px solid var(--border);border-radius:5px;background:var(--bg);margin-bottom:10px;display:flex;align-items:center;justify-content:center;overflow:hidden}
#stamp-preview canvas{image-rendering:pixelated;max-width:100%;max-height:100%}
#stamp-preview .empty{color:var(--text-dim);font-size:11px}

/* Furniture marker icons on canvas */
.furn-ghost{position:absolute;pointer-events:none;font-size:20px;opacity:.7;text-shadow:0 0 3px rgba(0,0,0,.7)}

/* ‚îÄ‚îÄ‚îÄ Nine-Tile Brush System ‚îÄ‚îÄ‚îÄ */
#ntbModal{position:fixed;inset:0;z-index:1001;background:rgba(0,0,0,0.88);backdrop-filter:blur(5px);display:flex;flex-direction:column}
.ntb-header{display:flex;align-items:center;justify-content:space-between;padding:10px 16px;background:var(--panel);border-bottom:1px solid var(--border);flex-shrink:0}
.ntb-body{display:flex;flex:1;overflow:hidden}
.ntb-left{width:420px;flex-shrink:0;padding:12px;overflow-y:auto;border-right:1px solid var(--border);display:flex;flex-direction:column;gap:12px}
.ntb-right{flex:1;display:flex;flex-direction:column;overflow:hidden;background:var(--panel2)}
.ntb-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:4px;max-width:300px}
.ntb-cell{border:2px solid var(--border2);border-radius:6px;cursor:pointer;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:6px;background:var(--bg);transition:border-color .12s,background .12s;aspect-ratio:1;min-height:70px}
.ntb-cell:hover{background:var(--hover);border-color:var(--blue)}
.ntb-cell.ntb-selected{background:#0b2a4a !important;border-color:var(--blue);outline:2px solid var(--blue)}
.ntb-cell.ntb-filled{border-color:var(--green)}
.ntb-cell canvas{image-rendering:pixelated;width:48px;height:48px;display:block}
.ntb-cell-lbl{font-size:8px;color:var(--text-dim);margin-top:2px;font-weight:600;text-transform:uppercase}
.ntb-ic-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:4px;max-width:300px;margin-top:4px}
.ntb-corridor-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:4px;max-width:300px;margin-top:4px}
.ntb-brush-card{background:var(--bg);border:1px solid var(--border);border-radius:5px;padding:6px 8px;cursor:pointer;display:flex;align-items:center;gap:8px;transition:border-color .12s}
.ntb-brush-card:hover{border-color:var(--blue)}
.ntb-brush-card.selected{border-color:var(--gold);background:#1a1500}
.ntb-brush-card canvas{image-rendering:pixelated;flex-shrink:0}
.ntb-brush-card .ntb-bname{flex:1;font-size:12px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.ntb-brush-card .ntb-btype{font-size:9px;padding:1px 5px;border-radius:3px;text-transform:uppercase;font-weight:600}
.ntb-brush-card .ntb-btype.floor{background:#0e2a17;color:var(--green)}
.ntb-brush-card .ntb-btype.wall{background:#2a1f00;color:var(--gold)}
.ntb-type-tabs{display:flex;gap:4px;margin-bottom:8px}
.ntb-type-btn{font-size:11px;padding:4px 12px;border:1px solid var(--border2);border-radius:4px;background:var(--bg);color:var(--text-dim);cursor:pointer;transition:all .12s}
.ntb-type-btn:hover{background:var(--hover);border-color:var(--blue);color:var(--text)}
.ntb-type-btn.active{background:#0b2a4a;border-color:var(--blue);color:var(--blue);font-weight:600}
/* Toast */
#toast{position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:var(--panel);border:1px solid var(--border);color:var(--text);padding:8px 18px;border-radius:6px;font-size:12px;display:none;z-index:9999;box-shadow:0 4px 16px rgba(0,0,0,0.5)}
#toast.ok{border-color:var(--green);color:var(--green)}
#toast.err{border-color:var(--red);color:var(--red)}
/* ‚îÄ‚îÄ‚îÄ Interior Generator Modal ‚îÄ‚îÄ‚îÄ */
.igen-overlay{position:fixed;inset:0;z-index:1002;background:rgba(0,0,0,0.8);backdrop-filter:blur(4px);display:flex;align-items:center;justify-content:center}
.igen-modal{background:var(--panel);border:1px solid var(--border);border-radius:10px;width:520px;max-height:90vh;overflow-y:auto;padding:20px;box-shadow:0 8px 40px rgba(0,0,0,0.6)}
.igen-modal h3{margin:0 0 14px 0;color:var(--gold);font-size:16px}
.igen-section{margin-bottom:14px;padding:10px;background:var(--bg);border:1px solid var(--border);border-radius:6px}
.igen-section h4{margin:0 0 8px 0;font-size:12px;color:var(--blue);text-transform:uppercase;letter-spacing:.5px}
.igen-row{display:flex;align-items:center;gap:8px;margin-bottom:6px;font-size:12px}
.igen-row label{min-width:80px;color:var(--text-dim);text-align:right}
.igen-row select,.igen-row input[type=number]{background:var(--bg);color:var(--text);border:1px solid var(--border2);padding:3px 6px;border-radius:4px;font-size:11px}
.igen-row select{min-width:140px}
.igen-row input[type=range]{flex:1;max-width:140px}
.igen-preview{display:flex;justify-content:center;padding:8px;background:var(--bg);border:1px solid var(--border);border-radius:6px;min-height:120px}
.igen-preview canvas{image-rendering:pixelated}
.igen-btns{display:flex;justify-content:flex-end;gap:8px;margin-top:14px}
.igen-btns button{font-size:12px;padding:6px 16px;border-radius:5px;cursor:pointer;border:1px solid var(--border2);background:var(--bg);color:var(--text)}
.igen-btns button:hover{background:var(--hover)}
.igen-btns button.primary{background:var(--blue);color:#fff;border-color:var(--blue)}
.igen-btns button.primary:hover{filter:brightness(1.15)}
.igen-warn{color:#d4a05a;font-size:11px;margin:4px 0}
</style>
</head>
<body>

<!-- ‚ïê‚ïê‚ïê TOOLBAR ‚ïê‚ïê‚ïê -->
<div id="toolbar">
  <h1>üè† Interior Editor</h1>
  <div class="tb-sep"></div>
  <label style="font-size:11px;color:var(--text-dim)">W:</label>
  <input type="number" id="grid-w" value="10" min="4" max="30" style="width:45px">
  <label style="font-size:11px;color:var(--text-dim)">H:</label>
  <input type="number" id="grid-h" value="8" min="4" max="30" style="width:45px">
  <button onclick="resizeGrid()">Resize</button>
  <div class="tb-sep"></div>
  <div id="tool-btns">
    <button id="tool-paint"   class="active" onclick="setTool('paint')">üñå Paint</button>
    <button id="tool-erase"   onclick="setTool('erase')">üóë Erase</button>
    <button id="tool-fill"    onclick="setTool('fill')">ü™£ Fill</button>
    <button id="tool-eyedrop" onclick="setTool('eyedrop')">üíâ Pick</button>
    <button id="tool-impass"  onclick="setTool('impass')">‚õî Block</button>
    <button id="tool-door"    onclick="setTool('door')">üö™ Door</button>
    <button id="tool-furn"    onclick="setTool('furniture')">ü™ë Furniture</button>
    <button id="tool-9tile"   onclick="setTool('9tile')" title="9-Tile Auto-Brush (N)">üñº 9-Tile</button>
  </div>
  <div class="tb-sep"></div>
  <button class="purple" onclick="openNtbEditor(-1)" title="Create or edit 9-tile auto-edge brushes">üé® Brushes</button>
  <button class="gold" onclick="showInteriorGenerator()" title="Procedurally generate an interior layout">üèóÔ∏è Generate</button>
  <div class="tb-sep"></div>
  <button onclick="newInterior()">Ôºã New</button>
  <button onclick="saveInterior()" class="green">üíæ Save</button>
  <button onclick="exportAll()" class="gold">‚¨á Export JSON</button>
</div>

<!-- ‚ïê‚ïê‚ïê MAIN ‚ïê‚ïê‚ïê -->
<div id="main">

  <!-- LEFT: Palette -->
  <div id="palette-panel">
    <div id="pal-resizer"></div>
    <div id="pal-header"><h2>Palette</h2><div style="display:flex;gap:3px;align-items:center"><button onclick="changePalZoom(-0.5)" style="font-size:10px;padding:2px 6px">Ôºç</button><span id="pal-zoom-label" style="font-size:10px;color:var(--text-dim);min-width:24px;text-align:center">2√ó</span><button onclick="changePalZoom(0.5)" style="font-size:10px;padding:2px 6px">Ôºã</button><button onclick="loadCustomSheet()" style="font-size:10px">üìÇ</button></div></div>
    <div id="palette-cats"></div>
    <div id="palette-sheets"></div>
  </div>

  <!-- CENTER: Canvas -->
  <div id="canvas-area">
    <div id="canvas-toolbar">
      <button class="layer-btn active" data-layer="floor" onclick="setLayer('floor')">Floor</button>
      <button class="layer-btn" data-layer="furniture" onclick="setLayer('furniture')">Furniture</button>
      <button class="layer-btn" data-layer="walls" onclick="setLayer('walls')">Walls</button>
      <button class="layer-btn" data-layer="overlay" onclick="setLayer('overlay')">Overlay</button>
      <div class="tb-sep"></div>
      <button onclick="zoomIn()">Ôºã</button>
      <button onclick="zoomOut()">Ôºç</button>
      <button onclick="fitCanvas()">Fit</button>
      <div class="tb-sep"></div>
      <button onclick="clearLayer()" class="danger">Clear Layer</button>
      <button onclick="clearAll()" class="danger">Clear All</button>
    </div>
    <div id="canvas-wrap">
      <canvas id="build-canvas"></canvas>
    </div>
  </div>

  <!-- RIGHT: Properties -->
  <div id="props-panel">
    <div id="stamp-preview"><span class="empty">Select a tile from the palette</span></div>

    <div class="rp-section" id="interior-props">
      <h3>Interior Properties</h3>
      <div class="rp-field">
        <label>Name</label>
        <input type="text" id="int-name" placeholder="e.g. Cozy Tavern">
      </div>
      <div class="rp-field">
        <label>Linked Buildings <span style="color:var(--text-dim)">(click to toggle)</span></label>
        <div id="int-linked-buildings" style="max-height:120px;overflow-y:auto;border:1px solid var(--border);border-radius:4px;padding:4px;background:var(--input-bg);font-size:12px">
          <span style="color:var(--text-dim);font-style:italic">No buildings available</span>
        </div>
      </div>
      <div class="rp-field">
        <label>Building Type</label>
        <select id="int-type">
          <option value="house">House</option>
          <option value="tavern">Tavern</option>
          <option value="blacksmith">Blacksmith</option>
          <option value="church">Church</option>
          <option value="temple">Temple</option>
          <option value="marketplace">Marketplace</option>
          <option value="town_hall">Town Hall</option>
          <option value="barracks">Barracks</option>
          <option value="manor">Manor</option>
          <option value="granary">Granary</option>
          <option value="warehouse">Warehouse</option>
          <option value="stable">Stable</option>
          <option value="barn">Barn</option>
          <option value="guard_tower">Guard Tower</option>
          <option value="farm">Farm</option>
          <option value="castle">Castle</option>
          <option value="other">Other</option>
        </select>
      </div>
      <div class="rp-field">
        <label>Tags <span style="color:var(--text-dim)">(comma separated)</span></label>
        <input type="text" id="int-tags" placeholder="cozy, wooden, small">
      </div>
      <div class="rp-field">
        <label>Variant Group <span style="color:var(--text-dim)">(same group = interchangeable)</span></label>
        <input type="text" id="int-group" placeholder="e.g. tavern_interiors">
      </div>
    </div>

    <div class="rp-section" id="furniture-props" style="display:none">
      <h3>Furniture Properties</h3>
      <div class="rp-field">
        <label>Furniture Type</label>
        <select id="furn-type">
          <option value="table">ü™ë Table</option>
          <option value="chair">ü™ë Chair</option>
          <option value="bed">üõèÔ∏è Bed</option>
          <option value="chest">üì¶ Chest</option>
          <option value="barrel">üõ¢Ô∏è Barrel</option>
          <option value="bookshelf">üìö Bookshelf</option>
          <option value="fireplace">üî• Fireplace</option>
          <option value="candle">üïØÔ∏è Candle</option>
          <option value="bar">üç∫ Bar Counter</option>
          <option value="forge">üî• Forge</option>
          <option value="anvil">‚öíÔ∏è Anvil</option>
          <option value="altar">‚õ™ Altar</option>
          <option value="pew">ü™ë Pew</option>
          <option value="throne">üëë Throne</option>
          <option value="statue">üóø Statue</option>
          <option value="stall">üè™ Market Stall</option>
          <option value="rack">‚öîÔ∏è Weapon Rack</option>
          <option value="crate">üì¶ Crate</option>
          <option value="banner">üè¥ Banner</option>
          <option value="well">üíß Well</option>
          <option value="stairs">ü™ú Stairs</option>
          <option value="scales">‚öñÔ∏è Scales</option>
        </select>
      </div>
      <div class="rp-field">
        <label>Custom Name <span style="color:var(--text-dim)">(optional)</span></label>
        <input type="text" id="furn-name" placeholder="e.g. Grand Fireplace">
      </div>
      <div class="rp-field">
        <label>
          <input type="checkbox" id="furn-passable"> Passable (can walk through)
        </label>
      </div>
    </div>

    <div class="rp-section" id="ntb-brushes-section">
      <h3>üñº 9-Tile Brushes</h3>
      <div style="display:flex;gap:4px;margin-bottom:6px">
        <button class="purple" onclick="openNtbEditor(-1)" style="font-size:10px;padding:2px 7px;flex:1">Ôºã New Brush</button>
      </div>
      <div id="ntb-list-panel" style="display:flex;flex-direction:column;gap:3px;max-height:180px;overflow-y:auto"></div>
    </div>

    <div class="rp-section item-list">
      <h3>Saved Interiors (<span id="int-count">0</span>)</h3>
      <div id="interior-list"></div>
    </div>
  </div>
</div>

<!-- ‚ïê‚ïê‚ïê NINE-TILE BRUSH EDITOR MODAL ‚ïê‚ïê‚ïê -->
<div id="ntbModal" style="display:none">
  <div class="ntb-header">
    <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap">
      <span style="font-size:15px;font-weight:700;color:var(--purple)">üñº Nine-Tile Brush Editor</span>
      <input type="text" id="ntb-name" value="New Brush" placeholder="Brush name..." style="width:160px">
      <div class="ntb-type-tabs" style="margin-bottom:0">
        <button class="ntb-type-btn active" id="ntb-type-floor" onclick="ntbSetType('floor')">üü´ Floor</button>
        <button class="ntb-type-btn" id="ntb-type-wall" onclick="ntbSetType('wall')">üß± Wall</button>
      </div>
      <button class="green" onclick="ntbSave()">üíæ Save</button>
      <button class="danger" onclick="ntbDelete()" id="ntb-del-btn" disabled>üóë Delete</button>
      <div style="width:1px;height:22px;background:var(--border);margin:0 4px"></div>
      <span style="font-size:10px;color:var(--text-dim);text-transform:uppercase;font-weight:600">Cost per tile:</span>
      <label style="font-size:11px;color:var(--text-dim)">Gold</label>
      <input type="number" id="ntb-cost-gold" value="0" min="0" max="9999" style="width:60px;font-size:11px;background:var(--bg);border:1px solid var(--border2);color:var(--text);padding:2px 5px;border-radius:4px">
      <div id="ntb-cost-resource-rows" style="display:flex;align-items:center;gap:6px;flex-wrap:wrap"></div>
    </div>
    <button onclick="closeNtbEditor()" style="font-size:18px;padding:2px 10px;flex-shrink:0">‚úï</button>
  </div>
  <div class="ntb-body">
    <div class="ntb-left">
      <div>
        <div style="font-size:10px;color:var(--text-dim);text-transform:uppercase;font-weight:600;margin-bottom:6px">Tile Layout</div>
        <div style="font-size:10px;color:var(--text-dim);margin-bottom:8px;line-height:1.4;padding:6px 8px;background:var(--panel2);border-radius:4px;border:1px solid var(--border)">
          <b style="color:var(--text)">How it works:</b> Pick 9 outer tiles + 4 inside corners.<br>
          <b>Center</b> fills interior areas. <b>Edge</b> tiles appear at boundaries.<br>
          <b>Corner</b> tiles at diagonal boundaries. <b>Inside corners</b> for concave corners.<br>
          <b style="color:var(--gold)">Wall brushes</b> also have corridor/junction pieces for hallways.<br>
          <b style="color:var(--green)">Quick:</b> Drag a 3√ó3 on the palette for outer tiles, or 2√ó2 for inside corners.
        </div>
        <div class="ntb-grid" id="ntb-grid"></div>
        <div style="font-size:9px;color:var(--text-dim);text-transform:uppercase;font-weight:600;margin-top:8px;margin-bottom:2px">Inside Corners <span style="font-weight:400;text-transform:none">(optional)</span></div>
        <div class="ntb-ic-grid" id="ntb-ic-grid"></div>
        <div id="ntb-corridor-section" style="display:none">
          <div style="font-size:9px;color:var(--text-dim);text-transform:uppercase;font-weight:600;margin-top:10px;margin-bottom:2px">Corridors & Junctions <span style="font-weight:400;text-transform:none">(wall brush only)</span></div>
          <div class="ntb-corridor-grid" id="ntb-corridor-grid"></div>
          <div style="font-size:9px;color:var(--text-dim);text-transform:uppercase;font-weight:600;margin-top:8px;margin-bottom:2px">End Caps</div>
          <div class="ntb-corridor-grid" id="ntb-endcap-grid"></div>
        </div>
      </div>
      <div>
        <div style="font-size:10px;color:var(--text-dim);text-transform:uppercase;font-weight:600;margin-bottom:6px">Saved Brushes</div>
        <div id="ntb-brush-list" style="display:flex;flex-direction:column;gap:4px"></div>
      </div>
    </div>
    <div class="ntb-right">
      <div style="padding:7px 8px;border-bottom:1px solid var(--border);flex-shrink:0">
        <div style="font-size:9px;color:var(--text-dim);text-transform:uppercase;font-weight:600;margin-bottom:4px">Category</div>
        <div id="ntb-cat-btns" style="display:flex;flex-wrap:wrap;gap:3px"></div>
      </div>
      <div style="flex:1;overflow:auto;padding:6px">
        <canvas id="ntb-tileset-canvas" style="image-rendering:pixelated;cursor:crosshair;display:block"></canvas>
      </div>
    </div>
  </div>
</div>

<div id="toast"></div>

<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  INTERIOR EDITOR ‚Äî Full standalone editor for painting
//  building interiors with LPC spritesheets.
//  Follows the same patterns as sprite_editor.html.
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const TILE = 32;
let PAL_ZOOM = 2;

// ‚îÄ‚îÄ‚îÄ State ‚îÄ‚îÄ‚îÄ
let gridW = 10, gridH = 8;
let canvasZoom = 2, panX = 20, panY = 20;
let layers = { floor: {}, furniture: {}, walls: {}, overlay: {} };
let meta = {};       // "q,r" ‚Üí { impassable?, door?, furniture?: { type, name, passable } }
let placedObjects = {};  // "q,r" ‚Üí { defId, name, tiles:[{localCol,localRow,sheetPath,sx,sy,sw,sh}], bounds }
let activeLayer = 'floor';
let activeTool = 'paint';
let activeStamp = null;

let interiors = [];  // Saved interior definitions
let editIdx = -1;    // Index of interior being edited (-1 = new)
let _buildings = [];  // Buildings list from parent (for linked building checklist)
let _linkedBuildingIds = [];  // Currently linked building ids (array)
let _customObjects = [];  // Custom objects from sprite editor
let _resourceTypes = [
  { id: 'wood', name: 'Wood', icon: 'ü™µ', color: '#8b5a2b', buildCostEligible: true },
  { id: 'timber', name: 'Timber', icon: 'üå≤', color: '#8b5a2b', buildCostEligible: true },
  { id: 'stone', name: 'Stone', icon: '‚õ∞Ô∏è', color: '#808080', buildCostEligible: true },
  { id: 'iron', name: 'Iron', icon: '‚õèÔ∏è', color: '#8a7a7a', buildCostEligible: true },
];

// ‚îÄ‚îÄ‚îÄ Nine-Tile Brush State ‚îÄ‚îÄ‚îÄ
let nineTileBrushes = [];       // Array of brush definitions
let activeNineBrush = null;     // Index into nineTileBrushes or null
let brushGroupMap = {};         // "q,r" ‚Üí { brushId, layer } ‚Äî tracks which tiles belong to which brush

// Palette state
let currentCategory = null;
const imageCache = {};
const palHighlightDivs = new Map();
let palDragging = false, palDragMeta = null, palDragStart = null, palDragLive = null;

// Undo
let undoStack = [], redoStack = [];
const MAX_UNDO = 40;

// Canvas refs
let cvs, ctx;

function _setResourceTypes(resourceTypes) {
  if (Array.isArray(resourceTypes) && resourceTypes.length) {
    _resourceTypes = resourceTypes
      .map(r => ({
        id: String(r.id || '').trim(),
        name: String(r.name || r.id || '').trim(),
        icon: String(r.icon || 'üì¶'),
        color: String(r.color || '#888888'),
        buildCostEligible: !!r.buildCostEligible,
      }))
      .filter(r => r.id);
  }
  _renderNtbCostResourceRows();
}

function _getBuildCostResourceTypes() {
  const eligible = _resourceTypes.filter(r => r.buildCostEligible);
  if (eligible.length) return eligible;
  return _resourceTypes.filter(r => ['wood', 'timber', 'stone', 'iron'].includes(r.id));
}

function _renderNtbCostResourceRows(costMap = null) {
  const wrap = document.getElementById('ntb-cost-resource-rows');
  if (!wrap) return;
  const existing = costMap || {};
  const defs = [..._getBuildCostResourceTypes()].sort((a, b) => a.name.localeCompare(b.name));
  wrap.innerHTML = '';
  for (const r of defs) {
    const lbl = document.createElement('label');
    lbl.style.cssText = 'display:flex;align-items:center;gap:4px;font-size:11px;color:var(--text-dim)';
    lbl.textContent = `${r.icon || 'üì¶'} ${r.name}`;
    const input = document.createElement('input');
    input.type = 'number';
    input.min = '0';
    input.max = '999';
    input.value = String(existing[r.id] || 0);
    input.style.cssText = 'width:52px;font-size:11px;background:var(--bg);border:1px solid var(--border2);color:var(--text);padding:2px 5px;border-radius:4px';
    input.dataset.resId = r.id;
    lbl.appendChild(input);
    wrap.appendChild(lbl);
  }
}

// ‚îÄ‚îÄ‚îÄ LPC Palette categories ‚îÄ‚îÄ‚îÄ
const PALETTE_DATA = {
  'Floors': [
    'assets/lpc/Structure/Floor/floors.png',
    'assets/lpc/Structure/Floor/Diamond Tile A.png',
    'assets/lpc/Structure/Floor/Diamond Tile B.png',
    'assets/lpc/Structure/Floor/Diamond Tile C.png',
    'assets/lpc/Structure/Floor/Floral Carpet A.png',
    'assets/lpc/Structure/Floor/Floral Carpet B.png',
    'assets/lpc/Structure/Floor/Geometric Carpet A.png',
    'assets/lpc/Structure/Floor/Geometric Carpet B.png',
    'assets/lpc/Structure/Floor/Geometric Carpet C.png',
    'assets/lpc/Structure/Floor/Gritty Dirt.png',
    'assets/lpc/Structure/Floor/Herringbone A.png',
    'assets/lpc/Structure/Floor/Subfloor.png',
    'assets/lpc/Structure/Floor/Tile A.png',
    'assets/lpc/Structure/Floor/Tile B.png',
    'assets/lpc/Structure/Floor/Tile C.png',
    'assets/lpc/Structure/Floor/Wood Floor A.png',
    'assets/lpc/Structure/Floor/Wood Floor B.png',
  ],
  'Walls': [
    'assets/lpc/Structure/Walls/walls.png',
    'assets/lpc/Structure/Walls/Adobe Brick Wall.png',
    'assets/lpc/Structure/Walls/Adobe Stucco Wall.png',
    'assets/lpc/Structure/Walls/Brick Wall A.png',
    'assets/lpc/Structure/Walls/Brick Wall B.png',
    'assets/lpc/Structure/Walls/Brick Wall Block Edging.png',
    'assets/lpc/Structure/Walls/Diamond Wallpaper.png',
    'assets/lpc/Structure/Walls/Drywall.png',
    'assets/lpc/Structure/Walls/Floral Wallpaper A.png',
    'assets/lpc/Structure/Walls/Floral Wallpaper B.png',
    'assets/lpc/Structure/Walls/Grainy Plain Wall.png',
    'assets/lpc/Structure/Walls/Half-Wall Paneling A.png',
    'assets/lpc/Structure/Walls/Jagged Stone Walls.png',
    'assets/lpc/Structure/Walls/Painted Walls.png',
    'assets/lpc/Structure/Walls/Panels A.png',
    'assets/lpc/Structure/Walls/Striped Wallpaper A.png',
    'assets/lpc/Structure/Walls/Striped Wallpaper B.png',
    'assets/lpc/Structure/Walls/Striped Wallpaper C.png',
  ],
  'Wall Borders': [
    'assets/lpc/Structure/Wall Borders/Decorative Border A.png',
    'assets/lpc/Structure/Wall Borders/Formal Crown Molding.png',
    'assets/lpc/Structure/Wall Borders/Pillar Crown Molding.png',
    'assets/lpc/Structure/Wall Borders/Plain Edged Border - A.png',
    'assets/lpc/Structure/Wall Borders/Plain Edged Border.png',
    'assets/lpc/Structure/Wall Borders/Plain Smooth Border.png',
    'assets/lpc/Structure/Wall Borders/Textured Wood Border.png',
    'assets/lpc/Structure/Walls/Molding.png',
    'assets/lpc/Structure/Walls/CutawayOverlay.png',
  ],
  'Doors': [
    'assets/lpc/Structure/Doors/32x48px Doors/12 Panel Door A.png',
    'assets/lpc/Structure/Doors/32x48px Doors/12 Panel Door B.png',
    'assets/lpc/Structure/Doors/32x48px Doors/Barred Prison Door A.png',
    'assets/lpc/Structure/Doors/32x48px Doors/Doorframe A.png',
    'assets/lpc/Structure/Doors/32x48px Doors/Doorframe B.png',
    'assets/lpc/Structure/Doors/32x64px Doors/15 Panel Door A.png',
    'assets/lpc/Structure/Doors/32x64px Doors/Doorframe A.png',
    'assets/lpc/Structure/Doors/64x64px Arched Doors/Arched Doorway A.png',
    'assets/lpc/Structure/Doors/64x64px Arched Doors/Arched Double Doors A.png',
  ],
  'Furniture': [
    'assets/lpc/Objects/Furniture/Barrel.png',
    'assets/lpc/Objects/Furniture/Bin.png',
    'assets/lpc/Objects/Furniture/Cabinet.png',
    'assets/lpc/Objects/Furniture/Cauldron.png',
    'assets/lpc/Objects/Furniture/Chest.png',
    'assets/lpc/Objects/Furniture/Countertop.png',
    'assets/lpc/Objects/Furniture/Crate.png',
    'assets/lpc/Objects/Furniture/Dresser.png',
    'assets/lpc/Objects/Furniture/End Table.png',
    'assets/lpc/Objects/Furniture/Fireplace.png',
    'assets/lpc/Objects/Furniture/Fireplace, Cast Iron.png',
    'assets/lpc/Objects/Furniture/Ladder.png',
    'assets/lpc/Objects/Furniture/Mirror, Standing.png',
    'assets/lpc/Objects/Furniture/Planter.png',
    'assets/lpc/Objects/Furniture/Shelf.png',
    'assets/lpc/Objects/Furniture/Standing Screen.png',
    'assets/lpc/Objects/Furniture/Stone Slab.png',
    'assets/lpc/Objects/Furniture/Trough.png',
    'assets/lpc/Objects/Furniture/Wolf Stone.png',
  ],
  'Tables & Desks': [
    'assets/lpc/Objects/Furniture/Table, Card.png',
    'assets/lpc/Objects/Furniture/Table, Ornate Wood.png',
    'assets/lpc/Objects/Furniture/Table, Rough Wood.png',
    'assets/lpc/Objects/Furniture/Table, Workshop.png',
    'assets/lpc/Objects/Furniture/Desk, Vanity.png',
    'assets/lpc/Objects/Furniture/Workbench, Carpentry.png',
  ],
  'Seating & Beds': [
    'assets/lpc/Objects/Furniture/Seating/Bar Stools.png',
    'assets/lpc/Objects/Furniture/Seating/Chair, Dining A.png',
    'assets/lpc/Objects/Furniture/Seating/Chair, Dining B.png',
    'assets/lpc/Objects/Furniture/Seating/Chair, Dining C.png',
    'assets/lpc/Objects/Furniture/Seating/Chair, Dining D.png',
    'assets/lpc/Objects/Furniture/Seating/Chair, Sofa A.png',
    'assets/lpc/Objects/Furniture/Seating/Thrones.png',
    'assets/lpc/Objects/Furniture/Beds/Beds, Single  A.png',
    'assets/lpc/Objects/Furniture/Beds/Beds, Single B.png',
    'assets/lpc/Objects/Furniture/Beds/Beds, Single C.png',
    'assets/lpc/Objects/Furniture/Beds/Beds, Single Headboards.png',
    'assets/lpc/Objects/Furniture/Beds/Beds, Single Mattresses.png',
    'assets/lpc/Objects/Furniture/Beds/Beds, Double.png',
    'assets/lpc/Objects/Furniture/Beds/Beds, Double B.png',
  ],
  'Rugs': [
    'assets/lpc/Objects/Furniture/Rugs/Diamond Rug, tiling.png',
    'assets/lpc/Objects/Furniture/Rugs/Rainbow Checkered Rug.png',
    'assets/lpc/Objects/Furniture/Rugs/Rainbow Rug.png',
    'assets/lpc/Objects/Furniture/Rugs/Swirling Vine Rug.png',
  ],
  'Smithing': [
    'assets/lpc/Objects/Furniture/Smithing/Anvils.png',
    'assets/lpc/Objects/Furniture/Smithing/Bellows.png',
    'assets/lpc/Objects/Furniture/Smithing/Coal Piles.png',
    'assets/lpc/Objects/Furniture/Smithing/Forge A.png',
    'assets/lpc/Objects/Furniture/Smithing/Furnace A.png',
    'assets/lpc/Objects/Furniture/Smithing/Grindstone.png',
    'assets/lpc/Objects/Furniture/Smithing/Smelter.png',
    'assets/lpc/Objects/Furniture/Smithing/Workbench, Smith.png',
  ],
  'Small Items': [
    'assets/lpc/Objects/Small Items/Baskets A.png',
    'assets/lpc/Objects/Small Items/Boxes.png',
    'assets/lpc/Objects/Small Items/Buckets.png',
    'assets/lpc/Objects/Small Items/Dishes A.png',
    'assets/lpc/Objects/Small Items/Dungeon Elements.png',
    'assets/lpc/Objects/Small Items/Fire, Camp.png',
    'assets/lpc/Objects/Small Items/Fire, Fireplace.png',
    'assets/lpc/Objects/Small Items/Fireplace, Accessories A.png',
    'assets/lpc/Objects/Small Items/Flowers.png',
    'assets/lpc/Objects/Small Items/Games.png',
    'assets/lpc/Objects/Small Items/Hay & Straw.png',
    'assets/lpc/Objects/Small Items/Kitchen Clutter A.png',
    'assets/lpc/Objects/Small Items/Lighting, Table.png',
    'assets/lpc/Objects/Small Items/Lumber.png',
    'assets/lpc/Objects/Small Items/Pillows.png',
    'assets/lpc/Objects/Small Items/Skeletons A.png',
    'assets/lpc/Objects/Small Items/Tools, Carpentry.png',
    'assets/lpc/Objects/Small Items/Tools, Smithing.png',
  ],
  'Lighting': [
    'assets/lpc/Objects/Furniture/Lighting, Floor.png',
    'assets/lpc/Objects/Furniture/Lighting, Outdoors.png',
    'assets/lpc/Objects/Wall Items/Lighting, Wall.png',
  ],
  'Wall Decor': [
    'assets/lpc/Objects/Wall Items/Curtains.png',
    'assets/lpc/Objects/Wall Items/Mirrors.png',
    'assets/lpc/Objects/Wall Items/Paintings, Abstract.png',
    'assets/lpc/Objects/Wall Items/Paintings, Landscape.png',
    'assets/lpc/Objects/Wall Items/Paintings, Portraits.png',
    'assets/lpc/Objects/Wall Items/Paintings, Still Life.png',
    'assets/lpc/Objects/Wall Items/Posters.png',
    'assets/lpc/Objects/Small Items/Tabletop Portraits.png',
  ],
  'Windows': [
    'assets/lpc/Structure/Windows/Ornamental Windows A.png',
    'assets/lpc/Structure/Windows/Ornamental Windows B.png',
    'assets/lpc/Structure/Windows/Stone Windows A.png',
    'assets/lpc/Structure/Windows/Window Awnings A.png',
  ],
  'Structures': [
    'assets/lpc/Structure/Structures/Brick House A.png',
    'assets/lpc/Structure/Structures/Brick House B.png',
    'assets/lpc/Structure/Structures/Paneled House A.png',
  ],
  'Roofing': [
    'assets/lpc/Structure/Roofing/Adobe Brick Roof.png',
    'assets/lpc/Structure/Roofing/Adobe Stucco Roof.png',
    'assets/lpc/Structure/Roofing/Flat Shingle Roof A.png',
    'assets/lpc/Structure/Roofing/Gable Shingle Roof A.png',
    'assets/lpc/Structure/Roofing/Hipped Shingle Roof A.png',
    'assets/lpc/Structure/Roofing/Brick Chimney A.png',
    'assets/lpc/Structure/Roofing/Roof Trim.png',
  ],
  'Pillars & Stairs': [
    'assets/lpc/Structure/Pillars/Floral Pillar A.png',
    'assets/lpc/Structure/Pillars/Stone Pillar A.png',
    'assets/lpc/Structure/Stairs/Formal Interior Stairs A.png',
    'assets/lpc/Structure/Stairs/Wood Interior Stairs A.png',
    'assets/lpc/Structure/Stairs/Wood Interior Stairs B.png',
    'assets/lpc/Structure/Stairs/Short Steps A.png',
    'assets/lpc/Structure/Stairs/Cement Stairs A.png',
  ],
  'Misc': [
    'assets/lpc/Structure/Misc/Fountain A.png',
    'assets/lpc/Structure/Misc/Pool A.png',
    'assets/lpc/Structure/Misc/Prison A.png',
    'assets/lpc/Structure/Misc/Drain A.png',
    'assets/lpc/Structure/Misc/Trellis A.png',
    'assets/lpc/Objects/Furniture/Sewing & Weaving/Loom.png',
    'assets/lpc/Objects/Furniture/Sewing & Weaving/Spinning Wheel.png',
  ],
  'Terrain': [
    'assets/lpc/Terrain/terrain_summer.png',
    'assets/lpc/Terrain/terrain_spring.png',
    'assets/lpc/Terrain/terrain_autumn.png',
    'assets/lpc/Terrain/terrain_winter.png',
    'assets/lpc/Terrain/tilled_soil.png',
  ],
  'Plants': [
    'assets/lpc/Terrain/plants_summer.png',
    'assets/lpc/Terrain/plants_spring.png',
    'assets/lpc/Terrain/flowers.png',
    'assets/lpc/Terrain/mushrooms.png',
  ],
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  IMAGE LOADING
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function loadImage(path) {
  if (imageCache[path] instanceof HTMLImageElement) return Promise.resolve(imageCache[path]);
  if (imageCache[path] === 'loading') {
    return new Promise(res => {
      const check = setInterval(() => {
        if (imageCache[path] instanceof HTMLImageElement) { clearInterval(check); res(imageCache[path]); }
        else if (imageCache[path] === null) { clearInterval(check); res(null); }
      }, 50);
    });
  }
  imageCache[path] = 'loading';
  return new Promise(res => {
    const img = new Image();
    img.onload = () => { imageCache[path] = img; res(img); };
    img.onerror = () => { imageCache[path] = null; res(null); };
    img.src = path;
  });
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  PALETTE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function changePalZoom(delta) {
  PAL_ZOOM = Math.max(0.5, Math.min(6, PAL_ZOOM + delta));
  const lbl = document.getElementById('pal-zoom-label');
  if (lbl) lbl.textContent = PAL_ZOOM + '√ó';
  // Re-render current category
  if (currentCategory) showCategory(currentCategory, document.querySelector('.cat-btn.active'));
}

function buildPaletteCats() {
  const container = document.getElementById('palette-cats');
  container.innerHTML = '';
  const allCats = Object.keys(PALETTE_DATA);
  if (_customObjects.length) allCats.push('üì¶ Custom Objects');
  for (const cat of allCats) {
    const btn = document.createElement('button');
    btn.className = 'cat-btn';
    btn.textContent = cat;
    btn.onclick = () => showCategory(cat, btn);
    container.appendChild(btn);
  }
}

function showCategory(cat, btn) {
  document.querySelectorAll('.cat-btn').forEach(b => b.classList.remove('active'));
  if (btn) btn.classList.add('active');
  currentCategory = cat;

  // Custom Objects category ‚Äî special rendering
  if (cat === 'üì¶ Custom Objects') {
    _showCustomObjectsPalette();
    return;
  }

  const container = document.getElementById('palette-sheets');
  container.innerHTML = '';
  const paths = PALETTE_DATA[cat] || [];
  for (const path of paths) {
    const block = document.createElement('div'); block.className = 'sheet-block';
    const label = document.createElement('div'); label.className = 'sheet-name';
    label.textContent = path.split('/').pop().replace(/\.[^.]+$/, '');
    const wrap = document.createElement('div'); wrap.className = 'sheet-canvas-wrap';
    const pcvs = document.createElement('canvas'); pcvs.className = 'palette-canvas';
    const highlight = document.createElement('div'); highlight.className = 'stamp-highlight';
    highlight.style.display = 'none';
    wrap.appendChild(pcvs); wrap.appendChild(highlight);
    block.appendChild(label); block.appendChild(wrap);
    container.appendChild(block);

    loadImage(path).then(img => {
      if (!img) { label.textContent += ' ‚ö† not found'; return; }
      const cols = Math.floor(img.width / TILE);
      const rows = Math.floor(img.height / TILE);
      const dw = img.width * PAL_ZOOM, dh = img.height * PAL_ZOOM;
      pcvs.width = dw; pcvs.height = dh;
      const pctx = pcvs.getContext('2d');
      pctx.imageSmoothingEnabled = false;
      pctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, dw, dh);
      // Grid
      pctx.strokeStyle = 'rgba(255,255,255,0.18)'; pctx.lineWidth = 0.5;
      for (let c = 0; c <= cols; c++) { pctx.beginPath(); pctx.moveTo(c * TILE * PAL_ZOOM, 0); pctx.lineTo(c * TILE * PAL_ZOOM, dh); pctx.stroke(); }
      for (let r = 0; r <= rows; r++) { pctx.beginPath(); pctx.moveTo(0, r * TILE * PAL_ZOOM); pctx.lineTo(dw, r * TILE * PAL_ZOOM); pctx.stroke(); }

      palHighlightDivs.set(path, highlight);

      pcvs.addEventListener('mousedown', e => {
        const rect = pcvs.getBoundingClientRect();
        const col = Math.floor((e.clientX - rect.left) / PAL_ZOOM / TILE);
        const row = Math.floor((e.clientY - rect.top) / PAL_ZOOM / TILE);
        palDragging = true;
        palDragMeta = { path, cols, rows };
        palDragStart = { col, row }; palDragLive = { col, row };
        updatePalHighlight();
      });
      pcvs.addEventListener('mousemove', e => {
        if (!palDragging || !palDragMeta || palDragMeta.path !== path) return;
        const rect = pcvs.getBoundingClientRect();
        palDragLive = {
          col: Math.max(0, Math.min(cols - 1, Math.floor((e.clientX - rect.left) / PAL_ZOOM / TILE))),
          row: Math.max(0, Math.min(rows - 1, Math.floor((e.clientY - rect.top) / PAL_ZOOM / TILE))),
        };
        updatePalHighlight();
      });
    });
  }
}

function updatePalHighlight() {
  if (!palDragging || !palDragMeta) return;
  const hl = palHighlightDivs.get(palDragMeta.path);
  if (!hl) return;
  const c1 = Math.min(palDragStart.col, palDragLive.col);
  const r1 = Math.min(palDragStart.row, palDragLive.row);
  const c2 = Math.max(palDragStart.col, palDragLive.col);
  const r2 = Math.max(palDragStart.row, palDragLive.row);
  hl.style.display = 'block';
  hl.style.left = (c1 * TILE * PAL_ZOOM) + 'px';
  hl.style.top = (r1 * TILE * PAL_ZOOM) + 'px';
  hl.style.width = ((c2 - c1 + 1) * TILE * PAL_ZOOM) + 'px';
  hl.style.height = ((r2 - r1 + 1) * TILE * PAL_ZOOM) + 'px';
}

window.addEventListener('mouseup', () => {
  if (palDragging && palDragMeta) {
    const c1 = Math.min(palDragStart.col, palDragLive.col);
    const r1 = Math.min(palDragStart.row, palDragLive.row);
    const c2 = Math.max(palDragStart.col, palDragLive.col);
    const r2 = Math.max(palDragStart.row, palDragLive.row);
    setStamp(palDragMeta.path, c1, r1, c2, r2);
  }
  palDragging = false;
});

function setStamp(path, c1, r1, c2, r2) {
  const tiles = [];
  for (let r = r1; r <= r2; r++) {
    for (let c = c1; c <= c2; c++) {
      tiles.push({ localCol: c - c1, localRow: r - r1, sx: c * TILE, sy: r * TILE });
    }
  }
  activeStamp = { sheetPath: path, stampCols: c2 - c1 + 1, stampRows: r2 - r1 + 1, tiles };
  updateStampPreview();
  if (activeTool !== 'paint') setTool('paint');
}

function updateStampPreview() {
  const el = document.getElementById('stamp-preview');
  if (!activeStamp) { el.innerHTML = '<span class="empty">Select a tile from the palette</span>'; return; }
  const pc = document.createElement('canvas');
  pc.width = activeStamp.stampCols * TILE;
  pc.height = activeStamp.stampRows * TILE;
  const pctx = pc.getContext('2d');
  pctx.imageSmoothingEnabled = false;
  // Offset for origin-based stamps (custom objects have negative localCol/Row)
  const offC = activeStamp._originOffCol || 0;
  const offR = activeStamp._originOffRow || 0;
  if (activeStamp._isMultiSheet && activeStamp._srcTiles) {
    // Multi-sheet custom object preview
    const paths = [...new Set(activeStamp._srcTiles.map(t => t.sheetPath).filter(Boolean))];
    Promise.all(paths.map(loadImage)).then(() => {
      for (let i = 0; i < activeStamp.tiles.length; i++) {
        const t = activeStamp.tiles[i];
        const src = activeStamp._srcTiles[i];
        const img = imageCache[src.sheetPath];
        if (!(img instanceof HTMLImageElement)) continue;
        const px = (t.localCol + offC) * TILE, py = (t.localRow + offR) * TILE;
        const rot = t.rotation || 0;
        if (rot) {
          pctx.save();
          pctx.translate(px + TILE/2, py + TILE/2);
          pctx.rotate(rot * Math.PI / 180);
          pctx.drawImage(img, src.sx, src.sy, src.sw || TILE, src.sh || TILE, -TILE/2, -TILE/2, TILE, TILE);
          pctx.restore();
        } else {
          pctx.drawImage(img, src.sx, src.sy, src.sw || TILE, src.sh || TILE, px, py, TILE, TILE);
        }
      }
      el.innerHTML = '';
      el.appendChild(pc);
    });
  } else {
    loadImage(activeStamp.sheetPath).then(img => {
      if (!img) return;
      for (const t of activeStamp.tiles) {
        pctx.drawImage(img, t.sx, t.sy, TILE, TILE, (t.localCol + offC) * TILE, (t.localRow + offR) * TILE, TILE, TILE);
      }
      el.innerHTML = '';
      el.appendChild(pc);
    });
  }
}

function loadCustomSheet() {
  const input = document.createElement('input');
  input.type = 'file'; input.accept = 'image/*';
  input.onchange = e => {
    const file = e.target.files[0]; if (!file) return;
    const url = URL.createObjectURL(file);
    const name = file.name.replace(/\.[^.]+$/, '');
    const catName = 'Custom: ' + name;
    PALETTE_DATA[catName] = [url];
    buildPaletteCats();
    showCategory(catName, document.querySelector('.cat-btn:last-child'));
  };
  input.click();
}

// ‚îÄ‚îÄ‚îÄ Custom Objects Palette ‚îÄ‚îÄ‚îÄ

function _showCustomObjectsPalette() {
  const container = document.getElementById('palette-sheets');
  container.innerHTML = '';
  if (!_customObjects.length) {
    container.innerHTML = '<div style="color:var(--text-dim);padding:8px;font-size:12px">No custom objects available. Create objects in the Sprite Editor.</div>';
    return;
  }
  for (const obj of _customObjects) {
    const card = document.createElement('div');
    card.style.cssText = 'display:flex;align-items:center;gap:8px;padding:6px;margin-bottom:4px;border:1px solid var(--border);border-radius:4px;cursor:pointer;background:var(--input-bg);transition:border-color .15s';
    card.onmouseenter = () => card.style.borderColor = 'var(--gold)';
    card.onmouseleave = () => card.style.borderColor = 'var(--border)';

    // Render a thumbnail
    const thumb = document.createElement('canvas');
    const tiles = obj.tiles || [];
    const bounds = obj.bounds || { minCol: 0, minRow: 0, maxCol: 0, maxRow: 0 };
    const tw = bounds.maxCol - bounds.minCol + 1;
    const th = bounds.maxRow - bounds.minRow + 1;
    const thumbScale = Math.min(48 / (tw * TILE), 48 / (th * TILE), 2);
    thumb.width = Math.ceil(tw * TILE * thumbScale);
    thumb.height = Math.ceil(th * TILE * thumbScale);
    thumb.style.cssText = 'image-rendering:pixelated;background:#111;border-radius:3px;flex-shrink:0';
    const tctx = thumb.getContext('2d');
    tctx.imageSmoothingEnabled = false;
    // Draw tiles once images load
    const paths = [...new Set(tiles.map(t => t.sheetPath).filter(Boolean))];
    Promise.all(paths.map(loadImage)).then(() => {
      for (const t of tiles) {
        const img = imageCache[t.sheetPath];
        if (!(img instanceof HTMLImageElement)) continue;
        const dx = (t.localCol - bounds.minCol) * TILE * thumbScale;
        const dy = (t.localRow - bounds.minRow) * TILE * thumbScale;
        tctx.drawImage(img, t.sx, t.sy, t.sw || TILE, t.sh || TILE,
          dx, dy, TILE * thumbScale, TILE * thumbScale);
      }
    });

    const label = document.createElement('div');
    label.style.cssText = 'font-size:11px;color:var(--text);line-height:1.3';
    label.innerHTML = `<b>${obj.name}</b><br><span style="color:var(--text-dim)">${tw}√ó${th} tiles ¬∑ ${obj.objectType || 'object'}</span>`;

    card.appendChild(thumb);
    card.appendChild(label);
    card.addEventListener('click', () => _selectCustomObject(obj));
    container.appendChild(card);
  }
}

function _selectCustomObject(obj) {
  const tiles = obj.tiles || [];
  if (!tiles.length) return;
  const bounds = obj.bounds || { minCol: 0, minRow: 0, maxCol: 0, maxRow: 0 };
  // Keep raw localCol/localRow so origin (0,0) lands on the clicked tile
  const stampTiles = tiles.map(t => ({
    localCol: t.localCol,
    localRow: t.localRow,
    sx: t.sx, sy: t.sy,
    rotation: t.rotation || 0,
  }));

  // Build rotation variant list: base (default tiles) + any saved rotation variants
  const _rotVariants = [{ label: 'Default', tiles: tiles }];
  if (obj.rotationVariants && obj.rotationVariants.length) {
    for (const rv of obj.rotationVariants) {
      _rotVariants.push({ label: rv.label || 'Variant', tiles: rv.tiles || [] });
    }
  }

  // Build color variant list: base + any saved color variants
  const _colorVariants = [{ label: 'Base', tiles: tiles, rotationVariants: obj.rotationVariants || [] }];
  if (obj.colorVariants && obj.colorVariants.length) {
    for (const cv of obj.colorVariants) {
      _colorVariants.push({
        label: cv.label || 'Variant',
        tiles: cv.tiles || [],
        rotationVariants: cv.rotationVariants || [],
      });
    }
  }

  activeStamp = {
    sheetPath: tiles[0].sheetPath,
    stampCols: bounds.maxCol - bounds.minCol + 1,
    stampRows: bounds.maxRow - bounds.minRow + 1,
    tiles: stampTiles,
    _isMultiSheet: true,
    _srcTiles: tiles.map(t => ({ ...t })),
    _originOffCol: -bounds.minCol,
    _originOffRow: -bounds.minRow,
    _objDefId: obj.id,
    _objName: obj.name,
    _objBounds: { ...bounds },
    _rotVariants: _rotVariants,
    _rotIndex: 0,
    _colorVariants: _colorVariants,
    _colorIndex: 0,
  };
  updateStampPreview();
  if (activeTool !== 'paint') setTool('paint');
}

/** Cycle through the object's rotation variants (R = next, Shift+R = prev). */
function rotateObjectStamp(dir) {
  if (!activeStamp || !activeStamp._isMultiSheet) return;
  // If no rotation variants defined, do nothing
  if (!activeStamp._rotVariants || activeStamp._rotVariants.length <= 1) return;

  // Cycle index
  const len = activeStamp._rotVariants.length;
  activeStamp._rotIndex = ((activeStamp._rotIndex || 0) + dir + len) % len;
  const rv = activeStamp._rotVariants[activeStamp._rotIndex];
  const tiles = rv.tiles || [];
  if (!tiles.length) return;

  // Recompute bounds from this variant's tiles
  let minC = Infinity, minR = Infinity, maxC = -Infinity, maxR = -Infinity;
  for (const t of tiles) {
    if (t.localCol < minC) minC = t.localCol;
    if (t.localCol > maxC) maxC = t.localCol;
    if (t.localRow < minR) minR = t.localRow;
    if (t.localRow > maxR) maxR = t.localRow;
  }

  // Rebuild stamp tiles from this variant
  activeStamp.tiles = tiles.map(t => ({
    localCol: t.localCol,
    localRow: t.localRow,
    sx: t.sx, sy: t.sy,
    rotation: t.rotation || 0,
  }));
  activeStamp._srcTiles = tiles.map(t => ({ ...t }));
  activeStamp.sheetPath = tiles[0].sheetPath;
  activeStamp.stampCols = maxC - minC + 1;
  activeStamp.stampRows = maxR - minR + 1;
  activeStamp._objBounds = { minCol: minC, minRow: minR, maxCol: maxC, maxRow: maxR };
  activeStamp._originOffCol = -minC;
  activeStamp._originOffRow = -minR;

  // Preload images then update preview
  const paths = [...new Set(tiles.map(t => t.sheetPath).filter(Boolean))];
  Promise.all(paths.map(loadImage)).then(() => {
    updateStampPreview();
    renderCanvas();
  });
}

/** Cycle through the object's color variants (T = next, Shift+T = prev). */
function cycleColorVariant(dir) {
  if (!activeStamp || !activeStamp._isMultiSheet) return;
  if (!activeStamp._colorVariants || activeStamp._colorVariants.length <= 1) return;

  const len = activeStamp._colorVariants.length;
  activeStamp._colorIndex = ((activeStamp._colorIndex || 0) + dir + len) % len;
  const cv = activeStamp._colorVariants[activeStamp._colorIndex];
  const tiles = cv.tiles || [];
  if (!tiles.length) return;

  // Recompute bounds
  let minC=Infinity, minR_=Infinity, maxC=-Infinity, maxR_=-Infinity;
  for (const t of tiles){if(t.localCol<minC)minC=t.localCol;if(t.localCol>maxC)maxC=t.localCol;if(t.localRow<minR_)minR_=t.localRow;if(t.localRow>maxR_)maxR_=t.localRow;}

  // Rebuild stamp tiles
  activeStamp.tiles = tiles.map(t => ({ localCol:t.localCol, localRow:t.localRow, sx:t.sx, sy:t.sy, rotation:t.rotation||0 }));
  activeStamp._srcTiles = tiles.map(t => ({ ...t }));
  activeStamp.sheetPath = tiles[0].sheetPath;
  activeStamp.stampCols = maxC - minC + 1;
  activeStamp.stampRows = maxR_ - minR_ + 1;
  activeStamp._objBounds = { minCol:minC, minRow:minR_, maxCol:maxC, maxRow:maxR_ };
  activeStamp._originOffCol = -minC;
  activeStamp._originOffRow = -minR_;

  // Rebuild rotation variants for this color variant
  const _rotVariants = [{ label: 'Default', tiles: tiles }];
  if (cv.rotationVariants && cv.rotationVariants.length) {
    for (const rv of cv.rotationVariants) _rotVariants.push({ label: rv.label || 'Variant', tiles: rv.tiles || [] });
  }
  activeStamp._rotVariants = _rotVariants;
  activeStamp._rotIndex = 0;

  const paths = [...new Set(tiles.map(t => t.sheetPath).filter(Boolean))];
  Promise.all(paths.map(loadImage)).then(() => {
    updateStampPreview();
    renderCanvas();
  });

  showToast(`Color: ${cv.label}`);
}

// ‚îÄ‚îÄ‚îÄ Object layer helpers ‚îÄ‚îÄ‚îÄ

/** Remove a placed object by its anchor key */
function _removeObjectAt(q, r) {
  delete placedObjects[`${q},${r}`];
}

/** Erase any placed object whose footprint covers tile (q,r) */
function _eraseObjectTouching(q, r) {
  for (const [key, obj] of Object.entries(placedObjects)) {
    const [aq, ar] = key.split(',').map(Number);
    for (const t of (obj.tiles || [])) {
      if (aq + t.localCol === q && ar + t.localRow === r) {
        delete placedObjects[key];
        return;
      }
    }
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  TOOLS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function setTool(t) {
  activeTool = t;
  document.querySelectorAll('#tool-btns button').forEach(b => b.classList.remove('active'));
  const btn = document.getElementById('tool-' + (t === 'furniture' ? 'furn' : t === '9tile' ? '9tile' : t));
  if (btn) btn.classList.add('active');
  // Show/hide furniture props
  document.getElementById('furniture-props').style.display = t === 'furniture' ? '' : 'none';
  // If switching away from 9tile, deselect brush
  if (t !== '9tile') {
    // Don't deselect ‚Äî keep brush selected but allow other tools
  }
}

function setLayer(l) {
  activeLayer = l;
  document.querySelectorAll('.layer-btn').forEach(b => b.classList.toggle('active', b.dataset.layer === l));
  renderCanvas();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  CANVAS ‚Äî Rendering
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function screenToTile(sx, sy) {
  const ds = TILE * canvasZoom;
  const q = Math.floor((sx - panX) / ds), r = Math.floor((sy - panY) / ds);
  return { q, r, valid: q >= 0 && q < gridW && r >= 0 && r < gridH };
}

function renderCanvas() {
  const ds = TILE * canvasZoom;
  cvs.width = gridW * ds + panX * 2 + 40;
  cvs.height = gridH * ds + panY * 2 + 40;
  ctx.imageSmoothingEnabled = false;

  // Background
  ctx.fillStyle = '#0a0e17';
  ctx.fillRect(0, 0, cvs.width, cvs.height);

  // Draw layers in order
  for (const layerName of ['floor', 'furniture', 'walls', 'overlay']) {
    const lyr = layers[layerName];
    const isActive = layerName === activeLayer;
    if (!isActive) ctx.globalAlpha = 0.5;
    for (const [key, cell] of Object.entries(lyr)) {
      const [q, r] = key.split(',').map(Number);
      const dx = panX + q * ds, dy = panY + r * ds;
      const img = imageCache[cell.sheetPath];
      if (img instanceof HTMLImageElement) {
        ctx.drawImage(img, cell.sx, cell.sy, cell.sw || TILE, cell.sh || TILE, dx, dy, ds, ds);
      } else {
        ctx.fillStyle = '#333';
        ctx.fillRect(dx, dy, ds, ds);
      }
    }
    ctx.globalAlpha = 1;
  }

  // Draw placed objects on top of layers, depth-sorted by anchor row
  const sortedObjs = Object.entries(placedObjects)
    .map(([key, obj]) => {
      const [aq, ar] = key.split(',').map(Number);
      return { aq, ar, obj };
    })
    .sort((a, b) => {
      if (a.ar !== b.ar) return a.ar - b.ar;
      // Same row: taller objects behind, then rightmost on top
      const aH = a.obj.bounds ? (a.obj.bounds.maxRow - a.obj.bounds.minRow + 1) : 1;
      const bH = b.obj.bounds ? (b.obj.bounds.maxRow - b.obj.bounds.minRow + 1) : 1;
      if (aH !== bH) return bH - aH;
      return a.aq - b.aq;
    });
  for (const { aq, ar, obj } of sortedObjs) {
    for (const t of (obj.tiles || [])) {
      const tq = aq + t.localCol, tr = ar + t.localRow;
      const dx = panX + tq * ds, dy = panY + tr * ds;
      const img = imageCache[t.sheetPath];
      if (img instanceof HTMLImageElement) {
        const rot = t.rotation || 0;
        if (rot) {
          ctx.save();
          ctx.translate(dx + ds/2, dy + ds/2);
          ctx.rotate(rot * Math.PI / 180);
          ctx.drawImage(img, t.sx, t.sy, t.sw || TILE, t.sh || TILE, -ds/2, -ds/2, ds, ds);
          ctx.restore();
        } else {
          ctx.drawImage(img, t.sx, t.sy, t.sw || TILE, t.sh || TILE, dx, dy, ds, ds);
        }
      }
    }
  }

  // Grid overlay
  ctx.strokeStyle = 'rgba(255,255,255,0.12)';
  ctx.lineWidth = 0.5;
  for (let q = 0; q <= gridW; q++) {
    ctx.beginPath(); ctx.moveTo(panX + q * ds, panY); ctx.lineTo(panX + q * ds, panY + gridH * ds); ctx.stroke();
  }
  for (let r = 0; r <= gridH; r++) {
    ctx.beginPath(); ctx.moveTo(panX, panY + r * ds); ctx.lineTo(panX + gridW * ds, panY + r * ds); ctx.stroke();
  }

  // Brush group overlay (show when 9tile tool is active)
  if (activeTool === '9tile') {
    for (const [key, entry] of Object.entries(brushGroupMap)) {
      const [q, r] = key.split(',').map(Number);
      if (q < 0 || q >= gridW || r < 0 || r >= gridH) continue;
      const dx = panX + q * ds, dy = panY + r * ds;
      const brush = nineTileBrushes.find(b => b.id === entry.brushId);
      if (brush) {
        const isFloor = brush.brushType !== 'wall';
        ctx.fillStyle = isFloor ? 'rgba(63,185,80,0.12)' : 'rgba(230,168,23,0.12)';
        ctx.fillRect(dx, dy, ds, ds);
        // Small dot indicator
        ctx.fillStyle = isFloor ? 'rgba(63,185,80,0.5)' : 'rgba(230,168,23,0.5)';
        ctx.beginPath(); ctx.arc(dx + ds - 5, dy + 5, 3, 0, Math.PI * 2); ctx.fill();
      }
    }
  }

  // Meta overlay: impassable, doors, furniture
  for (const [key, m] of Object.entries(meta)) {
    const [q, r] = key.split(',').map(Number);
    const dx = panX + q * ds, dy = panY + r * ds;
    if (m.impassable) {
      ctx.fillStyle = 'rgba(248,81,73,0.25)';
      ctx.fillRect(dx, dy, ds, ds);
      ctx.strokeStyle = 'rgba(248,81,73,0.6)';
      ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.moveTo(dx, dy); ctx.lineTo(dx + ds, dy + ds); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(dx + ds, dy); ctx.lineTo(dx, dy + ds); ctx.stroke();
    }
    if (m.door) {
      ctx.fillStyle = 'rgba(88,166,255,0.3)';
      ctx.fillRect(dx, dy, ds, ds);
      ctx.font = `${ds * 0.5}px sans-serif`;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillStyle = 'rgba(88,166,255,0.9)';
      ctx.fillText('üö™', dx + ds / 2, dy + ds / 2);
    }
    if (m.furniture) {
      ctx.fillStyle = 'rgba(230,168,23,0.2)';
      ctx.fillRect(dx, dy, ds, ds);
      const iconMap = {
        table:'ü™ë',chair:'ü™ë',bed:'üõèÔ∏è',chest:'üì¶',barrel:'üõ¢Ô∏è',bookshelf:'üìö',
        fireplace:'üî•',candle:'üïØÔ∏è',bar:'üç∫',forge:'üî•',anvil:'‚öíÔ∏è',altar:'‚õ™',
        pew:'ü™ë',throne:'üëë',statue:'üóø',stall:'üè™',rack:'‚öîÔ∏è',crate:'üì¶',
        banner:'üè¥',well:'üíß',stairs:'ü™ú',scales:'‚öñÔ∏è',
      };
      ctx.font = `${ds * 0.45}px sans-serif`;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillStyle = 'rgba(230,168,23,0.9)';
      ctx.fillText(iconMap[m.furniture.type] || 'ü™ë', dx + ds / 2, dy + ds / 2);
    }
  }

  // Hover tile highlight + stamp ghost preview
  if (_hoverTile) {
    if (activeTool === 'paint' && activeStamp && activeStamp._isMultiSheet && activeStamp._srcTiles) {
      // Multi-tile object ghost preview
      ctx.globalAlpha = 0.5;
      for (let i = 0; i < activeStamp.tiles.length; i++) {
        const t = activeStamp.tiles[i];
        const src = activeStamp._srcTiles[i];
        const tq = _hoverTile.q + t.localCol, tr = _hoverTile.r + t.localRow;
        const dx = panX + tq * ds, dy = panY + tr * ds;
        const img = imageCache[src.sheetPath];
        if (img instanceof HTMLImageElement) {
          const rot = t.rotation || 0;
          if (rot) {
            ctx.save();
            ctx.translate(dx + ds/2, dy + ds/2);
            ctx.rotate(rot * Math.PI / 180);
            ctx.drawImage(img, src.sx, src.sy, src.sw || TILE, src.sh || TILE, -ds/2, -ds/2, ds, ds);
            ctx.restore();
          } else {
            ctx.drawImage(img, src.sx, src.sy, src.sw || TILE, src.sh || TILE, dx, dy, ds, ds);
          }
        }
      }
      ctx.globalAlpha = 1;
    } else {
      const dx = panX + _hoverTile.q * ds, dy = panY + _hoverTile.r * ds;
      ctx.strokeStyle = 'rgba(230,168,23,0.6)';
      ctx.lineWidth = 2;
      ctx.strokeRect(dx, dy, ds, ds);
    }
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  CANVAS ‚Äî Input
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

let _painting = false, _panning = false, _panStartX = 0, _panStartY = 0;
let _hoverTile = null;

function pushUndo() {
  undoStack.push({
    layers: JSON.parse(JSON.stringify(layers)),
    meta: JSON.parse(JSON.stringify(meta)),
    placedObjects: JSON.parse(JSON.stringify(placedObjects)),
    brushGroupMap: JSON.parse(JSON.stringify(brushGroupMap)),
  });
  if (undoStack.length > MAX_UNDO) undoStack.shift();
  redoStack = [];
}

function undo() {
  if (!undoStack.length) return;
  redoStack.push({ layers: JSON.parse(JSON.stringify(layers)), meta: JSON.parse(JSON.stringify(meta)), placedObjects: JSON.parse(JSON.stringify(placedObjects)), brushGroupMap: JSON.parse(JSON.stringify(brushGroupMap)) });
  const state = undoStack.pop();
  layers = state.layers; meta = state.meta; placedObjects = state.placedObjects || {}; brushGroupMap = state.brushGroupMap || {};
  renderCanvas();
  scheduleAutoSave();
}

function redo() {
  if (!redoStack.length) return;
  undoStack.push({ layers: JSON.parse(JSON.stringify(layers)), meta: JSON.parse(JSON.stringify(meta)), placedObjects: JSON.parse(JSON.stringify(placedObjects)), brushGroupMap: JSON.parse(JSON.stringify(brushGroupMap)) });
  const state = redoStack.pop();
  layers = state.layers; meta = state.meta; placedObjects = state.placedObjects || {}; brushGroupMap = state.brushGroupMap || {};
  renderCanvas();
  scheduleAutoSave();
}

// ‚îÄ‚îÄ Debounced auto-save ‚îÄ‚îÄ
let _autoSaveTimer = null;
function scheduleAutoSave() {
  clearTimeout(_autoSaveTimer);
  _autoSaveTimer = setTimeout(() => _autoSaveInterior(), 1200);
}

/** Silently save current canvas state into interiors[editIdx] and notify parent. */
function _autoSaveInterior() {
  // Need a name to save ‚Äî if none, skip
  const name = document.getElementById('int-name').value.trim();
  if (!name) return;
  // Collect linked buildings
  _linkedBuildingIds = [...document.getElementById('int-linked-buildings').querySelectorAll('input:checked')].map(cb => cb.value);
  const interior = {
    id: slugify(name),
    name,
    linkedBuildingIds: _linkedBuildingIds.length ? [..._linkedBuildingIds] : undefined,
    buildingType: document.getElementById('int-type').value,
    tags: document.getElementById('int-tags').value.trim().split(',').map(s => s.trim()).filter(Boolean),
    variantGroup: document.getElementById('int-group').value.trim() || null,
    tileW: TILE, tileH: TILE,
    width: gridW, height: gridH,
    layers: {
      floor: { ...layers.floor },
      furniture: { ...layers.furniture },
      walls: { ...layers.walls },
      overlay: { ...layers.overlay },
    },
    meta: { ...meta },
    placedObjects: JSON.parse(JSON.stringify(placedObjects)),
    brushGroupMap: JSON.parse(JSON.stringify(brushGroupMap)),
    nineTileBrushes: JSON.parse(JSON.stringify(nineTileBrushes)),
  };
  if (editIdx >= 0) {
    interiors[editIdx] = interior;
  } else {
    interiors.push(interior);
    editIdx = interiors.length - 1;
    refreshList();
  }
  notifyParent();
  console.log('[AutoSave] interior saved');
}

function applyTool(sx, sy) {
  const { q, r, valid } = screenToTile(sx, sy);
  if (!valid) return;
  const key = `${q},${r}`;
  const store = layers[activeLayer];

  switch (activeTool) {
    case 'paint':
      if (!activeStamp) return;
      if (activeStamp._isMultiSheet && activeStamp._srcTiles) {
        // Custom object: place as a single object on the objects layer
        // Remove any existing object whose footprint overlaps the anchor
        _removeObjectAt(q, r);
        placedObjects[key] = {
          defId: activeStamp._objDefId || null,
          name: activeStamp._objName || 'Object',
          tiles: activeStamp._srcTiles.map(t => ({ ...t })),
          bounds: activeStamp._objBounds || null,
        };
      } else {
        for (const t of activeStamp.tiles) {
          const tq = q + t.localCol, tr = r + t.localRow;
          if (tq < 0 || tq >= gridW || tr < 0 || tr >= gridH) continue;
          store[`${tq},${tr}`] = {
            sheetPath: activeStamp.sheetPath,
            sx: t.sx, sy: t.sy, sw: TILE, sh: TILE,
          };
        }
      }
      break;

    case 'erase':
      // Also erase any placed object whose anchor or footprint covers this tile
      _eraseObjectTouching(q, r);
      // Also erase any brush group at this tile
      nineTileErase(q, r);
      delete store[key];
      break;

    case 'fill':
      if (!activeStamp || activeStamp.tiles.length === 0) return;
      floodFill(q, r);
      break;

    case 'eyedrop': {
      // Pick the top visible tile at q,r from any layer (overlay ‚Üí walls ‚Üí floor)
      for (const ln of ['overlay', 'walls', 'floor']) {
        const cell = layers[ln][key];
        if (cell) {
          activeStamp = {
            sheetPath: cell.sheetPath, stampCols: 1, stampRows: 1,
            tiles: [{ localCol: 0, localRow: 0, sx: cell.sx, sy: cell.sy }],
          };
          setLayer(ln);
          updateStampPreview();
          setTool('paint');
          return;
        }
      }
      break;
    }

    case 'impass': {
      if (!meta[key]) meta[key] = {};
      meta[key].impassable = !meta[key].impassable;
      if (!meta[key].impassable && !meta[key].door && !meta[key].furniture) delete meta[key];
      break;
    }

    case 'door': {
      // Clear any existing door, then set this tile
      for (const [k, m] of Object.entries(meta)) {
        if (m.door) { delete m.door; if (!m.impassable && !m.furniture) delete meta[k]; }
      }
      if (!meta[key]) meta[key] = {};
      meta[key].door = true;
      break;
    }

    case 'furniture': {
      const furnType = document.getElementById('furn-type').value;
      const furnName = document.getElementById('furn-name').value.trim();
      const furnPassable = document.getElementById('furn-passable').checked;
      const iconMap = {
        table:'ü™ë',chair:'ü™ë',bed:'üõèÔ∏è',chest:'üì¶',barrel:'üõ¢Ô∏è',bookshelf:'üìö',
        fireplace:'üî•',candle:'üïØÔ∏è',bar:'üç∫',forge:'üî•',anvil:'‚öíÔ∏è',altar:'‚õ™',
        pew:'ü™ë',throne:'üëë',statue:'üóø',stall:'üè™',rack:'‚öîÔ∏è',crate:'üì¶',
        banner:'üè¥',well:'üíß',stairs:'ü™ú',scales:'‚öñÔ∏è',
      };
      if (!meta[key]) meta[key] = {};
      // Toggle: if clicking same furniture, remove it
      if (meta[key].furniture && meta[key].furniture.type === furnType) {
        delete meta[key].furniture;
        if (!meta[key].impassable && !meta[key].door) delete meta[key];
      } else {
        meta[key].furniture = {
          type: furnType,
          name: furnName || (furnType.charAt(0).toUpperCase() + furnType.slice(1)),
          icon: iconMap[furnType] || 'ü™ë',
          passable: furnPassable,
        };
        // Furniture is typically also impassable
        if (!furnPassable) meta[key].impassable = true;
      }
      break;
    }

    case '9tile': {
      if (activeNineBrush !== null) {
        nineTilePaint(q, r);
      }
      break;
    }
  }
  renderCanvas();
}

function floodFill(startQ, startR) {
  if (!activeStamp || !activeStamp.tiles.length) return;
  const store = layers[activeLayer];
  const t0 = activeStamp.tiles[0];
  const targetKey = store[`${startQ},${startR}`];
  const targetStr = targetKey ? JSON.stringify(targetKey) : '__empty__';
  const newStr = JSON.stringify({ sheetPath: activeStamp.sheetPath, sx: t0.sx, sy: t0.sy, sw: TILE, sh: TILE });
  if (targetStr === newStr) return;

  const visited = new Set();
  const queue = [{ q: startQ, r: startR }];
  while (queue.length) {
    const { q, r } = queue.shift();
    const key = `${q},${r}`;
    if (visited.has(key)) continue;
    if (q < 0 || q >= gridW || r < 0 || r >= gridH) continue;
    const cellStr = store[key] ? JSON.stringify(store[key]) : '__empty__';
    if (cellStr !== targetStr) continue;
    visited.add(key);
    // Paint with tiled stamp
    const tq = ((q - startQ) % activeStamp.stampCols + activeStamp.stampCols) % activeStamp.stampCols;
    const tr = ((r - startR) % activeStamp.stampRows + activeStamp.stampRows) % activeStamp.stampRows;
    const tile = activeStamp.tiles.find(t => t.localCol === tq && t.localRow === tr) || activeStamp.tiles[0];
    store[key] = { sheetPath: activeStamp.sheetPath, sx: tile.sx, sy: tile.sy, sw: TILE, sh: TILE };
    queue.push({ q: q - 1, r }, { q: q + 1, r }, { q, r: r - 1 }, { q, r: r + 1 });
  }
}

function initCanvas() {
  cvs = document.getElementById('build-canvas');
  ctx = cvs.getContext('2d');

  const wrap = document.getElementById('canvas-wrap');

  cvs.addEventListener('mousedown', e => {
    const rect = cvs.getBoundingClientRect();
    const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
    if (e.button === 1 || (e.button === 0 && e.altKey)) {
      _panning = true; _panStartX = e.clientX - panX; _panStartY = e.clientY - panY;
      e.preventDefault(); return;
    }
    if (e.button === 0) {
      pushUndo();
      _painting = true;
      applyTool(sx, sy);
    }
  });

  cvs.addEventListener('mousemove', e => {
    const rect = cvs.getBoundingClientRect();
    const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
    if (_panning) { panX = e.clientX - _panStartX; panY = e.clientY - _panStartY; renderCanvas(); return; }
    const t = screenToTile(sx, sy);
    _hoverTile = t.valid ? t : null;
    if (_painting) { applyTool(sx, sy); }
    else { renderCanvas(); }
  });

  cvs.addEventListener('mouseup', () => { if (_painting) { _painting = false; scheduleAutoSave(); } _painting = false; _panning = false; });
  cvs.addEventListener('mouseleave', () => { if (_painting) scheduleAutoSave(); _painting = false; _panning = false; _hoverTile = null; renderCanvas(); });

  cvs.addEventListener('wheel', e => {
    e.preventDefault();
    const old = canvasZoom;
    canvasZoom = Math.max(0.5, Math.min(6, canvasZoom + (e.deltaY < 0 ? 0.25 : -0.25)));
    // Zoom toward cursor
    const rect = cvs.getBoundingClientRect();
    const mx = e.clientX - rect.left, my = e.clientY - rect.top;
    const ratio = canvasZoom / old;
    panX = mx - (mx - panX) * ratio;
    panY = my - (my - panY) * ratio;
    renderCanvas();
  }, { passive: false });

  // Keyboard shortcuts
  window.addEventListener('keydown', e => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;
    if (e.ctrlKey && e.key === 'z') { e.preventDefault(); undo(); }
    if (e.ctrlKey && e.key === 'y') { e.preventDefault(); redo(); }
    if (e.key === 'b' || e.key === 'B') setTool('paint');
    if (e.key === 'e' || e.key === 'E') setTool('erase');
    if (e.key === 'g' || e.key === 'G') setTool('fill');
    if (e.key === 'i' || e.key === 'I') setTool('eyedrop');
    if (e.key === 'f' || e.key === 'F') setTool('furniture');
    if (e.key === 'n' || e.key === 'N') setTool('9tile');
    if (e.key === 'r' && !e.shiftKey) rotateObjectStamp(1);    // R = rotate CW
    if (e.key === 'R' && e.shiftKey)  rotateObjectStamp(-1);   // Shift+R = rotate CCW
    if (e.key === 't' && !e.shiftKey) cycleColorVariant(1);    // T = next color variant
    if (e.key === 'T' && e.shiftKey)  cycleColorVariant(-1);   // Shift+T = prev color variant
  });
}

function zoomIn()  { canvasZoom = Math.min(6, canvasZoom + 0.5); renderCanvas(); }
function zoomOut() { canvasZoom = Math.max(0.5, canvasZoom - 0.5); renderCanvas(); }
function fitCanvas() {
  const wrap = document.getElementById('canvas-wrap');
  const ds = TILE * canvasZoom;
  const totalW = gridW * ds, totalH = gridH * ds;
  const ww = wrap.clientWidth, wh = wrap.clientHeight;
  canvasZoom = Math.min(ww / (gridW * TILE) * 0.9, wh / (gridH * TILE) * 0.9, 4);
  panX = (ww - gridW * TILE * canvasZoom) / 2;
  panY = (wh - gridH * TILE * canvasZoom) / 2;
  renderCanvas();
}

function resizeGrid() {
  const w = parseInt(document.getElementById('grid-w').value) || 10;
  const h = parseInt(document.getElementById('grid-h').value) || 8;
  gridW = Math.max(4, Math.min(30, w));
  gridH = Math.max(4, Math.min(30, h));
  // Trim tiles outside new bounds
  for (const lyr of Object.values(layers)) {
    for (const key of Object.keys(lyr)) {
      const [q, r] = key.split(',').map(Number);
      if (q >= gridW || r >= gridH) delete lyr[key];
    }
  }
  for (const key of Object.keys(meta)) {
    const [q, r] = key.split(',').map(Number);
    if (q >= gridW || r >= gridH) delete meta[key];
  }
  for (const key of Object.keys(brushGroupMap)) {
    const [q, r] = key.split(',').map(Number);
    if (q >= gridW || r >= gridH) delete brushGroupMap[key];
  }
  fitCanvas();
  scheduleAutoSave();
}

function clearLayer() {
  pushUndo();
  layers[activeLayer] = {};
  renderCanvas();
  scheduleAutoSave();
}

function clearAll() {
  pushUndo();
  layers = { floor: {}, furniture: {}, walls: {}, overlay: {} };
  meta = {};
  placedObjects = {};
  brushGroupMap = {};
  renderCanvas();
  scheduleAutoSave();
}

// ‚îÄ‚îÄ‚îÄ Palette resize drag ‚îÄ‚îÄ‚îÄ
function initPaletteResize() {
  const panel = document.getElementById('palette-panel');
  const handle = document.getElementById('pal-resizer');
  let dragging = false;
  handle.addEventListener('mousedown', e => { dragging = true; e.preventDefault(); });
  window.addEventListener('mousemove', e => {
    if (!dragging) return;
    const w = Math.max(180, Math.min(600, e.clientX));
    panel.style.width = w + 'px';
  });
  window.addEventListener('mouseup', () => { dragging = false; });
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  TOAST NOTIFICATIONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let _toastTimer = null;
function toast(msg, type) {
  const el = document.getElementById('toast');
  if (!el) return;
  el.textContent = msg;
  el.className = type || '';
  el.style.display = 'block';
  clearTimeout(_toastTimer);
  _toastTimer = setTimeout(() => { el.style.display = 'none'; }, 2200);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  NINE-TILE BRUSH SYSTEM
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const NTB_LABELS = [
  ['TL', 'Top', 'TR'],
  ['Left', 'Center', 'Right'],
  ['BL', 'Bottom', 'BR']
];
const NTB_IC_LABELS = ['IC-TL', 'IC-TR', 'IC-BL', 'IC-BR'];
// Corridor pieces for wall brushes:
// H-corridor (horizontal hall), V-corridor (vertical hall),
// T-junctions (3 neighbors), Cross (4-way)
const NTB_CORRIDOR_LABELS = ['V-Hall', 'H-Hall', 'T-Down', 'T-Up', 'T-Right', 'T-Left', 'Cross', 'Solo'];
const NTB_ENDCAP_LABELS = ['End-N', 'End-S', 'End-W', 'End-E'];

// NTB editor state
let ntbEditIdx = -1;
let ntbBrushType = 'floor';   // 'floor' or 'wall'
let ntbSelSlot = null;         // {row, col} or {type:'ic',idx} or {type:'corr',idx} or {type:'end',idx}
let ntbTiles = [[null,null,null],[null,null,null],[null,null,null]];
let ntbCorners = [null, null, null, null];
let ntbCorridors = new Array(8).fill(null);  // V-Hall, H-Hall, T-Down, T-Up, T-Right, T-Left, Cross, Solo
let ntbEndCaps = new Array(4).fill(null);    // End-N, End-S, End-W, End-E
let ntbSheet = null;
let ntbImgCols = 0, ntbImgRows = 0;
let ntbDragStart = null;
let ntbDragCur = null;
const NTB_SCALE = 2;
let ntbActiveCat = '';
let _ntbCanvasEventsSet = false;

function ntbEmptyGrid() { return [[null,null,null],[null,null,null],[null,null,null]]; }
function ntbEmptyCorners() { return [null, null, null, null]; }
function ntbEmptyCorridors() { return new Array(8).fill(null); }
function ntbEmptyEndCaps() { return new Array(4).fill(null); }

// ‚îÄ‚îÄ Left panel brush list (in props panel) ‚îÄ‚îÄ
function buildNtbListPanel() {
  const list = document.getElementById('ntb-list-panel');
  if (!list) return;
  list.innerHTML = '';
  if (nineTileBrushes.length === 0) {
    list.innerHTML = '<div style="font-size:11px;color:var(--text-dim);padding:4px 0">No brushes yet ‚Äî click Ôºã to create one</div>';
    return;
  }
  nineTileBrushes.forEach((brush, i) => {
    const card = document.createElement('div');
    card.className = 'ntb-brush-card' + (activeNineBrush === i ? ' selected' : '');
    card.onclick = () => selectNineBrush(i);
    card.ondblclick = () => openNtbEditor(i);
    card.title = 'Click to select for painting, double-click to edit';
    const cvs2 = document.createElement('canvas');
    cvs2.width = 24; cvs2.height = 24;
    const ctx2 = cvs2.getContext('2d');
    ctx2.imageSmoothingEnabled = false;
    const ctr = brush.tiles[1] && brush.tiles[1][1];
    if (ctr) {
      const img = imageCache[ctr.sheetPath];
      if (img instanceof HTMLImageElement) ctx2.drawImage(img, ctr.sx, ctr.sy, TILE, TILE, 0, 0, 24, 24);
    } else { ctx2.fillStyle = '#333'; ctx2.fillRect(0, 0, 24, 24); }
    card.appendChild(cvs2);
    const name = document.createElement('span');
    name.className = 'ntb-bname';
    name.textContent = brush.name;
    card.appendChild(name);
    const typeBadge = document.createElement('span');
    typeBadge.className = 'ntb-btype ' + (brush.brushType || 'floor');
    typeBadge.textContent = brush.brushType || 'floor';
    card.appendChild(typeBadge);
    list.appendChild(card);
  });
}

function selectNineBrush(idx) {
  activeNineBrush = (activeNineBrush === idx) ? null : idx;
  if (activeNineBrush !== null) {
    activeStamp = null;
    // Auto-switch to the target layer for this brush
    const brush = nineTileBrushes[activeNineBrush];
    if (brush) setLayer(brush.brushType === 'wall' ? 'walls' : 'floor');
    if (activeTool !== '9tile') setTool('9tile');
  }
  buildNtbListPanel();
  updateStampPreview();
}

// ‚îÄ‚îÄ Nine-Tile Brush Editor Modal ‚îÄ‚îÄ
function ntbSetType(type) {
  ntbBrushType = type;
  document.getElementById('ntb-type-floor').classList.toggle('active', type === 'floor');
  document.getElementById('ntb-type-wall').classList.toggle('active', type === 'wall');
  document.getElementById('ntb-corridor-section').style.display = type === 'wall' ? '' : 'none';
}

function openNtbEditor(idx) {
  ntbEditIdx = (idx !== undefined) ? idx : -1;
  const modal = document.getElementById('ntbModal');
  modal.style.display = 'flex';
  if (ntbEditIdx >= 0 && nineTileBrushes[ntbEditIdx]) {
    const brush = nineTileBrushes[ntbEditIdx];
    document.getElementById('ntb-name').value = brush.name;
    ntbTiles = brush.tiles.map(row => row.map(t => t ? {...t} : null));
    ntbCorners = (brush.insideCorners || ntbEmptyCorners()).map(t => t ? {...t} : null);
    ntbCorridors = (brush.corridors || ntbEmptyCorridors()).map(t => t ? {...t} : null);
    ntbEndCaps = (brush.endCaps || ntbEmptyEndCaps()).map(t => t ? {...t} : null);
    ntbBrushType = brush.brushType || 'floor';
    document.getElementById('ntb-del-btn').disabled = false;
    // Populate cost fields
    const c = brush.cost || {};
    const cr = c.resources || {};
    document.getElementById('ntb-cost-gold').value = c.gold || 0;
    _renderNtbCostResourceRows(cr);
  } else {
    ntbEditIdx = -1;
    document.getElementById('ntb-name').value = 'New Brush';
    ntbTiles = ntbEmptyGrid();
    ntbCorners = ntbEmptyCorners();
    ntbCorridors = ntbEmptyCorridors();
    ntbEndCaps = ntbEmptyEndCaps();
    ntbBrushType = 'floor';
    document.getElementById('ntb-del-btn').disabled = true;
    // Default costs
    document.getElementById('ntb-cost-gold').value = 0;
    _renderNtbCostResourceRows({});
  }
  ntbSetType(ntbBrushType);
  ntbSelSlot = null;
  ntbDragStart = null; ntbDragCur = null;
  ntbBuildGrid();
  ntbBuildBrushList();
  ntbBuildCatButtons();
  if (!ntbSheet) {
    const cats = Object.keys(PALETTE_DATA);
    if (cats.length > 0) ntbShowCategory(cats[0]);
  } else {
    ntbRenderSheetCanvas(ntbSheet);
  }
  ntbSetupCanvasEvents();
}

function closeNtbEditor() {
  document.getElementById('ntbModal').style.display = 'none';
  buildNtbListPanel();
}

function ntbBuildGrid() {
  // Main 3√ó3 grid
  const grid = document.getElementById('ntb-grid');
  grid.innerHTML = '';
  for (let r = 0; r < 3; r++) {
    for (let c = 0; c < 3; c++) {
      const cell = document.createElement('div');
      const isSel = ntbSelSlot && !ntbSelSlot.type && ntbSelSlot.row === r && ntbSelSlot.col === c;
      const tileRef = ntbTiles[r][c];
      cell.className = 'ntb-cell' + (isSel ? ' ntb-selected' : '') + (tileRef ? ' ntb-filled' : '');
      cell.onclick = () => { ntbSelSlot = {row: r, col: c}; ntbBuildGrid(); };
      cell.oncontextmenu = ev => { ev.preventDefault(); ntbTiles[r][c] = null; ntbBuildGrid(); };
      if (tileRef) {
        const tc = document.createElement('canvas');
        tc.width = 32; tc.height = 32;
        const tctx = tc.getContext('2d');
        tctx.imageSmoothingEnabled = false;
        const img = imageCache[tileRef.sheetPath];
        if (img instanceof HTMLImageElement) tctx.drawImage(img, tileRef.sx, tileRef.sy, TILE, TILE, 0, 0, 32, 32);
        cell.appendChild(tc);
      }
      const lbl = document.createElement('div');
      lbl.className = 'ntb-cell-lbl';
      lbl.textContent = NTB_LABELS[r][c];
      cell.appendChild(lbl);
      grid.appendChild(cell);
    }
  }
  // Inside corners grid
  const icGrid = document.getElementById('ntb-ic-grid');
  icGrid.innerHTML = '';
  for (let i = 0; i < 4; i++) {
    const cell = document.createElement('div');
    const isSel = ntbSelSlot && ntbSelSlot.type === 'ic' && ntbSelSlot.idx === i;
    const tileRef = ntbCorners[i];
    cell.className = 'ntb-cell' + (isSel ? ' ntb-selected' : '') + (tileRef ? ' ntb-filled' : '');
    cell.onclick = () => { ntbSelSlot = {type:'ic', idx:i}; ntbBuildGrid(); };
    cell.oncontextmenu = ev => { ev.preventDefault(); ntbCorners[i] = null; ntbBuildGrid(); };
    if (tileRef) {
      const tc = document.createElement('canvas');
      tc.width = 32; tc.height = 32;
      const tctx = tc.getContext('2d');
      tctx.imageSmoothingEnabled = false;
      const img = imageCache[tileRef.sheetPath];
      if (img instanceof HTMLImageElement) tctx.drawImage(img, tileRef.sx, tileRef.sy, TILE, TILE, 0, 0, 32, 32);
      cell.appendChild(tc);
    }
    const lbl = document.createElement('div');
    lbl.className = 'ntb-cell-lbl';
    lbl.textContent = NTB_IC_LABELS[i];
    cell.appendChild(lbl);
    icGrid.appendChild(cell);
  }
  // Corridor grid (wall brushes only)
  const corrGrid = document.getElementById('ntb-corridor-grid');
  corrGrid.innerHTML = '';
  for (let i = 0; i < NTB_CORRIDOR_LABELS.length; i++) {
    const cell = document.createElement('div');
    const isSel = ntbSelSlot && ntbSelSlot.type === 'corr' && ntbSelSlot.idx === i;
    const tileRef = ntbCorridors[i];
    cell.className = 'ntb-cell' + (isSel ? ' ntb-selected' : '') + (tileRef ? ' ntb-filled' : '');
    cell.onclick = () => { ntbSelSlot = {type:'corr', idx:i}; ntbBuildGrid(); };
    cell.oncontextmenu = ev => { ev.preventDefault(); ntbCorridors[i] = null; ntbBuildGrid(); };
    if (tileRef) {
      const tc = document.createElement('canvas');
      tc.width = 32; tc.height = 32;
      const tctx = tc.getContext('2d');
      tctx.imageSmoothingEnabled = false;
      const img = imageCache[tileRef.sheetPath];
      if (img instanceof HTMLImageElement) tctx.drawImage(img, tileRef.sx, tileRef.sy, TILE, TILE, 0, 0, 32, 32);
      cell.appendChild(tc);
    }
    const lbl = document.createElement('div');
    lbl.className = 'ntb-cell-lbl';
    lbl.textContent = NTB_CORRIDOR_LABELS[i];
    cell.appendChild(lbl);
    corrGrid.appendChild(cell);
  }
  // End cap grid
  const endGrid = document.getElementById('ntb-endcap-grid');
  endGrid.innerHTML = '';
  for (let i = 0; i < NTB_ENDCAP_LABELS.length; i++) {
    const cell = document.createElement('div');
    const isSel = ntbSelSlot && ntbSelSlot.type === 'end' && ntbSelSlot.idx === i;
    const tileRef = ntbEndCaps[i];
    cell.className = 'ntb-cell' + (isSel ? ' ntb-selected' : '') + (tileRef ? ' ntb-filled' : '');
    cell.onclick = () => { ntbSelSlot = {type:'end', idx:i}; ntbBuildGrid(); };
    cell.oncontextmenu = ev => { ev.preventDefault(); ntbEndCaps[i] = null; ntbBuildGrid(); };
    if (tileRef) {
      const tc = document.createElement('canvas');
      tc.width = 32; tc.height = 32;
      const tctx = tc.getContext('2d');
      tctx.imageSmoothingEnabled = false;
      const img = imageCache[tileRef.sheetPath];
      if (img instanceof HTMLImageElement) tctx.drawImage(img, tileRef.sx, tileRef.sy, TILE, TILE, 0, 0, 32, 32);
      cell.appendChild(tc);
    }
    const lbl = document.createElement('div');
    lbl.className = 'ntb-cell-lbl';
    lbl.textContent = NTB_ENDCAP_LABELS[i];
    cell.appendChild(lbl);
    endGrid.appendChild(cell);
  }
}

function ntbBuildBrushList() {
  const list = document.getElementById('ntb-brush-list');
  list.innerHTML = '';
  if (nineTileBrushes.length === 0) {
    list.innerHTML = '<div style="font-size:11px;color:var(--text-dim)">No saved brushes</div>';
    return;
  }
  nineTileBrushes.forEach((brush, i) => {
    const card = document.createElement('div');
    card.className = 'ntb-brush-card' + (ntbEditIdx === i ? ' selected' : '');
    card.onclick = () => openNtbEditor(i);
    const cvs2 = document.createElement('canvas');
    cvs2.width = 24; cvs2.height = 24;
    const ctx2 = cvs2.getContext('2d');
    ctx2.imageSmoothingEnabled = false;
    const ctr = brush.tiles[1] && brush.tiles[1][1];
    if (ctr) {
      const img = imageCache[ctr.sheetPath];
      if (img instanceof HTMLImageElement) ctx2.drawImage(img, ctr.sx, ctr.sy, TILE, TILE, 0, 0, 24, 24);
    }
    card.appendChild(cvs2);
    const name = document.createElement('span');
    name.className = 'ntb-bname';
    name.textContent = brush.name;
    card.appendChild(name);
    const typeBadge = document.createElement('span');
    typeBadge.className = 'ntb-btype ' + (brush.brushType || 'floor');
    typeBadge.textContent = brush.brushType || 'floor';
    card.appendChild(typeBadge);
    list.appendChild(card);
  });
}

function ntbBuildCatButtons() {
  const container = document.getElementById('ntb-cat-btns');
  container.innerHTML = '';
  const cats = Object.keys(PALETTE_DATA);
  for (const cat of cats) {
    const btn = document.createElement('button');
    btn.style.cssText = 'font-size:10px;padding:2px 7px;border-radius:4px';
    btn.textContent = cat;
    btn.className = (cat === ntbActiveCat) ? 'active' : '';
    btn.onclick = () => ntbShowCategory(cat);
    container.appendChild(btn);
  }
}

function ntbShowCategory(cat) {
  ntbActiveCat = cat;
  ntbBuildCatButtons();
  const paths = PALETTE_DATA[cat] || [];
  // Build a sheet selector below the cat buttons
  const container = document.getElementById('ntb-cat-btns');
  const existing = document.getElementById('ntb-sheet-list-wrap');
  if (existing) existing.remove();
  if (paths.length > 1) {
    const wrap = document.createElement('div');
    wrap.id = 'ntb-sheet-list-wrap';
    wrap.style.cssText = 'display:flex;flex-wrap:wrap;gap:3px;margin-top:4px;width:100%';
    for (const p of paths) {
      const btn = document.createElement('button');
      btn.style.cssText = 'font-size:9px;padding:2px 6px;border-radius:3px';
      btn.textContent = p.split('/').pop().replace(/\.[^.]+$/, '');
      btn.className = (p === ntbSheet) ? 'active' : '';
      btn.onclick = () => {
        ntbSheet = p;
        loadImage(p).then(() => ntbRenderSheetCanvas(p));
        wrap.querySelectorAll('button').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
      };
      wrap.appendChild(btn);
    }
    container.parentElement.appendChild(wrap);
  }
  if (paths.length > 0) {
    ntbSheet = paths[0];
    loadImage(ntbSheet).then(() => ntbRenderSheetCanvas(ntbSheet));
  }
}

function ntbRenderSheetCanvas(sheetPath) {
  const cvs = document.getElementById('ntb-tileset-canvas');
  const ctx2 = cvs.getContext('2d');
  const img = imageCache[sheetPath];
  if (!(img instanceof HTMLImageElement)) return;
  ntbImgCols = Math.floor(img.width / TILE);
  ntbImgRows = Math.floor(img.height / TILE);
  const dw = img.width * NTB_SCALE, dh = img.height * NTB_SCALE;
  cvs.width = dw; cvs.height = dh;
  ctx2.imageSmoothingEnabled = false;
  ctx2.drawImage(img, 0, 0, img.width, img.height, 0, 0, dw, dh);
  // Grid lines
  ctx2.strokeStyle = 'rgba(255,255,255,0.18)'; ctx2.lineWidth = 0.5;
  for (let c = 0; c <= ntbImgCols; c++) { ctx2.beginPath(); ctx2.moveTo(c * TILE * NTB_SCALE, 0); ctx2.lineTo(c * TILE * NTB_SCALE, dh); ctx2.stroke(); }
  for (let r = 0; r <= ntbImgRows; r++) { ctx2.beginPath(); ctx2.moveTo(0, r * TILE * NTB_SCALE); ctx2.lineTo(dw, r * TILE * NTB_SCALE); ctx2.stroke(); }
  // Highlight drag region
  if (ntbDragStart && ntbDragCur) {
    const c1 = Math.min(ntbDragStart.col, ntbDragCur.col), r1 = Math.min(ntbDragStart.row, ntbDragCur.row);
    const c2 = Math.max(ntbDragStart.col, ntbDragCur.col), r2 = Math.max(ntbDragStart.row, ntbDragCur.row);
    ctx2.fillStyle = 'rgba(230,168,23,0.2)';
    ctx2.fillRect(c1 * TILE * NTB_SCALE, r1 * TILE * NTB_SCALE, (c2-c1+1) * TILE * NTB_SCALE, (r2-r1+1) * TILE * NTB_SCALE);
    ctx2.strokeStyle = 'var(--gold)'; ctx2.lineWidth = 2;
    ctx2.strokeRect(c1 * TILE * NTB_SCALE, r1 * TILE * NTB_SCALE, (c2-c1+1) * TILE * NTB_SCALE, (r2-r1+1) * TILE * NTB_SCALE);
  }
}

function ntbSetupCanvasEvents() {
  if (_ntbCanvasEventsSet) return;
  _ntbCanvasEventsSet = true;
  const cvs = document.getElementById('ntb-tileset-canvas');
  cvs.addEventListener('mousedown', e => {
    const rect = cvs.getBoundingClientRect();
    const col = Math.floor((e.clientX - rect.left) / NTB_SCALE / TILE);
    const row = Math.floor((e.clientY - rect.top) / NTB_SCALE / TILE);
    if (col < 0 || col >= ntbImgCols || row < 0 || row >= ntbImgRows) return;
    ntbDragStart = {col, row};
    ntbDragCur = {col, row};
    ntbRenderSheetCanvas(ntbSheet);
  });
  cvs.addEventListener('mousemove', e => {
    if (!ntbDragStart) return;
    const rect = cvs.getBoundingClientRect();
    ntbDragCur = {
      col: Math.max(0, Math.min(ntbImgCols - 1, Math.floor((e.clientX - rect.left) / NTB_SCALE / TILE))),
      row: Math.max(0, Math.min(ntbImgRows - 1, Math.floor((e.clientY - rect.top) / NTB_SCALE / TILE))),
    };
    ntbRenderSheetCanvas(ntbSheet);
  });
  cvs.addEventListener('mouseup', () => {
    if (!ntbDragStart || !ntbDragCur) return;
    const c1 = Math.min(ntbDragStart.col, ntbDragCur.col), r1 = Math.min(ntbDragStart.row, ntbDragCur.row);
    const c2 = Math.max(ntbDragStart.col, ntbDragCur.col), r2 = Math.max(ntbDragStart.row, ntbDragCur.row);
    const w = c2 - c1 + 1, h = r2 - r1 + 1;

    if (w === 3 && h === 3) {
      // Auto-assign 3√ó3 to main grid
      for (let dr = 0; dr < 3; dr++) for (let dc = 0; dc < 3; dc++) {
        ntbTiles[dr][dc] = { sheetPath: ntbSheet, sx: (c1+dc)*TILE, sy: (r1+dr)*TILE };
      }
      toast('3√ó3 outer tiles assigned', 'ok');
    } else if (w === 2 && h === 2) {
      // Auto-assign 2√ó2 to inside corners
      ntbCorners[0] = { sheetPath: ntbSheet, sx: c1*TILE, sy: r1*TILE };
      ntbCorners[1] = { sheetPath: ntbSheet, sx: (c1+1)*TILE, sy: r1*TILE };
      ntbCorners[2] = { sheetPath: ntbSheet, sx: c1*TILE, sy: (r1+1)*TILE };
      ntbCorners[3] = { sheetPath: ntbSheet, sx: (c1+1)*TILE, sy: (r1+1)*TILE };
      toast('2√ó2 inside corners assigned', 'ok');
    } else if (w === 1 && h === 1) {
      // Single tile: assign to selected slot
      const ref = { sheetPath: ntbSheet, sx: c1*TILE, sy: r1*TILE };
      if (ntbSelSlot) {
        if (ntbSelSlot.type === 'ic') ntbCorners[ntbSelSlot.idx] = ref;
        else if (ntbSelSlot.type === 'corr') ntbCorridors[ntbSelSlot.idx] = ref;
        else if (ntbSelSlot.type === 'end') ntbEndCaps[ntbSelSlot.idx] = ref;
        else ntbTiles[ntbSelSlot.row][ntbSelSlot.col] = ref;
        // Advance selection
        ntbAdvanceSlot();
      } else {
        toast('Select a slot first, or drag 3√ó3 / 2√ó2', 'err');
      }
    } else if (w === 4 && h === 2 && ntbBrushType === 'wall') {
      // 4√ó2 block: assign first row to corridors[0..3], second row to corridors[4..7]
      for (let i = 0; i < 4; i++) ntbCorridors[i] = { sheetPath: ntbSheet, sx: (c1+i)*TILE, sy: r1*TILE };
      for (let i = 0; i < 4; i++) {
        if (i < NTB_CORRIDOR_LABELS.length - 4)
          ntbCorridors[4+i] = { sheetPath: ntbSheet, sx: (c1+i)*TILE, sy: (r1+1)*TILE };
      }
      toast('Corridor tiles assigned', 'ok');
    } else if (w === 4 && h === 1) {
      // 4√ó1: assign to end caps
      for (let i = 0; i < 4; i++) ntbEndCaps[i] = { sheetPath: ntbSheet, sx: (c1+i)*TILE, sy: r1*TILE };
      toast('End caps assigned', 'ok');
    } else {
      toast('Drag 3√ó3 (outer), 2√ó2 (corners), or click single tile', 'err');
    }
    ntbDragStart = null; ntbDragCur = null;
    ntbBuildGrid();
    ntbRenderSheetCanvas(ntbSheet);
  });
  cvs.addEventListener('mouseleave', () => {
    if (ntbDragStart) { ntbDragStart = null; ntbDragCur = null; ntbRenderSheetCanvas(ntbSheet); }
  });
}

function ntbAdvanceSlot() {
  if (!ntbSelSlot) return;
  if (!ntbSelSlot.type) {
    // Main grid: advance left-to-right, top-to-bottom
    let c = ntbSelSlot.col + 1, r = ntbSelSlot.row;
    if (c >= 3) { c = 0; r++; }
    if (r < 3) ntbSelSlot = {row: r, col: c};
    else ntbSelSlot = {type:'ic', idx:0};
  } else if (ntbSelSlot.type === 'ic') {
    const next = ntbSelSlot.idx + 1;
    if (next < 4) ntbSelSlot = {type:'ic', idx:next};
    else if (ntbBrushType === 'wall') ntbSelSlot = {type:'corr', idx:0};
    else ntbSelSlot = null;
  } else if (ntbSelSlot.type === 'corr') {
    const next = ntbSelSlot.idx + 1;
    if (next < NTB_CORRIDOR_LABELS.length) ntbSelSlot = {type:'corr', idx:next};
    else ntbSelSlot = {type:'end', idx:0};
  } else if (ntbSelSlot.type === 'end') {
    const next = ntbSelSlot.idx + 1;
    if (next < 4) ntbSelSlot = {type:'end', idx:next};
    else ntbSelSlot = null;
  }
}

function ntbSave() {
  const name = document.getElementById('ntb-name').value.trim() || 'Unnamed Brush';
  if (!ntbTiles[1][1]) {
    toast('Center tile is required', 'err');
    return;
  }
  const brushData = {
    id: (ntbEditIdx >= 0 && nineTileBrushes[ntbEditIdx]) ? nineTileBrushes[ntbEditIdx].id : 'ntb_' + Date.now(),
    name,
    brushType: ntbBrushType,
    tiles: ntbTiles.map(row => row.map(t => t ? {...t} : null)),
    insideCorners: ntbCorners.map(t => t ? {...t} : null),
    corridors: ntbCorridors.map(t => t ? {...t} : null),
    endCaps: ntbEndCaps.map(t => t ? {...t} : null),
    cost: {
      gold: parseInt(document.getElementById('ntb-cost-gold').value) || 0,
      resources: Object.fromEntries(
        [...document.querySelectorAll('#ntb-cost-resource-rows input[data-res-id]')]
          .map(inp => [inp.dataset.resId, parseInt(inp.value) || 0])
          .filter(([rid, v]) => rid && v > 0)
      ),
    },
  };
  if (ntbEditIdx >= 0 && nineTileBrushes[ntbEditIdx]) {
    nineTileBrushes[ntbEditIdx] = brushData;
    toast('Brush updated', 'ok');
  } else {
    nineTileBrushes.push(brushData);
    ntbEditIdx = nineTileBrushes.length - 1;
    toast('Brush saved', 'ok');
  }
  document.getElementById('ntb-del-btn').disabled = false;
  ntbBuildBrushList();
  buildNtbListPanel();
  recomputeAllBrushTiles(brushData.id);
  notifyParent();
}

function ntbDelete() {
  if (ntbEditIdx < 0 || !nineTileBrushes[ntbEditIdx]) return;
  // Double-click guard: require two clicks within 2 seconds
  if (!ntbDelete._armed) {
    ntbDelete._armed = true;
    document.getElementById('ntb-del-btn').textContent = '‚ö† Confirm Delete';
    document.getElementById('ntb-del-btn').style.fontWeight = '700';
    setTimeout(() => {
      ntbDelete._armed = false;
      const btn = document.getElementById('ntb-del-btn');
      if (btn) { btn.textContent = 'üóë Delete'; btn.style.fontWeight = ''; }
    }, 2000);
    return;
  }
  ntbDelete._armed = false;
  document.getElementById('ntb-del-btn').textContent = 'üóë Delete';
  document.getElementById('ntb-del-btn').style.fontWeight = '';
  const deletedId = nineTileBrushes[ntbEditIdx].id;
  nineTileBrushes.splice(ntbEditIdx, 1);
  // Remove from brushGroupMap
  for (const key of Object.keys(brushGroupMap)) {
    if (brushGroupMap[key] && brushGroupMap[key].brushId === deletedId) delete brushGroupMap[key];
  }
  if (activeNineBrush === ntbEditIdx) activeNineBrush = null;
  else if (activeNineBrush !== null && activeNineBrush > ntbEditIdx) activeNineBrush--;
  ntbEditIdx = -1;
  ntbTiles = ntbEmptyGrid();
  ntbCorners = ntbEmptyCorners();
  ntbCorridors = ntbEmptyCorridors();
  ntbEndCaps = ntbEmptyEndCaps();
  document.getElementById('ntb-name').value = 'New Brush';
  document.getElementById('ntb-del-btn').disabled = true;
  ntbBuildBrushList();
  ntbBuildGrid();
  buildNtbListPanel();
  renderCanvas();
  notifyParent();
}

// ‚îÄ‚îÄ Nine-Tile Painting ‚îÄ‚îÄ
function nineTilePaint(q, r) {
  if (activeNineBrush === null) return;
  const brush = nineTileBrushes[activeNineBrush];
  if (!brush) return;
  const targetLayer = brush.brushType === 'wall' ? 'walls' : 'floor';
  const key = `${q},${r}`;
  brushGroupMap[key] = { brushId: brush.id, layer: targetLayer };
  // Recompute this cell and all neighbors
  const toUpdate = new Set();
  for (let dr = -1; dr <= 1; dr++) {
    for (let dc = -1; dc <= 1; dc++) {
      const nq = q + dc, nr = r + dr;
      if (nq >= 0 && nq < gridW && nr >= 0 && nr < gridH) {
        const nk = `${nq},${nr}`;
        if (brushGroupMap[nk] && brushGroupMap[nk].brushId === brush.id) {
          toUpdate.add(nk);
        }
      }
    }
  }
  toUpdate.add(key);
  for (const k of toUpdate) {
    const [uq, ur] = k.split(',').map(Number);
    recomputeNineTile(uq, ur);
  }
}

function nineTileErase(q, r) {
  const key = `${q},${r}`;
  const entry = brushGroupMap[key];
  if (!entry) return;
  const brushId = entry.brushId;
  const targetLayer = entry.layer;
  delete brushGroupMap[key];
  delete layers[targetLayer][key];
  // Recompute neighbors
  for (let dr = -1; dr <= 1; dr++) {
    for (let dc = -1; dc <= 1; dc++) {
      const nq = q + dc, nr = r + dr;
      const nk = `${nq},${nr}`;
      if (nq >= 0 && nq < gridW && nr >= 0 && nr < gridH && brushGroupMap[nk] && brushGroupMap[nk].brushId === brushId) {
        recomputeNineTile(nq, nr);
      }
    }
  }
}

function recomputeNineTile(q, r) {
  const key = `${q},${r}`;
  const entry = brushGroupMap[key];
  if (!entry) return;
  const brush = nineTileBrushes.find(b => b.id === entry.brushId);
  if (!brush) return;
  const targetLayer = entry.layer;
  const groupId = entry.brushId;

  // Check cardinal neighbors
  const has = (dq, dr) => {
    const nq = q + dq, nr = r + dr;
    if (nq < 0 || nq >= gridW || nr < 0 || nr >= gridH) return false;
    const nk = `${nq},${nr}`;
    return brushGroupMap[nk] && brushGroupMap[nk].brushId === groupId;
  };

  const hasTop = has(0, -1), hasBottom = has(0, 1), hasLeft = has(-1, 0), hasRight = has(1, 0);
  const hasTL = has(-1, -1), hasTR = has(1, -1), hasBL = has(-1, 1), hasBR = has(1, 1);

  const cardCount = (hasTop?1:0) + (hasBottom?1:0) + (hasLeft?1:0) + (hasRight?1:0);

  // Wall brush corridor/junction logic
  if (brush.brushType === 'wall' && brush.corridors) {
    // Solo tile (no neighbors)
    if (cardCount === 0 && brush.corridors[7]) {
      layers[targetLayer][key] = { sheetPath: brush.corridors[7].sheetPath, sx: brush.corridors[7].sx, sy: brush.corridors[7].sy, sw: TILE, sh: TILE };
      return;
    }
    // End caps: only one cardinal neighbor
    if (cardCount === 1 && brush.endCaps) {
      let ecIdx = -1;
      if (hasBottom && !hasTop && !hasLeft && !hasRight) ecIdx = 0; // End-N (open toward south)
      else if (hasTop && !hasBottom && !hasLeft && !hasRight) ecIdx = 1; // End-S
      else if (hasRight && !hasTop && !hasBottom && !hasLeft) ecIdx = 2; // End-W
      else if (hasLeft && !hasTop && !hasBottom && !hasRight) ecIdx = 3; // End-E
      if (ecIdx >= 0 && brush.endCaps[ecIdx]) {
        layers[targetLayer][key] = { sheetPath: brush.endCaps[ecIdx].sheetPath, sx: brush.endCaps[ecIdx].sx, sy: brush.endCaps[ecIdx].sy, sw: TILE, sh: TILE };
        return;
      }
    }
    // Vertical corridor: top + bottom, no left/right
    if (hasTop && hasBottom && !hasLeft && !hasRight && brush.corridors[0]) {
      layers[targetLayer][key] = { sheetPath: brush.corridors[0].sheetPath, sx: brush.corridors[0].sx, sy: brush.corridors[0].sy, sw: TILE, sh: TILE };
      return;
    }
    // Horizontal corridor: left + right, no top/bottom
    if (hasLeft && hasRight && !hasTop && !hasBottom && brush.corridors[1]) {
      layers[targetLayer][key] = { sheetPath: brush.corridors[1].sheetPath, sx: brush.corridors[1].sx, sy: brush.corridors[1].sy, sw: TILE, sh: TILE };
      return;
    }
    // T-junctions (3 cardinals)
    if (cardCount === 3) {
      let tIdx = -1;
      if (hasLeft && hasRight && hasBottom && !hasTop) tIdx = 2;   // T-Down (open down)
      else if (hasLeft && hasRight && hasTop && !hasBottom) tIdx = 3; // T-Up
      else if (hasTop && hasBottom && hasRight && !hasLeft) tIdx = 4; // T-Right
      else if (hasTop && hasBottom && hasLeft && !hasRight) tIdx = 5; // T-Left
      if (tIdx >= 0 && brush.corridors[tIdx]) {
        layers[targetLayer][key] = { sheetPath: brush.corridors[tIdx].sheetPath, sx: brush.corridors[tIdx].sx, sy: brush.corridors[tIdx].sy, sw: TILE, sh: TILE };
        return;
      }
    }
    // Cross (4 cardinals, used when no diagonals are present or no standard tile fits)
    if (cardCount === 4 && brush.corridors[6]) {
      // Only use cross if at least one diagonal is missing
      const diagCount = (hasTL?1:0) + (hasTR?1:0) + (hasBL?1:0) + (hasBR?1:0);
      if (diagCount < 4) {
        // Check for inside corners first
        // (fall through to standard inside corner logic below)
      } else {
        // All 8 neighbors = center tile (below)
      }
    }
  }

  // Check for inside corners: all 4 cardinals present but a diagonal is missing
  if (hasTop && hasBottom && hasLeft && hasRight && brush.insideCorners) {
    // IC indices: 0=TL, 1=TR, 2=BL, 3=BR (the diagonal that's MISSING)
    const icIdx = !hasTL ? 0 : !hasTR ? 1 : !hasBL ? 2 : !hasBR ? 3 : -1;
    if (icIdx >= 0 && brush.insideCorners[icIdx]) {
      const ic = brush.insideCorners[icIdx];
      layers[targetLayer][key] = { sheetPath: ic.sheetPath, sx: ic.sx, sy: ic.sy, sw: TILE, sh: TILE };
      return;
    }
  }

  // Standard 3√ó3 mapping
  // Row: 0=top edge, 1=middle/fill, 2=bottom edge
  let row = 1;
  if (!hasTop && hasBottom) row = 0;
  else if (hasTop && !hasBottom) row = 2;
  // else: both present OR both absent ‚Üí center (row=1)
  // Col: 0=left edge, 1=middle/fill, 2=right edge
  let col = 1;
  if (!hasLeft && hasRight) col = 0;
  else if (hasLeft && !hasRight) col = 2;
  // else: both present OR both absent ‚Üí center (col=1)

  const tileRef = brush.tiles[row] && brush.tiles[row][col];
  if (tileRef) {
    layers[targetLayer][key] = { sheetPath: tileRef.sheetPath, sx: tileRef.sx, sy: tileRef.sy, sw: TILE, sh: TILE };
  }
}

function recomputeAllBrushTiles(brushId) {
  for (const [key, entry] of Object.entries(brushGroupMap)) {
    if (entry.brushId === brushId) {
      const [q, r] = key.split(',').map(Number);
      recomputeNineTile(q, r);
    }
  }
  renderCanvas();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  INTERIOR GENERATOR
//  Procedurally generates a room layout using 9-tile brushes
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

let _igenSeed = 0;
let _igenResult = null;

function _igenRng() {
  _igenSeed ^= _igenSeed << 13;
  _igenSeed ^= _igenSeed >> 17;
  _igenSeed ^= _igenSeed << 5;
  return ((_igenSeed >>> 0) % 10000) / 10000;
}
function _igenRandInt(a, b) { return a + Math.floor(_igenRng() * (b - a + 1)); }

/**
 * Generate a floor plan with rooms and optional inner walls.
 * Returns { width, height, floorCells: Set, wallCells: Set, doorCells: Set }
 */
function _igenFloorPlan(rooms, minW, maxW, minH, maxH, addInnerWalls) {
  // Generate room rectangles ‚Äî dimensions include the perimeter walls
  const rects = [];
  for (let i = 0; i < rooms; i++) {
    const rw = _igenRandInt(Math.max(3, minW), Math.max(3, maxW));
    const rh = _igenRandInt(Math.max(3, minH), Math.max(3, maxH));
    rects.push({ x: 0, y: 0, w: rw, h: rh });
  }

  // Layout rooms starting at (0,0); adjacent rooms share a wall column/row
  if (rects.length > 0) {
    rects[0].x = 0; rects[0].y = 0;
    for (let i = 1; i < rects.length; i++) {
      const prev = rects[i - 1];
      if (_igenRng() > 0.5) {
        // Attach right ‚Äî overlap 1 column (shared wall)
        rects[i].x = prev.x + prev.w - 1;
        rects[i].y = prev.y + _igenRandInt(0, Math.max(0, prev.h - rects[i].h));
      } else {
        // Attach bottom ‚Äî overlap 1 row (shared wall)
        rects[i].x = prev.x + _igenRandInt(0, Math.max(0, prev.w - rects[i].w));
        rects[i].y = prev.y + prev.h - 1;
      }
    }
  }

  // Normalize so min corner is (0,0)
  let minX = Infinity, minY = Infinity;
  for (const r of rects) { if (r.x < minX) minX = r.x; if (r.y < minY) minY = r.y; }
  for (const r of rects) { r.x -= minX; r.y -= minY; }

  // Determine total extent
  let maxX = 0, maxY = 0;
  for (const r of rects) {
    if (r.x + r.w > maxX) maxX = r.x + r.w;
    if (r.y + r.h > maxY) maxY = r.y + r.h;
  }
  const totalW = maxX;
  const totalH = maxY;

  // All cells inside any room rectangle are floor cells
  const floorCells = new Set();
  for (const r of rects) {
    for (let y = r.y; y < r.y + r.h; y++) {
      for (let x = r.x; x < r.x + r.w; x++) {
        floorCells.add(`${x},${y}`);
      }
    }
  }

  // Wall cells = outer rim of floor (floor cells with at least one non-floor neighbor)
  const wallCells = new Set();
  for (const key of floorCells) {
    const [fx, fy] = key.split(',').map(Number);
    let isEdge = false;
    for (let dy = -1; dy <= 1 && !isEdge; dy++) {
      for (let dx = -1; dx <= 1 && !isEdge; dx++) {
        if (dx === 0 && dy === 0) continue;
        if (!floorCells.has(`${fx+dx},${fy+dy}`)) isEdge = true;
      }
    }
    if (isEdge) wallCells.add(key);
  }

  const doorCells = new Set();

  // Inner walls between adjacent rooms (cells on the shared boundary)
  if (addInnerWalls && rects.length > 1) {
    for (let i = 1; i < rects.length; i++) {
      const r = rects[i], prev = rects[i - 1];
      const sharedCells = [];

      // Vertical shared column
      if (r.x === prev.x + prev.w - 1) {
        const overlapStart = Math.max(r.y, prev.y);
        const overlapEnd   = Math.min(r.y + r.h, prev.y + prev.h);
        for (let y = overlapStart; y < overlapEnd; y++) sharedCells.push(`${r.x},${y}`);
      } else if (prev.x === r.x + r.w - 1) {
        const overlapStart = Math.max(r.y, prev.y);
        const overlapEnd   = Math.min(r.y + r.h, prev.y + prev.h);
        for (let y = overlapStart; y < overlapEnd; y++) sharedCells.push(`${prev.x},${y}`);
      }
      // Horizontal shared row
      else if (r.y === prev.y + prev.h - 1) {
        const overlapStart = Math.max(r.x, prev.x);
        const overlapEnd   = Math.min(r.x + r.w, prev.x + prev.w);
        for (let x = overlapStart; x < overlapEnd; x++) sharedCells.push(`${x},${r.y}`);
      } else if (prev.y === r.y + r.h - 1) {
        const overlapStart = Math.max(r.x, prev.x);
        const overlapEnd   = Math.min(r.x + r.w, prev.x + prev.w);
        for (let x = overlapStart; x < overlapEnd; x++) sharedCells.push(`${x},${prev.y}`);
      }

      // Skip corner cells (already outer perimeter) ‚Äî only process interior shared cells
      if (sharedCells.length >= 3) {
        const inner = sharedCells.slice(1, -1); // exclude first/last (outer corners)
        if (inner.length > 0) {
          const doorIdx = _igenRandInt(0, inner.length - 1);
          for (let j = 0; j < inner.length; j++) {
            if (j === doorIdx) {
              doorCells.add(inner[j]);
              wallCells.delete(inner[j]); // ensure door is not a wall
            } else {
              wallCells.add(inner[j]); // add inner wall
            }
          }
        }
      }
    }
  }

  // Add entrance door on the bottom wall
  let maxFloorR = 0;
  for (const key of floorCells) {
    const r = +key.split(',')[1];
    if (r > maxFloorR) maxFloorR = r;
  }
  const bottomWalls = [];
  for (const key of wallCells) {
    const [x, y] = key.split(',').map(Number);
    // Bottom-edge wall cells (on the bottom row and not at the extreme corners)
    if (y === maxFloorR && x > 0 && x < totalW - 1) bottomWalls.push(key);
  }
  if (bottomWalls.length) {
    bottomWalls.sort((a, b) => +a.split(',')[0] - +b.split(',')[0]);
    const mid = Math.floor(bottomWalls.length / 2);
    const doorKey = bottomWalls[mid];
    wallCells.delete(doorKey);
    doorCells.add(doorKey);
  }

  return { width: totalW, height: totalH, floorCells, wallCells, doorCells, rects };
}

/**
 * Build the generated interior with brush tiles applied.
 * Floor covers ALL floor cells (floor layer).
 * Walls cover the outer rim of the floor (walls layer, overlaid on floor).
 * Returns { width, height, layers, meta, brushGroupMap }
 */
function _igenBuild(plan, floorBrushIdx, wallBrushIdx) {
  const w = plan.width;
  const h = plan.height;
  const newLayers = { floor: {}, furniture: {}, walls: {}, overlay: {} };
  const newMeta = {};
  const newBGM = {};

  const floorBrush = floorBrushIdx >= 0 ? nineTileBrushes[floorBrushIdx] : null;
  const wallBrush  = wallBrushIdx >= 0  ? nineTileBrushes[wallBrushIdx]  : null;

  // Helper: resolve a 9-tile brush sprite for a cell, auto-tiling against a member set
  function resolveTile(brush, q, r, memberSet) {
    const has = (dq, dr) => memberSet.has(`${q+dq},${r+dr}`);
    const hasTop = has(0,-1), hasBot = has(0,1), hasLft = has(-1,0), hasRgt = has(1,0);
    const hasTL = has(-1,-1), hasTR = has(1,-1), hasBL = has(-1,1), hasBR = has(1,1);
    const card = (hasTop?1:0)+(hasBot?1:0)+(hasLft?1:0)+(hasRgt?1:0);

    // Wall-type corridor / junction tiles
    if (brush.brushType === 'wall' && brush.corridors) {
      if (card === 0 && brush.corridors[7])  return brush.corridors[7];        // solo
      if (card === 1 && brush.endCaps) {                                        // end cap
        let ec = hasBot?0 : hasTop?1 : hasRgt?2 : hasLft?3 : -1;
        if (ec >= 0 && brush.endCaps[ec]) return brush.endCaps[ec];
      }
      if (hasTop && hasBot && !hasLft && !hasRgt && brush.corridors[0]) return brush.corridors[0]; // vert
      if (hasLft && hasRgt && !hasTop && !hasBot && brush.corridors[1]) return brush.corridors[1]; // horiz
      if (card === 3) {                                                         // T-junction
        let ti = (hasLft&&hasRgt&&hasBot&&!hasTop)?2 : (hasLft&&hasRgt&&hasTop&&!hasBot)?3
               : (hasTop&&hasBot&&hasRgt&&!hasLft)?4 : (hasTop&&hasBot&&hasLft&&!hasRgt)?5 : -1;
        if (ti >= 0 && brush.corridors[ti]) return brush.corridors[ti];
      }
      if (card === 4 && brush.corridors[6]) {                                   // cross / IC
        const diag = (hasTL?1:0)+(hasTR?1:0)+(hasBL?1:0)+(hasBR?1:0);
        if (diag === 4) { /* fall through to center */ }
      }
    }

    // Inside corners
    if (hasTop && hasBot && hasLft && hasRgt && brush.insideCorners) {
      const ic = !hasTL?0 : !hasTR?1 : !hasBL?2 : !hasBR?3 : -1;
      if (ic >= 0 && brush.insideCorners[ic]) return brush.insideCorners[ic];
    }

    // Standard 3√ó3 mapping
    let row = 1;
    if (!hasTop && hasBot) row = 0;
    else if (hasTop && !hasBot) row = 2;
    // else: both present OR both absent ‚Üí center (row=1)
    let col = 1;
    if (!hasLft && hasRgt) col = 0;
    else if (hasLft && !hasRgt) col = 2;
    // else: both present OR both absent ‚Üí center (col=1)
    return (brush.tiles && brush.tiles[row] && brush.tiles[row][col]) || null;
  }

  // ‚îÄ‚îÄ Pass 1: Floor tiles on the floor layer for ALL floor cells ‚îÄ‚îÄ
  if (floorBrush) {
    for (const key of plan.floorCells) {
      const [q, r] = key.split(',').map(Number);
      const tile = resolveTile(floorBrush, q, r, plan.floorCells);
      if (tile) newLayers.floor[key] = { sheetPath: tile.sheetPath, sx: tile.sx, sy: tile.sy, sw: TILE, sh: TILE };
    }
  }

  // ‚îÄ‚îÄ Pass 2: Wall tiles on the walls layer for perimeter cells only ‚îÄ‚îÄ
  if (wallBrush) {
    for (const key of plan.wallCells) {
      const [q, r] = key.split(',').map(Number);
      const tile = resolveTile(wallBrush, q, r, plan.wallCells);
      if (tile) newLayers.walls[key] = { sheetPath: tile.sheetPath, sx: tile.sx, sy: tile.sy, sw: TILE, sh: TILE };
      newMeta[key] = { impassable: true };
    }
  }

  // ‚îÄ‚îÄ Brush group map: wall brush for perimeter, floor brush for interior ‚îÄ‚îÄ
  for (const key of plan.floorCells) {
    if (plan.wallCells.has(key)) {
      if (wallBrush) newBGM[key] = { brushId: wallBrush.id, layer: 'walls' };
    } else {
      if (floorBrush) newBGM[key] = { brushId: floorBrush.id, layer: 'floor' };
    }
  }

  // Door cells
  for (const key of plan.doorCells) {
    newMeta[key] = { door: true };
  }

  return { width: w, height: h, layers: newLayers, meta: newMeta, brushGroupMap: newBGM };
}

/** Render a small preview of the generated interior */
function _igenRenderPreview(canvas, result) {
  if (!result) return;
  const previewTile = 8;
  canvas.width  = result.width * previewTile;
  canvas.height = result.height * previewTile;
  const pctx = canvas.getContext('2d');
  pctx.fillStyle = '#0d1117';
  pctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw floors
  for (const key of Object.keys(result.layers.floor)) {
    const [q, r] = key.split(',').map(Number);
    const cell = result.layers.floor[key];
    const img = cell.sheetPath ? imageCache[cell.sheetPath] : null;
    if (img) {
      pctx.drawImage(img, cell.sx, cell.sy, cell.sw || TILE, cell.sh || TILE, q * previewTile, r * previewTile, previewTile, previewTile);
    } else {
      pctx.fillStyle = '#6a5a4a';
      pctx.fillRect(q * previewTile, r * previewTile, previewTile, previewTile);
    }
  }
  // Draw walls
  for (const key of Object.keys(result.layers.walls)) {
    const [q, r] = key.split(',').map(Number);
    const cell = result.layers.walls[key];
    const img = cell.sheetPath ? imageCache[cell.sheetPath] : null;
    if (img) {
      pctx.drawImage(img, cell.sx, cell.sy, cell.sw || TILE, cell.sh || TILE, q * previewTile, r * previewTile, previewTile, previewTile);
    } else {
      pctx.fillStyle = '#4a3a2a';
      pctx.fillRect(q * previewTile, r * previewTile, previewTile, previewTile);
    }
  }
  // Draw doors
  for (const [key, m] of Object.entries(result.meta)) {
    if (m.door) {
      const [q, r] = key.split(',').map(Number);
      pctx.fillStyle = '#8B6914';
      pctx.fillRect(q * previewTile + 1, r * previewTile + 1, previewTile - 2, previewTile - 2);
    }
  }
}

function showInteriorGenerator() {
  // Need at least one brush to generate
  if (nineTileBrushes.length === 0) {
    toast('Create 9-tile brushes first (üé® Brushes button)', 'err');
    return;
  }

  const existing = document.querySelector('.igen-overlay');
  if (existing) existing.remove();

  // Build brush option lists
  const floorBrushes = nineTileBrushes.map((b, i) => ({ b, i })).filter(({ b }) => b.brushType === 'floor');
  const wallBrushes  = nineTileBrushes.map((b, i) => ({ b, i })).filter(({ b }) => b.brushType === 'wall');

  const floorOpts = floorBrushes.length
    ? floorBrushes.map(({ b, i }) => `<option value="${i}">${b.name}</option>`).join('')
    : '<option value="-1">(no floor brushes)</option>';
  const wallOpts = wallBrushes.length
    ? wallBrushes.map(({ b, i }) => `<option value="${i}">${b.name}</option>`).join('')
    : '<option value="-1">(no wall brushes)</option>';

  const warn = (!floorBrushes.length || !wallBrushes.length)
    ? `<div class="igen-warn">‚ö† Create both floor and wall type brushes in üé® Brushes for best results</div>`
    : '';

  const ov = document.createElement('div');
  ov.className = 'igen-overlay';
  ov.innerHTML = `
<div class="igen-modal">
  <h3>üèóÔ∏è Interior Generator</h3>
  <div class="igen-section">
    <h4>Layout</h4>
    <div class="igen-row">
      <label>Rooms</label>
      <input type="range" id="igen-rooms" min="1" max="5" value="1">
      <span id="igen-rooms-val" style="min-width:16px;color:var(--text)">1</span>
    </div>
    <div class="igen-row">
      <label>Room Width</label>
      <input type="number" id="igen-minw" value="4" min="2" max="14" style="width:50px"> ‚Äì
      <input type="number" id="igen-maxw" value="8" min="2" max="18" style="width:50px">
    </div>
    <div class="igen-row">
      <label>Room Height</label>
      <input type="number" id="igen-minh" value="3" min="2" max="10" style="width:50px"> ‚Äì
      <input type="number" id="igen-maxh" value="6" min="2" max="14" style="width:50px">
    </div>
    <div class="igen-row">
      <label></label>
      <label style="min-width:0;cursor:pointer"><input type="checkbox" id="igen-innerwalls"> Inner walls between rooms</label>
    </div>
  </div>
  <div class="igen-section">
    <h4>Brushes</h4>
    <div class="igen-row"><label>Floor</label><select id="igen-floor">${floorOpts}</select></div>
    <div class="igen-row"><label>Walls</label><select id="igen-wall">${wallOpts}</select></div>
    ${warn}
  </div>
  <div class="igen-section">
    <h4>Preview</h4>
    <div class="igen-preview"><canvas id="igen-preview-cvs"></canvas></div>
    <div style="text-align:center;margin-top:6px">
      <button onclick="_igenRegenerate()" style="font-size:11px;padding:4px 12px;border-radius:4px;cursor:pointer;background:var(--bg);color:var(--text);border:1px solid var(--border2)">üé≤ Randomize</button>
    </div>
  </div>
  <div class="igen-btns">
    <button onclick="_igenClose()">Cancel</button>
    <button class="primary" onclick="_igenApply()">Apply to Canvas</button>
  </div>
</div>`;
  document.body.appendChild(ov);

  // Close on overlay click
  ov.addEventListener('click', e => { if (e.target === ov) _igenClose(); });

  // Live updates
  const roomSlider = document.getElementById('igen-rooms');
  const roomVal = document.getElementById('igen-rooms-val');
  roomSlider.addEventListener('input', () => { roomVal.textContent = roomSlider.value; _igenRegenerate(); });

  for (const id of ['igen-minw','igen-maxw','igen-minh','igen-maxh','igen-floor','igen-wall','igen-innerwalls']) {
    const el = document.getElementById(id);
    if (el) el.addEventListener('change', () => _igenRegenerate());
  }

  // Preload brush sheet images before first generate
  const sheetsToLoad = new Set();
  for (const brush of nineTileBrushes) {
    if (brush.tiles) for (const row of brush.tiles) if (row) for (const t of row) if (t && t.sheetPath) sheetsToLoad.add(t.sheetPath);
    if (brush.insideCorners) for (const t of brush.insideCorners) if (t && t.sheetPath) sheetsToLoad.add(t.sheetPath);
    if (brush.corridors) for (const t of brush.corridors) if (t && t.sheetPath) sheetsToLoad.add(t.sheetPath);
    if (brush.endCaps) for (const t of brush.endCaps) if (t && t.sheetPath) sheetsToLoad.add(t.sheetPath);
  }
  const loadPromises = [...sheetsToLoad].filter(p => !imageCache[p]).map(p => loadImage(p));
  if (loadPromises.length) {
    Promise.all(loadPromises).then(() => _igenRegenerate());
  } else {
    _igenRegenerate();
  }
}

function _igenRegenerate() {
  _igenSeed = Date.now() ^ (Math.random() * 0xffffffff);

  const rooms = +document.getElementById('igen-rooms').value;
  const minW  = +document.getElementById('igen-minw').value;
  const maxW  = +document.getElementById('igen-maxw').value;
  const minH  = +document.getElementById('igen-minh').value;
  const maxH  = +document.getElementById('igen-maxh').value;
  const floorBrushIdx = +document.getElementById('igen-floor').value;
  const wallBrushIdx  = +document.getElementById('igen-wall').value;
  const innerWalls    = document.getElementById('igen-innerwalls').checked;

  const plan = _igenFloorPlan(rooms, Math.max(2, minW), Math.max(minW, maxW), Math.max(2, minH), Math.max(minH, maxH), innerWalls);
  _igenResult = _igenBuild(plan, floorBrushIdx, wallBrushIdx);

  const cvs = document.getElementById('igen-preview-cvs');
  if (cvs) _igenRenderPreview(cvs, _igenResult);
}

function _igenClose() {
  const ov = document.querySelector('.igen-overlay');
  if (ov) ov.remove();
  _igenResult = null;
}

function _igenApply() {
  if (!_igenResult) return;
  const r = _igenResult;

  // Clear current state
  layers = { floor: {}, furniture: {}, walls: {}, overlay: {} };
  meta = {};
  placedObjects = {};
  brushGroupMap = {};
  undoStack = []; redoStack = [];
  editIdx = -1;

  // Set grid size
  gridW = r.width;
  gridH = r.height;
  document.getElementById('grid-w').value = gridW;
  document.getElementById('grid-h').value = gridH;

  // Copy layers
  for (const [ln, lyr] of Object.entries(r.layers)) {
    for (const [key, val] of Object.entries(lyr)) {
      layers[ln][key] = { ...val };
    }
  }

  // Copy meta
  for (const [key, val] of Object.entries(r.meta)) {
    meta[key] = { ...val };
  }

  // Copy brush group map
  brushGroupMap = JSON.parse(JSON.stringify(r.brushGroupMap));

  // Close modal
  _igenClose();

  // Update UI
  buildNtbListPanel();
  fitCanvas();
  toast('Interior generated! Edit it as you like.', 'ok');
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  SAVE / LOAD / EXPORT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function slugify(s) { return s.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_|_$/g, ''); }

function newInterior() {
  editIdx = -1;
  layers = { floor: {}, furniture: {}, walls: {}, overlay: {} };
  meta = {};
  placedObjects = {};
  brushGroupMap = {};
  gridW = parseInt(document.getElementById('grid-w').value) || 10;
  gridH = parseInt(document.getElementById('grid-h').value) || 8;
  document.getElementById('int-name').value = '';
  document.getElementById('int-type').value = 'house';
  document.getElementById('int-tags').value = '';
  document.getElementById('int-group').value = '';
  _linkedBuildingIds = [];
  _refreshLinkedBuildingChecklist();
  refreshList();
  fitCanvas();
}

function _refreshLinkedBuildingChecklist() {
  const container = document.getElementById('int-linked-buildings');
  if (!_buildings.length) {
    container.innerHTML = '<span style="color:var(--text-dim);font-style:italic">No buildings available</span>';
    return;
  }
  container.innerHTML = '';
  for (const bld of _buildings) {
    const row = document.createElement('label');
    row.style.cssText = 'display:flex;align-items:center;gap:4px;padding:2px 0;cursor:pointer;color:var(--text)';
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.value = bld.id;
    cb.checked = _linkedBuildingIds.includes(bld.id);
    cb.addEventListener('change', () => {
      if (cb.checked) {
        if (!_linkedBuildingIds.includes(bld.id)) _linkedBuildingIds.push(bld.id);
      } else {
        _linkedBuildingIds = _linkedBuildingIds.filter(id => id !== bld.id);
      }
      // Auto-set buildingType from first linked building
      if (_linkedBuildingIds.length) {
        const first = _buildings.find(b => b.id === _linkedBuildingIds[0]);
        if (first) document.getElementById('int-type').value = first.buildingType || 'other';
      }
    });
    row.appendChild(cb);
    row.appendChild(document.createTextNode(`${bld.name} (${bld.buildingType})`));
    container.appendChild(row);
  }
}

function saveInterior() {
  const name = document.getElementById('int-name').value.trim();
  if (!name) { toast('Enter an interior name', 'err'); return; }
  // Gather linked building ids from checklist
  _linkedBuildingIds = [...document.getElementById('int-linked-buildings').querySelectorAll('input:checked')].map(cb => cb.value);
  const interior = {
    id: slugify(name),
    name,
    linkedBuildingIds: _linkedBuildingIds.length ? [..._linkedBuildingIds] : undefined,
    buildingType: document.getElementById('int-type').value,
    tags: document.getElementById('int-tags').value.trim().split(',').map(s => s.trim()).filter(Boolean),
    variantGroup: document.getElementById('int-group').value.trim() || null,
    tileW: TILE, tileH: TILE,
    width: gridW, height: gridH,
    layers: {
      floor: { ...layers.floor },
      furniture: { ...layers.furniture },
      walls: { ...layers.walls },
      overlay: { ...layers.overlay },
    },
    meta: { ...meta },
    placedObjects: JSON.parse(JSON.stringify(placedObjects)),
    brushGroupMap: JSON.parse(JSON.stringify(brushGroupMap)),
    nineTileBrushes: JSON.parse(JSON.stringify(nineTileBrushes)),
  };
  if (editIdx >= 0) {
    interiors[editIdx] = interior;
  } else {
    interiors.push(interior);
    editIdx = interiors.length - 1;
  }
  refreshList();
  notifyParent();
}

function loadInterior(index) {
  const b = interiors[index];
  if (!b) return;
  editIdx = index;
  gridW = b.width || 10; gridH = b.height || 8;
  document.getElementById('grid-w').value = gridW;
  document.getElementById('grid-h').value = gridH;
  document.getElementById('int-name').value = b.name || '';
  document.getElementById('int-type').value = b.buildingType || 'house';
  document.getElementById('int-tags').value = (b.tags || []).join(', ');
  document.getElementById('int-group').value = b.variantGroup || '';
  // Support both old linkedBuildingId (string) and new linkedBuildingIds (array)
  if (Array.isArray(b.linkedBuildingIds)) {
    _linkedBuildingIds = [...b.linkedBuildingIds];
  } else if (b.linkedBuildingId) {
    _linkedBuildingIds = [b.linkedBuildingId];
  } else {
    _linkedBuildingIds = [];
  }
  _refreshLinkedBuildingChecklist();
  layers = {
    floor: { ...(b.layers.floor || {}) },
    furniture: { ...(b.layers.furniture || {}) },
    walls: { ...(b.layers.walls || {}) },
    overlay: { ...(b.layers.overlay || {}) },
  };
  meta = { ...(b.meta || {}) };
  placedObjects = JSON.parse(JSON.stringify(b.placedObjects || {}));
  brushGroupMap = JSON.parse(JSON.stringify(b.brushGroupMap || {}));
  if (b.nineTileBrushes) nineTileBrushes = JSON.parse(JSON.stringify(b.nineTileBrushes));
  buildNtbListPanel();
  // Ensure deep copy of furniture objects in meta
  for (const key of Object.keys(meta)) {
    if (meta[key].furniture) meta[key] = { ...meta[key], furniture: { ...meta[key].furniture } };
  }
  // Preload images
  const paths = new Set();
  for (const lyr of Object.values(layers)) {
    for (const c of Object.values(lyr)) if (c.sheetPath) paths.add(c.sheetPath);
  }
  for (const obj of Object.values(placedObjects)) {
    for (const t of (obj.tiles || [])) if (t.sheetPath) paths.add(t.sheetPath);
  }
  Promise.all([...paths].map(loadImage)).then(() => fitCanvas());
}

function deleteInterior(index) {
  interiors.splice(index, 1);
  if (editIdx === index) { editIdx = -1; newInterior(); }
  else if (editIdx > index) editIdx--;
  refreshList();
  notifyParent();
}

function duplicateInterior(index) {
  const copy = JSON.parse(JSON.stringify(interiors[index]));
  copy.id = copy.id + '_copy';
  copy.name = copy.name + ' (copy)';
  interiors.push(copy);
  refreshList();
  notifyParent();
}

function refreshList() {
  const container = document.getElementById('interior-list');
  document.getElementById('int-count').textContent = interiors.length;
  container.innerHTML = '';
  for (let i = 0; i < interiors.length; i++) {
    const it = interiors[i];
    const card = document.createElement('div');
    card.className = 'item-card' + (i === editIdx ? ' selected' : '');
    const ids = Array.isArray(it.linkedBuildingIds) ? it.linkedBuildingIds : (it.linkedBuildingId ? [it.linkedBuildingId] : []);
    const linkedNames = ids.map(id => { const b = _buildings.find(x => x.id === id); return b ? b.name : id; });
    const linkedLabel = linkedNames.length ? `<span style="font-size:10px;color:var(--gold);margin-left:4px" title="Linked to: ${linkedNames.join(', ')}">üîó${linkedNames.length > 1 ? linkedNames.length : ''}</span>` : '';
    card.innerHTML = `
      <span class="ic-name" title="${it.id}">üè† ${it.name}${linkedLabel}</span>
      <span class="ic-type">${it.buildingType}</span>
      <span class="ic-dup" title="Duplicate" style="cursor:pointer;font-size:11px;color:var(--blue);padding:2px 4px;opacity:.6" onmouseover="this.style.opacity=1" onmouseout="this.style.opacity=.6">üìã</span>
      <span class="ic-del" title="Delete">‚úï</span>
    `;
    card.querySelector('.ic-name').addEventListener('click', () => loadInterior(i));
    card.querySelector('.ic-del').addEventListener('click', e => { e.stopPropagation(); deleteInterior(i); });
    card.querySelector('.ic-dup').addEventListener('click', e => { e.stopPropagation(); duplicateInterior(i); });
    container.appendChild(card);
  }
}

// ‚îÄ‚îÄ‚îÄ Export ‚îÄ‚îÄ‚îÄ

function _exportInterior(interior) {
  // Find origin (top-left of painted tiles and placed object anchors)
  let minQ = Infinity, minR = Infinity;
  for (const lyr of Object.values(interior.layers)) {
    for (const k of Object.keys(lyr)) {
      const [q, r] = k.split(',').map(Number);
      if (q < minQ) minQ = q;
      if (r < minR) minR = r;
    }
  }
  // Include placed object tile footprints in origin calc
  for (const [key, obj] of Object.entries(interior.placedObjects || {})) {
    const [aq, ar] = key.split(',').map(Number);
    for (const t of (obj.tiles || [])) {
      const tq = aq + t.localCol, tr = ar + t.localRow;
      if (tq < minQ) minQ = tq;
      if (tr < minR) minR = tr;
    }
  }
  if (minQ === Infinity) { minQ = 0; minR = 0; }

  const out = { ...interior };
  out.layers = {};
  let bMinQ = Infinity, bMinR = Infinity, bMaxQ = -Infinity, bMaxR = -Infinity;
  for (const [ln, lyr] of Object.entries(interior.layers)) {
    out.layers[ln] = Object.entries(lyr).map(([key, c]) => {
      const [q, r] = key.split(',').map(Number);
      const rq = q - minQ, rr = r - minR;
      if (rq < bMinQ) bMinQ = rq; if (rq > bMaxQ) bMaxQ = rq;
      if (rr < bMinR) bMinR = rr; if (rr > bMaxR) bMaxR = rr;
      return { q: rq, r: rr, sheetPath: c.sheetPath, sx: c.sx, sy: c.sy, sw: c.sw || TILE, sh: c.sh || TILE };
    });
  }
  out.meta = Object.entries(interior.meta || {}).map(([key, m]) => {
    const [q, r] = key.split(',').map(Number);
    return { q: q - minQ, r: r - minR, ...m };
  }).filter(m => m.impassable || m.door || m.furniture);
  // Export placed objects with offset-adjusted anchor positions
  out.placedObjects = Object.entries(interior.placedObjects || {}).map(([key, obj]) => {
    const [aq, ar] = key.split(',').map(Number);
    return { anchorQ: aq - minQ, anchorR: ar - minR, ...obj };
  });
  // Export brush group map with offset
  if (interior.brushGroupMap && Object.keys(interior.brushGroupMap).length) {
    out.brushGroupMap = {};
    for (const [key, entry] of Object.entries(interior.brushGroupMap)) {
      const [q, r] = key.split(',').map(Number);
      out.brushGroupMap[`${q - minQ},${r - minR}`] = entry;
    }
  }
  // Include nine-tile brush definitions
  if (interior.nineTileBrushes && interior.nineTileBrushes.length) {
    out.nineTileBrushes = interior.nineTileBrushes;
  }
  if (bMinQ !== Infinity) {
    out.bounds = { minCol: bMinQ, minRow: bMinR, maxCol: bMaxQ, maxRow: bMaxR };
    out.width = bMaxQ - bMinQ + 1;
    out.height = bMaxR - bMinR + 1;
  }
  return out;
}

function getExportData() {
  if (!interiors.length) return {};
  return {
    interiors: interiors.map(i => _exportInterior(i)),
    nineTileBrushes: nineTileBrushes.length ? JSON.parse(JSON.stringify(nineTileBrushes)) : undefined,
  };
}

function exportAll() {
  const data = getExportData();
  if (!data.interiors || !data.interiors.length) { toast('No interiors to export', 'err'); return; }
  const blob = new Blob([JSON.stringify(data.interiors, null, 2)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'interiors.json';
  a.click();
  URL.revokeObjectURL(a.href);
}

// ‚îÄ‚îÄ‚îÄ Parent communication ‚îÄ‚îÄ‚îÄ

function notifyParent() {
  try {
    const d = getExportData();
    window.parent.postMessage({ type: 'interiorDataChanged', ...d }, '*');
  } catch (e) { /* standalone */ }
}

window.addEventListener('message', ev => {
  if (!ev.data) return;

  // ‚îÄ‚îÄ Handle openBuildingInterior from parent ‚îÄ‚îÄ
  if (ev.data.type === 'openBuildingInterior') {
    const { buildingId, buildingName, buildingType, buildingWidth, buildingHeight, buildings, autoGenerate } = ev.data;
    // Update buildings list
    if (Array.isArray(buildings)) {
      _buildings = buildings;
      _refreshLinkedBuildingChecklist();
    }
    // Check if an interior already linked to this building exists
    const existingIdx = interiors.findIndex(i => {
      const ids = Array.isArray(i.linkedBuildingIds) ? i.linkedBuildingIds : (i.linkedBuildingId ? [i.linkedBuildingId] : []);
      return ids.includes(buildingId);
    });
    if (existingIdx >= 0) {
      loadInterior(existingIdx);
      return;
    }

    // ‚îÄ‚îÄ Auto-generate interior using 9-tile brushes if available ‚îÄ‚îÄ
    const floorBrushes = nineTileBrushes.filter(b => b.brushType === 'floor');
    const wallBrushes  = nineTileBrushes.filter(b => b.brushType === 'wall');

    if ((autoGenerate || floorBrushes.length || wallBrushes.length) && (floorBrushes.length > 0 || wallBrushes.length > 0)) {
      // Determine interior size from building dimensions
      const intW = Math.max(4, Math.min(buildingWidth || 8, 20));
      const intH = Math.max(4, Math.min(buildingHeight || 6, 20));

      // Pick random brushes based on building id seed
      let seedHash = 0;
      const seedStr = buildingId || 'default';
      for (let i = 0; i < seedStr.length; i++) seedHash = ((seedHash << 5) - seedHash + seedStr.charCodeAt(i)) | 0;
      const floorBrushIdx = floorBrushes.length > 0
        ? nineTileBrushes.indexOf(floorBrushes[Math.abs(seedHash) % floorBrushes.length])
        : -1;
      const wallBrushIdx = wallBrushes.length > 0
        ? nineTileBrushes.indexOf(wallBrushes[Math.abs(seedHash + 7) % wallBrushes.length])
        : -1;

      // Build a simple rectangular floor plan matching the building exactly
      const floorCells = new Set();
      const wallCells  = new Set();
      const doorCells  = new Set();
      for (let y = 0; y < intH; y++) {
        for (let x = 0; x < intW; x++) {
          floorCells.add(`${x},${y}`);
        }
      }
      // Walls = outer rim (any floor cell with a non-floor neighbor)
      for (const key of floorCells) {
        const [fx, fy] = key.split(',').map(Number);
        let isEdge = false;
        for (let dy = -1; dy <= 1 && !isEdge; dy++) {
          for (let dx = -1; dx <= 1 && !isEdge; dx++) {
            if (dx === 0 && dy === 0) continue;
            if (!floorCells.has(`${fx+dx},${fy+dy}`)) isEdge = true;
          }
        }
        if (isEdge) wallCells.add(key);
      }
      // Door at bottom center
      const doorX = Math.floor(intW / 2);
      const doorKey = `${doorX},${intH - 1}`;
      wallCells.delete(doorKey);
      doorCells.add(doorKey);

      const plan = { width: intW, height: intH, floorCells, wallCells, doorCells, rects: [{ x: 0, y: 0, w: intW, h: intH }] };
      const result = _igenBuild(plan, floorBrushIdx, wallBrushIdx);

      // Apply to editor state
      newInterior();
      gridW = result.width;
      gridH = result.height;
      document.getElementById('grid-w').value = gridW;
      document.getElementById('grid-h').value = gridH;
      document.getElementById('int-name').value = (buildingName || 'Building') + ' Interior';
      const typeSelect = document.getElementById('int-type');
      if (buildingType && [...typeSelect.options].some(o => o.value === buildingType)) {
        typeSelect.value = buildingType;
      }
      _linkedBuildingIds = [buildingId];
      _refreshLinkedBuildingChecklist();

      // Copy generated data
      for (const [ln, lyr] of Object.entries(result.layers)) {
        for (const [key, val] of Object.entries(lyr)) {
          layers[ln][key] = { ...val };
        }
      }
      for (const [key, val] of Object.entries(result.meta)) {
        meta[key] = { ...val };
      }
      brushGroupMap = JSON.parse(JSON.stringify(result.brushGroupMap));

      // Auto-save the generated interior
      saveInterior();

      // Preload images then render
      const paths = new Set();
      for (const lyr of Object.values(layers)) {
        for (const c of Object.values(lyr)) if (c.sheetPath) paths.add(c.sheetPath);
      }
      Promise.all([...paths].map(loadImage)).then(() => fitCanvas());
      toast('Interior auto-generated for ' + (buildingName || 'building'), 'ok');
      return;
    }

    // Fallback: no brushes available ‚Äî create empty interior
    newInterior();
    document.getElementById('int-name').value = (buildingName || 'Building') + ' Interior';
    const typeSelect = document.getElementById('int-type');
    if (buildingType && [...typeSelect.options].some(o => o.value === buildingType)) {
      typeSelect.value = buildingType;
    }
    // Set linked building
    _linkedBuildingIds = [buildingId];
    _refreshLinkedBuildingChecklist();
    // Adjust grid size based on building dimensions (clamped)
    if (buildingWidth && buildingHeight) {
      gridW = Math.max(4, Math.min(buildingWidth, 20));
      gridH = Math.max(4, Math.min(buildingHeight, 20));
      document.getElementById('grid-w').value = gridW;
      document.getElementById('grid-h').value = gridH;
    }
    fitCanvas();
    return;
  }

  if (ev.data.type === 'resourceTypesUpdate') {
    _setResourceTypes(ev.data.resourceTypes || []);
    return;
  }

  if (ev.data.type !== 'loadGamedata') return;
  const d = ev.data;
  if (Array.isArray(d.resourceTypes)) {
    _setResourceTypes(d.resourceTypes);
  }
  // Store buildings list for linked building checklist
  if (Array.isArray(d.buildings)) {
    _buildings = d.buildings;
    _refreshLinkedBuildingChecklist();
  }
  // Store custom objects for palette
  if (Array.isArray(d.objects)) {
    _customObjects = d.objects;
    buildPaletteCats();
  }
  // Import nine-tile brush definitions from parent
  if (Array.isArray(d.nineTileBrushes)) {
    const seenIds = new Set(nineTileBrushes.map(b => b.id));
    for (const brush of d.nineTileBrushes) {
      if (!seenIds.has(brush.id)) { nineTileBrushes.push(brush); seenIds.add(brush.id); }
    }
    buildNtbListPanel();
  }
  // Also load interiorBrushes (saved separately by editor.html)
  if (Array.isArray(d.interiorBrushes)) {
    const seenIds = new Set(nineTileBrushes.map(b => b.id));
    for (const brush of d.interiorBrushes) {
      if (!seenIds.has(brush.id)) { nineTileBrushes.push(brush); seenIds.add(brush.id); }
    }
    buildNtbListPanel();
  }
  // New flat format: d.interiors = [...]
  let allInteriorsToLoad = [];
  if (Array.isArray(d.interiors) && d.interiors.length) {
    allInteriorsToLoad = d.interiors;
  } else if (d.custom_interiors && d.custom_interiors.files) {
    // Legacy format fallback
    for (const fileData of Object.values(d.custom_interiors.files)) {
      if (Array.isArray(fileData.interiors)) allInteriorsToLoad.push(...fileData.interiors);
    }
  }
  if (allInteriorsToLoad.length) {
      // Import: convert array layers back to dict format, add margin
      const MARGIN = 1;
      const imported = allInteriorsToLoad.map(int => {
        const hasBounds = !!int.bounds;
        const offQ = hasBounds ? MARGIN - int.bounds.minCol : 0;
        const offR = hasBounds ? MARGIN - int.bounds.minRow : 0;
        const newLayers = {};
        for (const [ln, arr] of Object.entries(int.layers || {})) {
          newLayers[ln] = {};
          const cells = Array.isArray(arr) ? arr : Object.entries(arr).map(([k, v]) => {
            const [q, r] = k.split(',').map(Number);
            return { q, r, ...v };
          });
          for (const c of cells) {
            newLayers[ln][`${c.q + offQ},${c.r + offR}`] = {
              sheetPath: c.sheetPath, sx: c.sx, sy: c.sy, sw: c.sw || TILE, sh: c.sh || TILE
            };
          }
        }
        const newMeta = {};
        const metaArr = Array.isArray(int.meta) ? int.meta : Object.entries(int.meta || {}).map(([k, v]) => {
          const [q, r] = k.split(',').map(Number);
          return { q, r, ...v };
        });
        for (const m of metaArr) {
          const key = `${m.q + offQ},${m.r + offR}`;
          const entry = {};
          if (m.impassable) entry.impassable = true;
          if (m.door) entry.door = true;
          if (m.furniture) entry.furniture = { ...m.furniture };
          newMeta[key] = entry;
        }
        // Convert placedObjects from export array [{anchorQ, anchorR, ...}] back to dict {"q,r": obj}
        const newPlacedObjects = {};
        const poSrc = int.placedObjects || [];
        if (Array.isArray(poSrc)) {
          for (const po of poSrc) {
            const aq = (po.anchorQ != null ? po.anchorQ : 0) + offQ;
            const ar = (po.anchorR != null ? po.anchorR : 0) + offR;
            const { anchorQ, anchorR, ...rest } = po;
            newPlacedObjects[`${aq},${ar}`] = rest;
          }
        } else {
          // Already dict format (e.g. from internal save) ‚Äî just re-key with offset
          for (const [k, v] of Object.entries(poSrc)) {
            const [q, r] = k.split(',').map(Number);
            newPlacedObjects[`${q + offQ},${r + offR}`] = v;
          }
        }
        // Re-key brushGroupMap with offset
        const newBrushGroupMap = {};
        const bgSrc = int.brushGroupMap || {};
        for (const [k, v] of Object.entries(bgSrc)) {
          const [bq, br] = k.split(',').map(Number);
          newBrushGroupMap[`${bq + offQ},${br + offR}`] = v;
        }
        const w = hasBounds ? int.bounds.maxCol - int.bounds.minCol + 1 + MARGIN * 2 : (int.width || 10);
        const h = hasBounds ? int.bounds.maxRow - int.bounds.minRow + 1 + MARGIN * 2 : (int.height || 8);
        return { ...int, layers: newLayers, meta: newMeta, placedObjects: newPlacedObjects, brushGroupMap: newBrushGroupMap, width: w, height: h };
      });
      interiors = imported;
      // Merge all brush definitions from imported interiors
      const seenBrushIds = new Set(nineTileBrushes.map(b => b.id));
      for (const int of imported) {
        if (Array.isArray(int.nineTileBrushes)) {
          for (const brush of int.nineTileBrushes) {
            if (!seenBrushIds.has(brush.id)) {
              nineTileBrushes.push(brush);
              seenBrushIds.add(brush.id);
            }
          }
        }
      }
      buildNtbListPanel();
      refreshList();
      if (interiors.length) loadInterior(0);
  }
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  INIT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

(function init() {
  initCanvas();
  initPaletteResize();
  _renderNtbCostResourceRows({});
  buildPaletteCats();
  // Show first category
  const firstCat = Object.keys(PALETTE_DATA)[0];
  if (firstCat) {
    const btn = document.querySelector('.cat-btn');
    showCategory(firstCat, btn);
  }
  refreshList();
  buildNtbListPanel();
  // Defer fitCanvas until after layout is painted so clientWidth/clientHeight are real
  requestAnimationFrame(() => requestAnimationFrame(() => fitCanvas()));

  // Notify parent we're ready
  try { window.parent.postMessage({ type: 'interiorEditorReady' }, '*'); } catch (e) {}
})();
</script>
</body>
</html>
