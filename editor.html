<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Lord of the Realms â€” Editors</title>
<style>
*{box-sizing:border-box;margin:0;padding:0}
:root{
  --bg:#0d1117;--panel:#161b22;--panel2:#1c2129;
  --border:#21262d;--border2:#30363d;
  --text:#c9d1d9;--text-dim:#8b949e;
  --blue:#58a6ff;--green:#3fb950;--red:#f85149;--gold:#e6a817;--purple:#a371f7;
  --hover:#1c2129;
}
html,body{height:100%;overflow:hidden;background:var(--bg);color:var(--text);font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;font-size:13px}

/* â”€â”€â”€ Top Nav â”€â”€â”€ */
#nav{display:flex;align-items:center;background:var(--panel);border-bottom:2px solid var(--border);height:42px;flex-shrink:0;padding:0 12px;gap:4px;position:relative;z-index:100}
#nav .brand{font-size:13px;font-weight:700;color:var(--gold);margin-right:12px;white-space:nowrap;letter-spacing:.02em}
#nav .brand span{color:var(--text-dim);font-weight:400}
.nav-tab{display:flex;align-items:center;gap:6px;padding:6px 14px;border-radius:6px 6px 0 0;font-size:12px;font-weight:600;cursor:pointer;border:1px solid transparent;border-bottom:none;transition:background .12s,color .12s,border-color .12s;color:var(--text-dim);background:transparent;margin-bottom:-2px;position:relative;top:2px;user-select:none}
.nav-tab:hover{color:var(--text);background:var(--hover)}
.nav-tab.active{color:var(--gold);background:var(--bg);border-color:var(--border);border-bottom:2px solid var(--bg)}
.nav-tab .tab-icon{font-size:14px}
.nav-spacer{flex:1}

/* â”€â”€â”€ Content area â”€â”€â”€ */
#content{height:calc(100vh - 42px);position:relative}
.editor-pane{position:absolute;inset:0;display:none}
.editor-pane.active{display:block}
.editor-pane iframe{width:100%;height:100%;border:none;display:block}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   RESOURCE TYPES EDITOR
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
#res-editor{display:flex;flex-direction:column;height:100%;overflow:hidden;background:var(--bg)}

/* toolbar */
#res-toolbar{display:flex;align-items:center;gap:8px;padding:7px 14px;background:var(--panel);border-bottom:1px solid var(--border);flex-shrink:0;flex-wrap:wrap}
#res-toolbar h2{font-size:12px;font-weight:700;color:var(--text-dim);letter-spacing:.06em;text-transform:uppercase;margin-right:4px}
button{background:#21262d;border:1px solid var(--border2);color:var(--text);padding:4px 10px;border-radius:5px;cursor:pointer;font-size:12px;transition:background .12s,border-color .12s}
button:hover{background:#2d333b;border-color:#484f58}
button.active{background:#0b2a4a;border-color:var(--blue);color:var(--blue)}
button.green{background:#0e2a17;border-color:var(--green);color:var(--green)}
button.gold{background:#2a1f00;border-color:var(--gold);color:var(--gold)}
button.danger{background:#2a0d0d;border-color:var(--red);color:var(--red)}
button.purple{background:#1e0f3a;border-color:var(--purple);color:var(--purple)}
button:disabled{opacity:.4;cursor:not-allowed;pointer-events:none}
input[type="text"],input[type="number"],input[type="color"],select,textarea{background:#0d1117;border:1px solid var(--border2);color:var(--text);padding:3px 7px;border-radius:4px;font-size:12px}
input[type="text"]:focus,input[type="number"]:focus,select:focus,textarea:focus{outline:none;border-color:var(--blue)}
input[type="color"]{padding:2px;width:36px;height:26px;cursor:pointer}
textarea{resize:vertical;font-family:inherit}
.tb-sep{width:1px;height:22px;background:var(--border2);margin:0 2px}
.status-badge{font-size:11px;color:var(--text-dim);padding:2px 8px;background:var(--bg);border:1px solid var(--border);border-radius:10px}
.status-badge.ok{color:var(--green);border-color:var(--green)}
.status-badge.dirty{color:var(--gold);border-color:var(--gold)}

/* main split */
#res-main{display:flex;flex:1;overflow:hidden}

/* â”€â”€ Left: resource list â”€â”€ */
#res-list-panel{width:280px;min-width:180px;flex-shrink:0;background:var(--panel);border-right:1px solid var(--border);display:flex;flex-direction:column;overflow:hidden}
#res-list-header{display:flex;align-items:center;justify-content:space-between;padding:8px 12px;border-bottom:1px solid var(--border);flex-shrink:0}
#res-list-header h3{font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:.08em;color:var(--text-dim)}
#res-search{width:100%;background:#0d1117;border:none;border-bottom:1px solid var(--border);padding:6px 12px;color:var(--text);font-size:12px;flex-shrink:0}
#res-search:focus{outline:none;border-bottom-color:var(--blue)}
#res-list-scroll{flex:1;overflow-y:auto;padding:6px}
.res-card{display:flex;align-items:center;gap:8px;padding:7px 9px;border-radius:5px;cursor:pointer;border:1px solid transparent;transition:background .1s,border-color .1s;margin-bottom:2px}
.res-card:hover{background:var(--hover)}
.res-card.selected{background:#0b2a4a;border-color:var(--blue)}
.res-card .rc-icon{font-size:18px;width:24px;text-align:center;flex-shrink:0}
.res-card .rc-dot{width:10px;height:10px;border-radius:50%;flex-shrink:0;border:1px solid rgba(255,255,255,.15)}
.res-card .rc-info{flex:1;min-width:0}
.res-card .rc-name{font-size:12px;font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.res-card .rc-id{font-size:10px;color:var(--text-dim);font-family:monospace}
.res-card .rc-cat{font-size:10px;color:var(--text-dim)}
.res-card .rc-count{font-size:10px;color:var(--text-dim);flex-shrink:0;text-align:right}
.cat-badge{font-size:9px;padding:1px 5px;border-radius:8px;text-transform:uppercase;letter-spacing:.05em;font-weight:600}
.cat-ore   {background:#1a1208;color:#c8941c;border:1px solid #6b4f0e}
.cat-plant {background:#0c1f0e;color:#3fb950;border:1px solid #1f5e27}
.cat-animal{background:#1a0d0a;color:#e07050;border:1px solid #7a3020}
.cat-liquid{background:#0a1828;color:#58a6ff;border:1px solid #1a4a80}
.cat-mineral{background:#141420;color:#a371f7;border:1px solid #5a3a9a}
.cat-seafood{background:#081a1a;color:#4ae0e0;border:1px solid #1a6060}
.cat-other {background:#14141c;color:#8b949e;border:1px solid #30363d}
.list-empty{color:var(--text-dim);font-size:12px;font-style:italic;padding:12px;text-align:center}

/* â”€â”€ Centre/right split â”€â”€ */
#res-right{flex:1;display:flex;flex-direction:column;overflow:hidden}

/* â”€â”€ Edit form â”€â”€ */
#res-form-panel{padding:16px 18px;border-bottom:1px solid var(--border);flex-shrink:0;overflow-y:auto;max-height:52%}
#res-form-panel h3{font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:.08em;color:var(--text-dim);margin-bottom:12px}
.form-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px 16px}
.form-field{display:flex;flex-direction:column;gap:4px}
.form-field.full{grid-column:1/-1}
.form-field label{font-size:11px;color:var(--text-dim)}
.form-field input[type="text"],.form-field input[type="number"],.form-field select,.form-field textarea{width:100%}
.icon-row{display:flex;align-items:center;gap:8px}
.icon-row input{flex:1}
.icon-preview{font-size:24px;width:36px;text-align:center}
.color-row{display:flex;align-items:center;gap:8px}
.color-row input[type="text"]{flex:1;font-family:monospace}
.form-actions{display:flex;gap:8px;margin-top:14px;align-items:center}
#no-selection{color:var(--text-dim);font-size:12px;font-style:italic;padding:20px 18px}

/* â”€â”€ Terrain Chances â”€â”€ */
#res-chances-panel{flex:1;display:flex;flex-direction:column;overflow:hidden}
#res-chances-header{display:flex;align-items:center;justify-content:space-between;padding:8px 16px;border-bottom:1px solid var(--border);flex-shrink:0}
#res-chances-header h3{font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:.08em;color:var(--text-dim)}
#res-chances-scroll{flex:1;overflow:auto;padding:8px 16px}
.terrain-block{background:var(--panel);border:1px solid var(--border);border-radius:6px;margin-bottom:8px;overflow:hidden}
.terrain-block-header{display:flex;align-items:center;gap:8px;padding:6px 10px;background:var(--panel2);border-bottom:1px solid var(--border)}
.terrain-block-header .t-icon{font-size:14px}
.terrain-block-header .t-name{font-size:12px;font-weight:600}
.terrain-block-header .t-id{font-size:10px;color:var(--text-dim);font-family:monospace;margin-left:2px}
.terrain-block-header .t-add{margin-left:auto;font-size:10px;padding:2px 7px}
.chance-rows{padding:4px 6px}
.chance-row{display:flex;align-items:center;gap:8px;padding:4px 4px;border-bottom:1px solid rgba(255,255,255,.04)}
.chance-row:last-child{border-bottom:none}
.chance-row .cr-icon{font-size:14px;width:20px;text-align:center;flex-shrink:0}
.chance-row .cr-name{flex:1;font-size:11px}
.chance-row .cr-id{font-size:10px;color:var(--text-dim);font-family:monospace;min-width:80px}
.chance-row .cr-pct{width:56px;text-align:right;font-size:11px;font-family:monospace}
.chance-row input[type="number"]{width:68px;text-align:right}
.chance-bar{height:4px;border-radius:2px;background:var(--border2);margin:0 4px;position:relative;flex-shrink:0;width:60px}
.chance-bar-fill{height:100%;border-radius:2px;background:var(--green);transition:width .2s}
.terrain-block .no-chances{color:var(--text-dim);font-size:11px;font-style:italic;padding:6px 10px}

/* â”€â”€ Modals & Toasts â”€â”€ */
#toast{position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:#1c2129;border:1px solid var(--border2);border-radius:8px;padding:9px 18px;font-size:12px;pointer-events:none;opacity:0;transition:opacity .25s;z-index:9999;white-space:nowrap}
#toast.show{opacity:1}
#toast.ok{border-color:var(--green);color:var(--green)}
#toast.err{border-color:var(--red);color:var(--red)}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   TECH TREE EDITOR
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
#tt-editor{display:flex;flex-direction:column;height:100%;overflow:hidden;background:var(--bg)}
#tt-toolbar{display:flex;align-items:center;gap:8px;padding:7px 14px;background:var(--panel);border-bottom:1px solid var(--border);flex-shrink:0;flex-wrap:wrap}
#tt-toolbar h2{font-size:12px;font-weight:700;color:var(--text-dim);letter-spacing:.06em;text-transform:uppercase;margin-right:4px}
#tt-main{display:flex;flex:1;overflow:hidden}
#tt-list-panel{width:280px;min-width:180px;flex-shrink:0;background:var(--panel);border-right:1px solid var(--border);display:flex;flex-direction:column;overflow:hidden}
#tt-list-header{display:flex;align-items:center;justify-content:space-between;padding:8px 12px;border-bottom:1px solid var(--border);flex-shrink:0}
#tt-list-header h3{font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:.08em;color:var(--text-dim)}
#tt-search{width:100%;background:#0d1117;border:none;border-bottom:1px solid var(--border);padding:6px 12px;color:var(--text);font-size:12px;flex-shrink:0}
#tt-search:focus{outline:none;border-bottom-color:var(--blue)}
#tt-list-scroll{flex:1;overflow-y:auto;padding:6px}
#tt-right{flex:1;display:flex;flex-direction:column;overflow:hidden}
#tt-form-panel{padding:16px 18px;border-bottom:1px solid var(--border);flex-shrink:0;overflow-y:auto;max-height:52%}
#tt-form-panel h3{font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:.08em;color:var(--text-dim);margin-bottom:12px}
#tt-tree-panel{flex:1;display:flex;flex-direction:column;overflow:hidden;position:relative}
#tt-canvas{display:block}
.tt-card{display:flex;align-items:center;gap:8px;padding:7px 9px;border-radius:5px;cursor:pointer;border:1px solid transparent;transition:background .1s,border-color .1s;margin-bottom:2px}
.tt-card:hover{background:var(--hover)}
.tt-card.selected{background:#0b2a4a;border-color:var(--blue)}
.tt-card.builtin{opacity:.8;border-left:2px solid #30363d}
.tt-card.builtin .tc-name{color:#8b949e}
.tt-card .tc-icon{font-size:18px;width:24px;text-align:center;flex-shrink:0}
.tt-card .tc-info{flex:1;min-width:0}
.tt-card .tc-name{font-size:12px;font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.tt-card .tc-id{font-size:10px;color:var(--text-dim);font-family:monospace}
.tt-card .tc-cat{font-size:10px;color:var(--text-dim)}
.tt-badge{display:inline-block;font-size:8px;padding:1px 5px;border-radius:3px;font-weight:700;text-transform:uppercase;letter-spacing:.04em;vertical-align:middle}
.tt-badge.badge-builtin{background:rgba(139,148,158,.15);color:#8b949e;border:1px solid rgba(139,148,158,.25)}
.tt-badge.badge-custom{background:rgba(88,166,255,.1);color:var(--blue);border:1px solid rgba(88,166,255,.2)}
#tt-builtin-notice{background:rgba(240,180,40,.06);border:1px solid rgba(240,180,40,.18);border-radius:6px;padding:8px 12px;margin-bottom:10px;font-size:11px;color:#e6a817;line-height:1.5}
#tt-show-filter{display:flex;gap:6px;align-items:center;margin-left:6px}
#tt-show-filter label{font-size:11px;color:var(--text-dim);cursor:pointer;display:flex;align-items:center;gap:3px}
.tt-tag{display:inline-flex;align-items:center;gap:3px;font-size:10px;padding:2px 6px;border-radius:8px;background:#1a1828;color:var(--blue);border:1px solid rgba(88,166,255,.25);cursor:default}
.tt-tag .tag-x{cursor:pointer;font-size:12px;line-height:1;margin-left:2px;opacity:.6}
.tt-tag .tag-x:hover{opacity:1;color:var(--red)}

/* Prereq picker modal */
#tt-prereq-modal{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:500}
#tt-prereq-modal.open{display:flex}
#tt-prereq-box{background:var(--panel);border:1px solid var(--border2);border-radius:10px;width:380px;max-height:70vh;display:flex;flex-direction:column;overflow:hidden}
#tt-prereq-box h3{padding:12px 16px;font-size:12px;border-bottom:1px solid var(--border)}
#tt-prereq-list{flex:1;overflow-y:auto;padding:8px 12px}
#tt-prereq-list label{display:flex;align-items:center;gap:8px;padding:4px 6px;border-radius:4px;cursor:pointer;font-size:12px}
#tt-prereq-list label:hover{background:var(--hover)}
#tt-prereq-list label input{flex-shrink:0}
#tt-prereq-box .modal-actions{display:flex;justify-content:flex-end;padding:10px 16px;border-top:1px solid var(--border);gap:8px}

/* â”€â”€ Scrollbar â”€â”€ */
::-webkit-scrollbar{width:6px;height:6px}
::-webkit-scrollbar-track{background:transparent}
::-webkit-scrollbar-thumb{background:var(--border2);border-radius:3px}
::-webkit-scrollbar-thumb:hover{background:#484f58}
</style>
</head>
<body>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• TOP NAV â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="nav">
  <div class="brand">âš”ï¸ Lord of the Realms <span>Editors</span></div>
  <div class="nav-tab active" data-tab="sprite"    onclick="switchTab('sprite')">
    <span class="tab-icon">ğŸ¨</span> Sprite Editor
  </div>
  <div class="nav-tab" data-tab="spritesheet" onclick="switchTab('spritesheet')">
    <span class="tab-icon">ğŸ—‚ï¸</span> Spritesheet Editor
  </div>
  <div class="nav-tab" data-tab="interiors"   onclick="switchTab('interiors')">
    <span class="tab-icon">ğŸ </span> Interior Editor
  </div>
  <div class="nav-tab" data-tab="terrain"     onclick="switchTab('terrain')">
    <span class="tab-icon">ğŸ”</span> Terrain Editor
  </div>
  <div class="nav-tab" data-tab="resources"   onclick="switchTab('resources')">
    <span class="tab-icon">ğŸ’</span> Resource Types
  </div>
  <div class="nav-tab" data-tab="techtree"    onclick="switchTab('techtree')">
    <span class="tab-icon">ğŸ”¬</span> Tech Tree
  </div>
  <div class="nav-tab" data-tab="palettes"    onclick="switchTab('palettes')">
    <span class="tab-icon">ğŸ¨</span> Palettes
  </div>
  <div class="nav-spacer"></div>
  <button class="green" style="font-size:11px;padding:3px 9px" onclick="newGamedata()">ğŸ“„ New</button>
  <button class="purple" style="font-size:11px;padding:3px 9px" onclick="triggerImport()">â¬† Import</button>
  <input type="file" id="import-file" accept=".json" style="display:none" onchange="handleImport(event)">
  <button class="gold" style="font-size:11px;padding:3px 9px" onclick="exportGamedata()">â¬‡ Export gamedata.json</button>
  <span id="dirty-badge" class="status-badge" style="font-size:10px;margin-left:4px">unchanged</span>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• CONTENT â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="content">

  <!-- Sprite Editor iframe -->
  <div class="editor-pane active" id="pane-sprite">
    <iframe src="sprite_editor.html" id="iframe-sprite"></iframe>
  </div>

  <!-- Spritesheet Editor iframe -->
  <div class="editor-pane" id="pane-spritesheet">
    <!-- loaded lazily on first activation -->
  </div>

  <!-- Interior Editor iframe -->
  <div class="editor-pane" id="pane-interiors">
    <!-- loaded lazily on first activation -->
  </div>

  <!-- Terrain Editor iframe -->
  <div class="editor-pane" id="pane-terrain">
    <!-- loaded lazily on first activation -->
  </div>

  <!-- Palette Maker iframe -->
  <div class="editor-pane" id="pane-palettes">
    <!-- loaded lazily on first activation -->
  </div>

  <!-- Tech Tree inline editor -->
  <div class="editor-pane" id="pane-techtree">
    <div id="tt-editor">
      <div id="tt-toolbar">
        <h2>Tech Tree Builder</h2>
        <div class="tb-sep"></div>
        <button class="green" onclick="ttAddTech()">ï¼‹ New Tech</button>
        <button onclick="ttAddCategory()">ï¼‹ Category</button>
        <div class="tb-sep"></div>
        <label style="font-size:11px;color:var(--text-dim)">Category:</label>
        <select id="tt-cat-filter" onchange="ttRender()" style="font-size:12px;min-width:110px">
          <option value="">All</option>
        </select>
        <div id="tt-show-filter">
          <label><input type="checkbox" id="tt-show-builtin" checked onchange="ttRender();ttDrawTree()"> Built-in</label>
          <label><input type="checkbox" id="tt-show-custom" checked onchange="ttRender();ttDrawTree()"> Custom</label>
        </div>
      </div>
      <div id="tt-main">
        <div id="tt-list-panel">
          <div id="tt-list-header"><h3>Technologies (<span id="tt-count">0</span>)</h3></div>
          <input id="tt-search" type="text" placeholder="ğŸ”  Search techsâ€¦" oninput="ttRender()">
          <div id="tt-list-scroll"></div>
        </div>
        <div id="tt-right">
          <div id="tt-form-panel">
            <div id="tt-no-sel">â† Select a tech to edit, or click <strong>ï¼‹ New Tech</strong>.</div>
            <div id="tt-form" style="display:none">
              <h3>Edit Technology</h3>
              <div class="form-grid">
                <div class="form-field"><label>ID <span style="color:var(--text-dim)">(snake_case)</span></label><input type="text" id="tt-id" placeholder="e.g. steel_forging" oninput="markDirty()"></div>
                <div class="form-field"><label>Display Name</label><input type="text" id="tt-name" placeholder="e.g. Steel Forging" oninput="markDirty()"></div>
                <div class="form-field"><label>Icon (emoji)</label><div class="icon-row"><span class="icon-preview" id="tt-icon-preview">ğŸ”¬</span><input type="text" id="tt-icon" placeholder="ğŸ”¬" maxlength="4" oninput="document.getElementById('tt-icon-preview').textContent=this.value||'ğŸ”¬';markDirty()"></div></div>
                <div class="form-field"><label>Category</label><select id="tt-category" onchange="markDirty()"></select></div>
                <div class="form-field"><label>Tier</label><input type="number" id="tt-tier" value="1" min="1" max="10" step="1" style="width:60px" oninput="markDirty()"></div>
                <div class="form-field"><label>Cost (gold)</label><input type="number" id="tt-cost" value="100" min="0" step="50" style="width:80px" oninput="markDirty()"></div>
                <div class="form-field"><label>Days</label><input type="number" id="tt-days" value="5" min="1" max="999" step="1" style="width:60px" oninput="markDirty()"></div>
                <div class="form-field"><label>Research Mats <span style="color:var(--text-dim)">(JSON)</span></label><input type="text" id="tt-materials" placeholder='{"iron":10,"wood":5}' oninput="markDirty()"></div>
                <div class="form-field full">
                  <label>Prerequisites <span style="color:var(--text-dim)">(click to add/remove)</span></label>
                  <div id="tt-prereqs-tags" style="display:flex;flex-wrap:wrap;gap:4px;min-height:24px;padding:4px;background:#0d1117;border:1px solid var(--border2);border-radius:4px;cursor:pointer" onclick="ttOpenPrereqPicker()"></div>
                </div>
                <div class="form-field full"><label>Description</label><textarea id="tt-desc" rows="2" placeholder="What this tech doesâ€¦" oninput="markDirty()"></textarea></div>
                <div class="form-field full"><label>Flavor Text</label><textarea id="tt-flavor" rows="1" placeholder="Flavor quoteâ€¦" oninput="markDirty()"></textarea></div>
                <div class="form-field full">
                  <label>Effects <span style="color:var(--text-dim)">(JSON â€” e.g. {"farmProductionBonus":0.2})</span></label>
                  <textarea id="tt-effects" rows="2" placeholder='{"farmProductionBonus": 0.20}' oninput="markDirty()"></textarea>
                </div>
              </div>
              <div class="form-actions">
                <button class="green" onclick="ttSave()">ğŸ’¾ Save Tech</button>
                <button class="danger" onclick="ttDelete()">ğŸ—‘ Delete</button>
                <span id="tt-msg" style="font-size:11px;color:var(--text-dim);margin-left:4px"></span>
              </div>
            </div>
          </div>
          <div id="tt-tree-panel">
            <div style="display:flex;align-items:center;justify-content:space-between;padding:8px 16px;border-bottom:1px solid var(--border);flex-shrink:0">
              <h3 style="font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:.08em;color:var(--text-dim)">Tech Tree Preview</h3>
            </div>
            <canvas id="tt-canvas" style="width:100%;flex:1;cursor:grab"></canvas>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Resource Types inline editor -->
  <div class="editor-pane" id="pane-resources">
    <div id="res-editor">

      <!-- Toolbar -->
      <div id="res-toolbar">
        <h2>Resource Types</h2>
        <div class="tb-sep"></div>
        <button class="green" onclick="addNewResource()">ï¼‹ New Resource</button>
      </div>

      <div id="res-main">

        <!-- â”€â”€ Left: Resource List â”€â”€ -->
        <div id="res-list-panel">
          <div id="res-list-header">
            <h3>Resources (<span id="res-count">0</span>)</h3>
          </div>
          <input id="res-search" type="text" placeholder="ğŸ”  Search resourcesâ€¦" oninput="renderResourceList()">
          <div id="res-list-scroll"></div>
        </div>

        <!-- â”€â”€ Right â”€â”€ -->
        <div id="res-right">

          <!-- Edit form (top right) -->
          <div id="res-form-panel">
            <div id="no-selection">â† Select a resource to edit, or click <strong>ï¼‹ New Resource</strong>.</div>
            <div id="res-form" style="display:none">
              <h3>Edit Resource</h3>
              <div class="form-grid">
                <div class="form-field">
                  <label>ID <span style="color:var(--text-dim)">(snake_case)</span></label>
                  <input type="text" id="f-id" placeholder="e.g. gold_ore" oninput="markDirty()">
                </div>
                <div class="form-field">
                  <label>Display Name</label>
                  <input type="text" id="f-name" placeholder="e.g. Gold Veins" oninput="markDirty()">
                </div>
                <div class="form-field">
                  <label>Icon (emoji)</label>
                  <div class="icon-row">
                    <span class="icon-preview" id="f-icon-preview">â“</span>
                    <input type="text" id="f-icon" placeholder="âœ¨" maxlength="4" oninput="updateIconPreview();markDirty()">
                  </div>
                </div>
                <div class="form-field">
                  <label>Color</label>
                  <div class="color-row">
                    <input type="color" id="f-color-picker" oninput="syncColorText();markDirty()">
                    <input type="text" id="f-color" placeholder="#ffd700" maxlength="9" oninput="syncColorPicker();markDirty()">
                  </div>
                </div>
                <div class="form-field">
                  <label>Category</label>
                  <select id="f-category" onchange="markDirty()">
                    <option value="ore">â›ï¸ Ore / Metal</option>
                    <option value="mineral">ğŸ’ Gem / Mineral</option>
                    <option value="plant">ğŸŒ¿ Plant / Crop</option>
                    <option value="animal">ğŸ„ Animal / Livestock</option>
                    <option value="seafood">ğŸŸ Seafood / Aquatic</option>
                    <option value="liquid">ğŸ›¢ï¸ Liquid / Fuel</option>
                    <option value="other">ğŸ“¦ Other</option>
                  </select>
                </div>
                <div class="form-field">
                  <label>Base Value <span style="color:var(--text-dim)">(gold)</span></label>
                  <input type="number" id="f-value" min="0" step="1" placeholder="10" style="width:100%" oninput="markDirty()">
                </div>
                <div class="form-field">
                  <label>Usage</label>
                  <label style="display:flex;align-items:center;gap:8px;font-size:12px;color:var(--text);margin-top:4px">
                    <input type="checkbox" id="f-build-cost" onchange="markDirty()">
                    Usable in building cost menus
                  </label>
                </div>
                <div class="form-field full">
                  <label>Description <span style="color:var(--text-dim)">(optional)</span></label>
                  <textarea id="f-desc" rows="2" placeholder="Flavour text shown in the UIâ€¦" oninput="markDirty()"></textarea>
                </div>
              </div>
              <div class="form-actions">
                <button class="green" onclick="saveCurrentResource()">ğŸ’¾ Save Resource</button>
                <button class="danger" onclick="deleteCurrentResource()">ğŸ—‘ Delete</button>
                <span id="form-msg" style="font-size:11px;color:var(--text-dim);margin-left:4px"></span>
              </div>
            </div>
          </div>

          <!-- Terrain Spawn Chances (bottom right) -->
          <div id="res-chances-panel">
            <div id="res-chances-header">
              <h3>Terrain Spawn Chances</h3>
              <button class="green" style="font-size:11px;padding:3px 9px" onclick="addTerrainBlock()">ï¼‹ Add Terrain</button>
            </div>
            <div id="res-chances-scroll"></div>
          </div>

        </div><!-- /#res-right -->
      </div><!-- /#res-main -->
    </div><!-- /#res-editor -->
  </div><!-- /#pane-resources -->

</div><!-- /#content -->

<!-- Toast -->
<div id="toast"></div>

<!-- Prereq Picker Modal -->
<div id="tt-prereq-modal">
  <div id="tt-prereq-box">
    <h3>Select Prerequisites</h3>
    <div id="tt-prereq-list"></div>
    <div class="modal-actions">
      <button onclick="ttClosePrereqPicker()">Done</button>
    </div>
  </div>
</div>

<script src="editor-modstore.js"></script>
<script>
'use strict';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TAB SWITCHING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const iframeLoaded = { sprite: true, spritesheet: false, interiors: false, terrain: false, palettes: false, techtree: true };

function switchTab(name) {
  document.querySelectorAll('.nav-tab').forEach(t => t.classList.toggle('active', t.dataset.tab === name));
  document.querySelectorAll('.editor-pane').forEach(p => p.classList.toggle('active', p.id === `pane-${name}`));

  // Lazy-load iframes
  if (name === 'spritesheet' && !iframeLoaded.spritesheet) {
    iframeLoaded.spritesheet = true;
    const pane = document.getElementById('pane-spritesheet');
    const iframe = document.createElement('iframe');
    iframe.src = 'spritesheet_editor.html';
    pane.appendChild(iframe);
  }
  if (name === 'interiors' && !iframeLoaded.interiors) {
    iframeLoaded.interiors = true;
    const pane = document.getElementById('pane-interiors');
    const iframe = document.createElement('iframe');
    iframe.id = 'iframe-interiors';
    iframe.src = 'interior_editor.html';
    pane.appendChild(iframe);
  }
  if (name === 'terrain' && !iframeLoaded.terrain) {
    iframeLoaded.terrain = true;
    const pane = document.getElementById('pane-terrain');
    const iframe = document.createElement('iframe');
    iframe.id = 'iframe-terrain';
    iframe.src = 'terrain_editor.html';
    pane.appendChild(iframe);
  }
  if (name === 'palettes' && !iframeLoaded.palettes) {
    iframeLoaded.palettes = true;
    const pane = document.getElementById('pane-palettes');
    const iframe = document.createElement('iframe');
    iframe.id = 'iframe-palettes';
    iframe.src = 'palette_maker.html';
    pane.appendChild(iframe);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RESOURCE TYPES EDITOR â€” STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// The entire gamedata.json â€” single source of truth
let _gamedata = null;
// Alias for the terrain section (convenience for the resource editor)
let terrainData = null;

// Working copies of the two sections we edit
let resources    = {};   // KEY â†’ { id, name, icon, color, category, baseValue, description, buildCostEligible }
let resChanc     = {};   // terrainId â†’ [ { resource, chance } ]

let selectedId  = null;  // currently selected resource KEY
let dirty       = false;

const CATEGORY_LABELS = {
  ore:     { label: 'â›ï¸ Ore',      cls: 'cat-ore'    },
  mineral: { label: 'ğŸ’ Mineral',  cls: 'cat-mineral' },
  plant:   { label: 'ğŸŒ¿ Plant',    cls: 'cat-plant'   },
  animal:  { label: 'ğŸ„ Animal',   cls: 'cat-animal'  },
  seafood: { label: 'ğŸŸ Seafood',  cls: 'cat-seafood' },
  liquid:  { label: 'ğŸ›¢ï¸ Liquid',  cls: 'cat-liquid'  },
  other:   { label: 'ğŸ“¦ Other',    cls: 'cat-other'   },
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  INIT â€” load gamedata.json
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Built-in game data (technology, etc.) loaded from gamedata.json on disk
let _builtinGamedata = null;

function isLegacyBuildCostResource(id) {
  return ['wood', 'timber', 'stone', 'iron'].includes(String(id || '').toLowerCase());
}

function mergeTerrainWithBuiltins(terrain) {
  const base = (_builtinGamedata && _builtinGamedata.terrain) ? _builtinGamedata.terrain : {};
  const incoming = terrain || {};
  return {
    ...base,
    ...incoming,
    types: { ...(base.types || {}), ...(incoming.types || {}) },
    resources: { ...(base.resources || {}), ...(incoming.resources || {}) },
    resourceChances: { ...(base.resourceChances || {}), ...(incoming.resourceChances || {}) },
    biomeTable: (Array.isArray(incoming.biomeTable) && incoming.biomeTable.length)
      ? incoming.biomeTable
      : (base.biomeTable || []),
  };
}

(async function init() {
  // Always fetch the full gamedata.json to get built-in data (technology tree, etc.)
  try {
    const res = await fetch('data/gamedata.json');
    if (res.ok) _builtinGamedata = await res.json();
  } catch(e) { console.warn('Could not fetch gamedata.json for built-in data:', e); }

  try {
    // Try loading from browser storage first (IndexedDB)
    await ModStore.init();
    const stored = await ModStore.loadModData();
    if (stored && typeof stored === 'object' && (stored.terrain || stored.buildings || stored.objects)) {
      _gamedata = { ...makeEmptyGamedata(), ...stored };
      _gamedata.terrain = mergeTerrainWithBuiltins(_gamedata.terrain);
      // Inject built-in data that the editor doesn't persist but needs to display
      if (_builtinGamedata) _gamedata.technology = _builtinGamedata.technology;
      applyGamedata();
      toast('Loaded from browser storage', 'ok');
      return;
    }
  } catch (e) {
    console.warn('ModStore load failed, trying gamedata.json...', e);
  }
  // Fall back to the fetched gamedata.json
  if (_builtinGamedata) {
    _gamedata = _builtinGamedata;
    applyGamedata();
    toast('gamedata.json loaded', 'ok');
  } else {
    newGamedata(true /* silent */);
    toast('No saved data found â€” started fresh. Import or create new.', 'err');
  }
})();

function loadFromTerrainData(data) {
  resources = {};
  for (const [KEY, r] of Object.entries(data.resources || {})) {
    const rid = r.id || KEY.toLowerCase();
    resources[KEY] = {
      id:          rid,
      name:        r.name        || KEY,
      icon:        r.icon        || 'ğŸ“¦',
      color:       r.color       || '#888888',
      category:    r.category    || guessCategory(rid),
      baseValue:   r.baseValue   ?? 10,
      description: r.description || '',
      buildCostEligible: (r.buildCostEligible === true || r.buildCost === true || isLegacyBuildCostResource(rid)),
    };
  }
  resChanc = {};
  for (const [terrain, arr] of Object.entries(data.resourceChances || {})) {
    resChanc[terrain] = arr.map(o => ({ resource: o.resource, chance: o.chance }));
  }
  renderResourceList();
  renderChances();
  broadcastResourceTypes();
}

function getResourceTypesForEditors() {
  return Object.values(resources).map(r => ({
    id: r.id,
    name: r.name,
    icon: r.icon || 'ğŸ“¦',
    color: r.color || '#888888',
    buildCostEligible: !!r.buildCostEligible,
  }));
}

function broadcastResourceTypes() {
  const payload = { type: 'resourceTypesUpdate', resourceTypes: getResourceTypesForEditors() };
  const spr = document.getElementById('iframe-sprite');
  if (spr && spr.contentWindow) {
    try { spr.contentWindow.postMessage(payload, '*'); } catch (e) {}
  }
  const interior = document.getElementById('iframe-interiors');
  if (interior && interior.contentWindow) {
    try { interior.contentWindow.postMessage(payload, '*'); } catch (e) {}
  }
}

function guessCategory(id) {
  if (/iron|gold|coal|copper|tin|silver|mithril/.test(id)) return 'ore';
  if (/gem|diamond|ruby|emerald|sapphire|crystal|salt|stone/.test(id)) return 'mineral';
  if (/wheat|spice|timber|wood|cotton|silk|herb|flax|tea|coffee/.test(id)) return 'plant';
  if (/cattle|horse|sheep|pig|chicken|ivory|fur/.test(id)) return 'animal';
  if (/fish|seafood|whale|pearl|crab|shrimp/.test(id)) return 'seafood';
  if (/oil|water|wine|beer|alcohol/.test(id)) return 'liquid';
  return 'other';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RESOURCE LIST
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function renderResourceList() {
  const q   = (document.getElementById('res-search').value || '').toLowerCase();
  const scr = document.getElementById('res-list-scroll');
  const keys = Object.keys(resources).filter(k => {
    const r = resources[k];
    return !q || r.name.toLowerCase().includes(q) || r.id.toLowerCase().includes(q);
  });
  document.getElementById('res-count').textContent = Object.keys(resources).length;

  if (!keys.length) {
    scr.innerHTML = `<div class="list-empty">${q ? 'No matches.' : 'No resources yet.'}</div>`;
    return;
  }

  scr.innerHTML = '';
  for (const KEY of keys) {
    const r   = resources[KEY];
    const cat = CATEGORY_LABELS[r.category] || CATEGORY_LABELS.other;
    // Count how many terrain/chance entries reference this resource
    const refCount = Object.values(resChanc).flat().filter(e => e.resource === r.id).length;
    const card = document.createElement('div');
    card.className = `res-card${KEY === selectedId ? ' selected' : ''}`;
    card.dataset.key = KEY;
    card.innerHTML =
      `<div class="rc-icon">${r.icon}</div>` +
      `<div class="rc-dot" style="background:${r.color}"></div>` +
      `<div class="rc-info">` +
        `<div class="rc-name">${escHtml(r.name)}</div>` +
        `<div class="rc-id">${escHtml(r.id)}</div>` +
      `</div>` +
      `<div style="display:flex;flex-direction:column;align-items:flex-end;gap:3px">` +
        `<span class="cat-badge ${cat.cls}">${cat.label}</span>` +
        `<span class="rc-count" title="${refCount} terrain chance entr${refCount===1?'y':'ies'}">${refCount > 0 ? refCount+'ğŸ—º' : ''}</span>` +
      `</div>`;
    card.addEventListener('click', () => selectResource(KEY));
    scr.appendChild(card);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SELECTION / FORM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function selectResource(KEY) {
  selectedId = KEY;
  renderResourceList();
  populateForm(resources[KEY]);
}

function populateForm(r) {
  document.getElementById('no-selection').style.display = 'none';
  document.getElementById('res-form').style.display    = 'block';
  document.getElementById('f-id').value       = r.id;
  document.getElementById('f-name').value     = r.name;
  document.getElementById('f-icon').value     = r.icon;
  document.getElementById('f-icon-preview').textContent = r.icon;
  document.getElementById('f-color').value    = r.color;
  document.getElementById('f-color-picker').value = r.color.length === 7 ? r.color : '#888888';
  document.getElementById('f-category').value = r.category || 'other';
  document.getElementById('f-value').value    = r.baseValue ?? 10;
  document.getElementById('f-build-cost').checked = !!r.buildCostEligible;
  document.getElementById('f-desc').value     = r.description || '';
  document.getElementById('form-msg').textContent = '';
}

function updateIconPreview() {
  document.getElementById('f-icon-preview').textContent =
    document.getElementById('f-icon').value || 'â“';
}

function syncColorText() {
  document.getElementById('f-color').value = document.getElementById('f-color-picker').value;
}
function syncColorPicker() {
  const v = document.getElementById('f-color').value;
  if (/^#[0-9a-f]{6}$/i.test(v)) document.getElementById('f-color-picker').value = v;
}

function saveCurrentResource() {
  if (!selectedId) return;
  const newId = document.getElementById('f-id').value.trim().replace(/\s+/g, '_').toLowerCase();
  if (!newId) { setFormMsg('ID is required.', true); return; }

  // If id changed we need to rename the KEY and update chance refs
  const oldId = resources[selectedId].id;
  resources[selectedId] = {
    id:          newId,
    name:        document.getElementById('f-name').value.trim() || newId,
    icon:        document.getElementById('f-icon').value.trim() || 'ğŸ“¦',
    color:       document.getElementById('f-color').value.trim() || '#888888',
    category:    document.getElementById('f-category').value,
    baseValue:   parseFloat(document.getElementById('f-value').value) || 0,
    buildCostEligible: !!document.getElementById('f-build-cost').checked,
    description: document.getElementById('f-desc').value.trim(),
  };

  // Rename id in resChanc
  if (oldId !== newId) {
    for (const arr of Object.values(resChanc)) {
      for (const e of arr) { if (e.resource === oldId) e.resource = newId; }
    }
  }

  // If KEY doesn't match new id, rename key
  const newKEY = newId.toUpperCase().replace(/-/g, '_');
  if (newKEY !== selectedId) {
    resources[newKEY] = resources[selectedId];
    delete resources[selectedId];
    selectedId = newKEY;
  }

  renderResourceList();
  renderChances();
  broadcastResourceTypes();
  markDirty();
  setFormMsg('Saved.', false);
}

function deleteCurrentResource() {
  if (!selectedId) return;
  if (!confirm(`Delete "${resources[selectedId].name}"? All terrain chance entries for this resource will also be removed.`)) return;
  const delId = resources[selectedId].id;
  // Remove from chances
  for (const terrain of Object.keys(resChanc)) {
    resChanc[terrain] = resChanc[terrain].filter(e => e.resource !== delId);
    if (!resChanc[terrain].length) delete resChanc[terrain];
  }
  delete resources[selectedId];
  selectedId = null;
  document.getElementById('no-selection').style.display = '';
  document.getElementById('res-form').style.display     = 'none';
  renderResourceList();
  renderChances();
  broadcastResourceTypes();
  markDirty();
}

function addNewResource() {
  let n = 1;
  while (resources[`NEW_RESOURCE_${n}`]) n++;
  const KEY = `NEW_RESOURCE_${n}`;
  resources[KEY] = {
    id: `new_resource_${n}`, name: `New Resource ${n}`,
    icon: 'ğŸ“¦', color: '#888888', category: 'other', baseValue: 10, description: '', buildCostEligible: false,
  };
  renderResourceList();
  selectResource(KEY);
  document.getElementById('f-id').focus();
  markDirty();
}

function setFormMsg(msg, isErr) {
  const el = document.getElementById('form-msg');
  el.textContent = msg;
  el.style.color = isErr ? 'var(--red)' : 'var(--green)';
  if (!isErr) setTimeout(() => { if (el.textContent === msg) el.textContent = ''; }, 2000);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TERRAIN CHANCES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function renderChances() {
  const scr = document.getElementById('res-chances-scroll');
  scr.innerHTML = '';

  // Get terrain type info for icons and display names
  const types = terrainData && terrainData.types ? terrainData.types : {};

  const terrains = Object.keys(resChanc).sort();
  if (!terrains.length) {
    scr.innerHTML = '<div class="list-empty">No terrain spawn entries yet. Click <strong>ï¼‹ Add Terrain</strong>.</div>';
    return;
  }

  for (const terrain of terrains) {
    const tInfo = Object.values(types).find(t => t.id === terrain) || {};
    const icon  = tInfo.icon  || 'ğŸ—ºï¸';
    const tname = tInfo.name  || terrain;

    const block = document.createElement('div');
    block.className = 'terrain-block';
    block.dataset.terrain = terrain;

    const rows = resChanc[terrain];
    let rowsHtml = '';
    if (!rows || !rows.length) {
      rowsHtml = '<div class="no-chances">No resources â€” <a href="#" onclick="addChanceRow(event,\''+terrain+'\')">add one</a></div>';
    } else {
      rowsHtml = '<div class="chance-rows">';
      for (let i = 0; i < rows.length; i++) {
        const e   = rows[i];
        const rObj = Object.values(resources).find(r => r.id === e.resource) || {};
        const rIcon  = rObj.icon  || 'â“';
        const rName  = rObj.name  || e.resource;
        const rColor = rObj.color || '#888888';
        const pct    = Math.round(e.chance * 100);
        const barPct = Math.min(100, pct * 5); // scale: 20% chance = full bar
        rowsHtml +=
          `<div class="chance-row" data-terrain="${terrain}" data-idx="${i}">` +
            `<span class="cr-icon">${rIcon}</span>` +
            `<span class="cr-name">${escHtml(rName)}</span>` +
            `<span class="cr-id">${escHtml(e.resource)}</span>` +
            `<select class="cr-res-sel" data-terrain="${terrain}" data-idx="${i}" onchange="updateChance(this)">` +
              resourceOptions(e.resource) +
            `</select>` +
            `<div class="chance-bar"><div class="chance-bar-fill" style="width:${barPct}%;background:${rColor}"></div></div>` +
            `<input type="number" min="0" max="1" step="0.01" value="${e.chance}" style="width:68px;text-align:right"` +
              ` data-terrain="${terrain}" data-idx="${i}" oninput="updateChance(this)">` +
            `<button class="danger" style="font-size:10px;padding:1px 6px;flex-shrink:0"` +
              ` onclick="removeChanceRow('${terrain}',${i})">âœ•</button>` +
          `</div>`;
      }
      rowsHtml += '</div>';
    }

    block.innerHTML =
      `<div class="terrain-block-header">` +
        `<span class="t-icon">${icon}</span>` +
        `<span class="t-name">${escHtml(tname)}</span>` +
        `<span class="t-id">${escHtml(terrain)}</span>` +
        `<button class="t-add green" onclick="addChanceRow(event,'${terrain}')">ï¼‹ Add</button>` +
        `<button class="danger t-add" style="margin-left:4px" onclick="removeTerrain('${terrain}')">ğŸ—‘</button>` +
      `</div>` + rowsHtml;

    scr.appendChild(block);
  }
}

function resourceOptions(selected) {
  let html = '';
  for (const r of Object.values(resources).sort((a,b) => a.name.localeCompare(b.name))) {
    html += `<option value="${r.id}"${r.id === selected ? ' selected' : ''}>${r.icon} ${escHtml(r.name)}</option>`;
  }
  return html;
}

function updateChance(el) {
  const terrain = el.dataset.terrain;
  const idx     = parseInt(el.dataset.idx);
  const entry   = resChanc[terrain]?.[idx];
  if (!entry) return;
  if (el.tagName === 'SELECT') {
    entry.resource = el.value;
  } else {
    entry.chance = Math.min(1, Math.max(0, parseFloat(el.value) || 0));
  }
  markDirty();
  // Re-render to refresh bar + icon
  renderChances();
}

function addChanceRow(evtOrStr, terrainFromArg) {
  if (evtOrStr && typeof evtOrStr === 'object' && evtOrStr.preventDefault) evtOrStr.preventDefault();
  const terrain = terrainFromArg || evtOrStr;
  if (!resChanc[terrain]) resChanc[terrain] = [];
  // Pick a resource not already in this terrain
  const usedIds = resChanc[terrain].map(e => e.resource);
  const unused  = Object.values(resources).find(r => !usedIds.includes(r.id));
  resChanc[terrain].push({ resource: unused ? unused.id : 'iron', chance: 0.10 });
  markDirty();
  renderChances();
}

function removeChanceRow(terrain, idx) {
  resChanc[terrain].splice(idx, 1);
  if (!resChanc[terrain].length) delete resChanc[terrain];
  markDirty();
  renderChances();
}

function removeTerrain(terrain) {
  if (!confirm(`Remove all spawn chances for terrain "${terrain}"?`)) return;
  delete resChanc[terrain];
  markDirty();
  renderChances();
}

function addTerrainBlock() {
  // Show a quick prompt with available terrain types
  const types = terrainData && terrainData.types ? terrainData.types : {};
  const existing = new Set(Object.keys(resChanc));
  const available = Object.values(types)
    .filter(t => !existing.has(t.id))
    .map(t => `${t.icon} ${t.id}`)
    .join('\n');
  const input = prompt(
    'Enter terrain ID to add spawn chances for.\n\nAvailable terrains not yet in list:\n' +
    (available || '(all already added)'),
    ''
  );
  if (!input) return;
  const tid = input.trim().toLowerCase();
  if (!tid) return;
  if (resChanc[tid]) { toast('That terrain already has spawn chances.', 'err'); return; }
  resChanc[tid] = [];
  markDirty();
  renderChances();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  IMPORT / EXPORT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function buildTerrainJson() {
  // Compose output resources section
  const outResources = {};
  for (const [KEY, r] of Object.entries(resources)) {
    outResources[KEY] = {
      id:   r.id,
      name: r.name,
      icon: r.icon,
      color: r.color,
    };
    // Only include extended fields if non-default
    if (r.category && r.category !== 'other') outResources[KEY].category = r.category;
    if (r.baseValue && r.baseValue !== 10)     outResources[KEY].baseValue = r.baseValue;
    if (r.description)                          outResources[KEY].description = r.description;
    if (r.buildCostEligible)                    outResources[KEY].buildCostEligible = true;
  }
  // Compose output resourceChances
  const outChances = {};
  for (const [terrain, arr] of Object.entries(resChanc)) {
    if (arr.length) outChances[terrain] = arr.map(e => ({ resource: e.resource, chance: e.chance }));
  }
  return {
    ...(terrainData || {}),
    resources:       outResources,
    resourceChances: outChances,
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GAMEDATA â€” unified import / export / new
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function makeEmptyGamedata() {
  return {
    terrain:    { types: {}, resources: {}, resourceChances: {}, biomeTable: [] },
    buildings:  [],
    objects:    [],
    interiors:  [],
    interiorBrushes: [],
    terrainSets:     [],
    nineTileBrushes: [],
    doorCatalog:     [],
    windowCatalog:   [],
    customTechs: {
      categories: {},
      techs: {},
      researchCosts: {},
    },
  };
}

function newGamedata(silent) {
  _gamedata = makeEmptyGamedata();
  // Always inject built-in technology data
  if (_builtinGamedata && _builtinGamedata.technology) {
    _gamedata.technology = _builtinGamedata.technology;
  }
  applyGamedata();
  if (!silent) {
    dirty = false; updateDirtyBadge();
    autoSaveToBrowser();
    toast('Created blank gamedata', 'ok');
  }
}

/**
 * Distribute _gamedata to every sub-editor.
 */
function applyGamedata() {
  // Resource editor
  terrainData = mergeTerrainWithBuiltins(_gamedata.terrain || { types: {}, resources: {}, resourceChances: {}, biomeTable: [] });
  _gamedata.terrain = terrainData;
  loadFromTerrainData(terrainData);

  // Tech tree editor
  ttLoadFromGamedata();

  // Sprite editor (iframe) â€” send buildings + objects + terrainSets
  pushToSpriteEditor();

  // Interior editor (iframe) â€” send interiors
  pushToInteriorEditor();

  // Terrain editor (iframe) â€” send terrainSets + nineTileBrushes
  pushToTerrainEditor();
}

function pushToSpriteEditor() {
  const iframe = document.getElementById('iframe-sprite');
  if (iframe && iframe.contentWindow) {
    try {
      const techList = Object.values(_ttTechs).map(t => ({ id: t.id, name: t.name, icon: t.icon, category: t.category, _builtin: !!t._builtin }));
      iframe.contentWindow.postMessage({
        type: 'loadGamedata',
        buildings:       _gamedata.buildings       || [],
        objects:         _gamedata.objects         || [],
        terrainSets:     _gamedata.terrainSets     || [],
        nineTileBrushes: _gamedata.nineTileBrushes || [],
        doorCatalog:     _gamedata.doorCatalog     || [],
        windowCatalog:   _gamedata.windowCatalog   || [],
        techs:           techList,
        resourceTypes:   getResourceTypesForEditors(),
      }, '*');
    } catch (e) { /* iframe may not be ready yet */ }
  }
}

function pushToTerrainEditor() {
  const iframe = document.getElementById('iframe-terrain');
  if (iframe && iframe.contentWindow) {
    try {
      iframe.contentWindow.postMessage({
        type: 'loadGamedata',
        data: {
          terrainSets:     _gamedata.terrainSets     || [],
          nineTileBrushes: _gamedata.nineTileBrushes  || [],
          objects:         _gamedata.objects          || [],
        }
      }, '*');
    } catch (e) { /* iframe may not be ready yet */ }
  }
}

function pushToInteriorEditor() {
  const iframe = document.getElementById('iframe-interiors');
  if (iframe && iframe.contentWindow) {
    try {
      iframe.contentWindow.postMessage({
        type: 'loadGamedata',
        interiors: _gamedata.interiors || [],
        interiorBrushes: _gamedata.interiorBrushes || [],
        buildings: _gamedata.buildings || [],
        objects:   _gamedata.objects   || [],
        resourceTypes: getResourceTypesForEditors(),
      }, '*');
    } catch (e) { /* iframe may not be ready yet */ }
  }
}

// When the sprite/interior iframes load, push data to them
window.addEventListener('message', ev => {
  if (!ev.data || !ev.data.type) return;
  // Sprite editor is ready and asking for data
  if (ev.data.type === 'spriteEditorReady') {
    pushToSpriteEditor();
  }
  // Sprite editor is sending back updated data (on every save)
  if (ev.data.type === 'spriteDataChanged') {
    if (ev.data.buildings)       _gamedata.buildings       = ev.data.buildings;
    if (ev.data.objects)         _gamedata.objects         = ev.data.objects;
    if (ev.data.terrainSets)     _gamedata.terrainSets     = ev.data.terrainSets;
    if (ev.data.nineTileBrushes) _gamedata.nineTileBrushes = ev.data.nineTileBrushes;
    if (ev.data.doorCatalog)     _gamedata.doorCatalog     = ev.data.doorCatalog;
    if (ev.data.windowCatalog)   _gamedata.windowCatalog   = ev.data.windowCatalog;
    markDirty();
    // Push updated objects/buildings to sub-editors so their palettes refresh
    if (ev.data.objects || ev.data.buildings) {
      pushToInteriorEditor();
      pushToTerrainEditor();
    }
  }
  // Interior editor is ready and asking for data
  if (ev.data.type === 'interiorEditorReady') {
    pushToInteriorEditor();
  }
  // Interior editor is sending back updated data (on every save)
  if (ev.data.type === 'interiorDataChanged') {
    if (ev.data.interiors) _gamedata.interiors = ev.data.interiors;
    if (ev.data.nineTileBrushes) _gamedata.interiorBrushes = ev.data.nineTileBrushes;
    markDirty();
  }
  // Terrain editor is ready and asking for data
  if (ev.data.type === 'terrainEditorReady') {
    pushToTerrainEditor();
  }
  // Terrain editor is sending back updated data
  if (ev.data.type === 'terrainDataChanged') {
    if (ev.data.terrainSets)     _gamedata.terrainSets     = ev.data.terrainSets;
    if (ev.data.nineTileBrushes) _gamedata.nineTileBrushes  = ev.data.nineTileBrushes;
    markDirty();
  }
  // Sprite editor requests opening interior for a specific building
  if (ev.data.type === 'openBuildingInterior') {
    // Switch to interiors tab (lazy-loads iframe if needed)
    switchTab('interiors');
    // Forward to interior editor once it's ready
    const fwd = () => {
      const iframe = document.getElementById('iframe-interiors');
      if (iframe && iframe.contentWindow) {
        iframe.contentWindow.postMessage({
          type: 'openBuildingInterior',
          buildingId:     ev.data.buildingId,
          buildingName:   ev.data.buildingName,
          buildingType:   ev.data.buildingType,
          buildingWidth:  ev.data.buildingWidth,
          buildingHeight: ev.data.buildingHeight,
          autoGenerate:   ev.data.autoGenerate || false,
          buildings:      _gamedata.buildings || [],
        }, '*');
      }
    };
    // Small delay to let iframe load if it was just created
    if (iframeLoaded.interiors) { setTimeout(fwd, 100); }
    else { setTimeout(fwd, 1200); }
  }
});

function triggerImport() { document.getElementById('import-file').click(); }

function handleImport(ev) {
  const file = ev.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = e => {
    try {
      const parsed = JSON.parse(e.target.result);
      if (!parsed.terrain && !parsed.buildings && !parsed.objects) {
        throw new Error('Not a valid gamedata.json â€” missing expected keys.');
      }
      // Merge into a full gamedata shell (so partial files still work)
      _gamedata = { ...makeEmptyGamedata(), ...parsed };
      // Ensure built-in technology data is always available
      if (_builtinGamedata && _builtinGamedata.technology && !_gamedata.technology) {
        _gamedata.technology = _builtinGamedata.technology;
      }

      // â”€â”€ Migrate legacy custom_* nested format to flat arrays â”€â”€
      if (_gamedata.custom_buildings && !_gamedata.buildings?.length) {
        const files = _gamedata.custom_buildings.files || {};
        const all = [];
        for (const fileData of Object.values(files)) {
          if (Array.isArray(fileData.buildings)) all.push(...fileData.buildings);
        }
        if (all.length) _gamedata.buildings = all;
        delete _gamedata.custom_buildings;
      }
      if (_gamedata.custom_objects && !_gamedata.objects?.length) {
        const files = _gamedata.custom_objects.files || {};
        const all = [];
        for (const fileData of Object.values(files)) {
          const arr = fileData.objects || (Array.isArray(fileData) ? fileData : []);
          all.push(...arr);
        }
        if (all.length) _gamedata.objects = all;
        delete _gamedata.custom_objects;
      }
      if (_gamedata.custom_interiors && !_gamedata.interiors?.length) {
        const files = _gamedata.custom_interiors.files || {};
        const all = [];
        for (const fileData of Object.values(files)) {
          const arr = fileData.interiors || (Array.isArray(fileData) ? fileData : []);
          all.push(...arr);
        }
        if (all.length) _gamedata.interiors = all;
        delete _gamedata.custom_interiors;
      }

      applyGamedata();
      dirty = false;
      updateDirtyBadge();
      // Save imported data to browser storage immediately
      autoSaveToBrowser();
      toast('gamedata.json imported & saved to browser', 'ok');
    } catch (err) {
      toast('Import failed: ' + err.message, 'err');
    }
    ev.target.value = '';
  };
  reader.readAsText(file);
}

function exportGamedata() {
  // Collect latest terrain edits from the resource editor
  _gamedata.terrain = buildTerrainJson();
  // Collect latest tech tree edits
  _gamedata.customTechs = ttBuildGamedata();

  // Ask sprite iframe for latest buildings/objects via synchronous pull
  const iframe = document.getElementById('iframe-sprite');
  if (iframe && iframe.contentWindow && typeof iframe.contentWindow.getExportData === 'function') {
    const spriteData = iframe.contentWindow.getExportData();
    if (spriteData.buildings) _gamedata.buildings = spriteData.buildings;
    if (spriteData.objects)   _gamedata.objects   = spriteData.objects;
    if (spriteData.terrainSets)   _gamedata.terrainSets   = spriteData.terrainSets;
    if (spriteData.nineTileBrushes) _gamedata.nineTileBrushes = spriteData.nineTileBrushes;
    if (spriteData.windowCatalog) _gamedata.windowCatalog = spriteData.windowCatalog;
    if (spriteData.doorCatalog)   _gamedata.doorCatalog   = spriteData.doorCatalog;
  }

  // Ask interior iframe for latest interiors
  const intIframe = document.getElementById('iframe-interiors');
  if (intIframe && intIframe.contentWindow && typeof intIframe.contentWindow.getExportData === 'function') {
    const intData = intIframe.contentWindow.getExportData();
    if (intData.interiors) _gamedata.interiors = intData.interiors;
  }

  // Ask sprite editor for latest terrain sets (tbrush sets are authored there)
  const sprIframe2 = document.getElementById('iframe-sprite');
  if (sprIframe2 && sprIframe2.contentWindow && typeof sprIframe2.contentWindow.getExportData === 'function') {
    const sprData2 = sprIframe2.contentWindow.getExportData();
    if (sprData2.terrainSets) _gamedata.terrainSets = sprData2.terrainSets;
  }

  // Ask terrain editor iframe for latest nine-tile brushes and map data
  const terrIframe = document.getElementById('iframe-terrain');
  if (terrIframe && terrIframe.contentWindow && typeof terrIframe.contentWindow.getExportData === 'function') {
    const terrData = terrIframe.contentWindow.getExportData();
    if (terrData.terrainSets)     _gamedata.terrainSets     = terrData.terrainSets;
    if (terrData.nineTileBrushes) _gamedata.nineTileBrushes  = terrData.nineTileBrushes;
    if (terrData.terrainMap)      _gamedata.terrainMap       = terrData.terrainMap;
  }

  // Remove any legacy keys before export
  delete _gamedata.custom_buildings;
  delete _gamedata.custom_objects;
  delete _gamedata.custom_interiors;

  const blob = new Blob([JSON.stringify(_gamedata)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'gamedata.json';
  a.click();
  URL.revokeObjectURL(a.href);
  dirty = false;
  updateDirtyBadge();
  toast('gamedata.json downloaded', 'ok');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UTILITIES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function markDirty() {
  dirty = true;
  updateDirtyBadge();
  scheduleAutoSave();
}

// â”€â”€ Debounced auto-save to IndexedDB â”€â”€
let _autoSaveTimer = null;
function scheduleAutoSave() {
  clearTimeout(_autoSaveTimer);
  _autoSaveTimer = setTimeout(() => autoSaveToBrowser(), 1000);
}

/** Gather latest data from all sub-editors and save to IndexedDB */
async function autoSaveToBrowser() {
  if (!_gamedata) return;
  try {
    // Collect latest from resource editor
    _gamedata.terrain = buildTerrainJson();
    // Collect latest from tech tree editor
    _gamedata.customTechs = ttBuildGamedata();

    // Pull from sprite editor iframe
    const sprIframe = document.getElementById('iframe-sprite');
    if (sprIframe && sprIframe.contentWindow && typeof sprIframe.contentWindow.getExportData === 'function') {
      const sd = sprIframe.contentWindow.getExportData();
      if (sd.buildings)    _gamedata.buildings    = sd.buildings;
      if (sd.objects)      _gamedata.objects      = sd.objects;
      if (sd.terrainSets)  _gamedata.terrainSets  = sd.terrainSets;
      if (sd.nineTileBrushes) _gamedata.nineTileBrushes = sd.nineTileBrushes;
      if (sd.windowCatalog) _gamedata.windowCatalog = sd.windowCatalog;
      if (sd.doorCatalog)   _gamedata.doorCatalog   = sd.doorCatalog;
    }

    // Pull from interior editor iframe
    const intIframe = document.getElementById('iframe-interiors');
    if (intIframe && intIframe.contentWindow && typeof intIframe.contentWindow.getExportData === 'function') {
      const id = intIframe.contentWindow.getExportData();
      if (id.interiors) _gamedata.interiors = id.interiors;
      if (id.nineTileBrushes) _gamedata.interiorBrushes = id.nineTileBrushes;
    }

    // Pull from terrain editor iframe
    const terrIframe = document.getElementById('iframe-terrain');
    if (terrIframe && terrIframe.contentWindow && typeof terrIframe.contentWindow.getExportData === 'function') {
      const td = terrIframe.contentWindow.getExportData();
      if (td.terrainSets)     _gamedata.terrainSets     = td.terrainSets;
      if (td.nineTileBrushes) _gamedata.nineTileBrushes  = td.nineTileBrushes;
    }

    await ModStore.saveModData(_gamedata);
    console.log('[AutoSave] saved to IndexedDB');
  } catch (e) {
    console.warn('[AutoSave] failed:', e);
  }
}

function updateDirtyBadge() {
  const el = document.getElementById('dirty-badge');
  if (dirty) {
    el.textContent = 'â— unsaved changes';
    el.className   = 'status-badge dirty';
  } else {
    el.textContent = 'unchanged';
    el.className   = 'status-badge ok';
  }
}

let toastTimer = null;
function toast(msg, type = '') {
  const el = document.getElementById('toast');
  el.textContent = msg;
  el.className   = `show ${type}`;
  clearTimeout(toastTimer);
  toastTimer = setTimeout(() => { el.className = type; }, 2600);
}

function escHtml(str) {
  return String(str).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TECH TREE EDITOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let _ttCategories = {}; // id â†’ { id, name, icon, color }
let _ttTechs      = {}; // KEY â†’ { id, name, icon, category, tier, cost, days, requires, description, flavorText, effects, materials }
let _ttSelected   = null;

// Default categories from the game
const _ttDefaultCats = {
  agriculture:    { id:'agriculture',    name:'Agriculture',       icon:'ğŸŒ¾', color:'#4caf50' },
  industry:       { id:'industry',       name:'Industry',          icon:'âš’ï¸', color:'#ff9800' },
  military:       { id:'military',       name:'Military',          icon:'âš”ï¸', color:'#f44336' },
  infrastructure: { id:'infrastructure', name:'Infrastructure',    icon:'ğŸ›¤ï¸', color:'#9c27b0' },
  commerce:       { id:'commerce',       name:'Commerce',          icon:'ğŸ’°', color:'#ffc107' },
  naval:          { id:'naval',          name:'Naval',             icon:'âš“', color:'#0097a7' },
  culture:        { id:'culture',        name:'Culture & Learning',icon:'ğŸ“š', color:'#7e57c2' },
  medicine:       { id:'medicine',       name:'Medicine',          icon:'ğŸ’Š', color:'#66bb6a' },
};

function ttLoadFromGamedata() {
  const ct = _gamedata.customTechs || {};
  _ttCategories = { ..._ttDefaultCats, ...(ct.categories || {}) };
  _ttTechs = {};

  // Load built-in techs from the game's technology data
  const builtinTechs = (_gamedata.technology && _gamedata.technology.TECHS) || {};
  for (const [KEY, t] of Object.entries(builtinTechs)) {
    _ttTechs[KEY] = { ...t, _builtin: true };
  }

  // Load custom techs (overrides built-in if same KEY)
  for (const [KEY, t] of Object.entries(ct.techs || {})) {
    _ttTechs[KEY] = { ...t, _builtin: false };
  }
  ttBuildCatFilter();
  ttRender();
  ttDrawTree();
}

function ttBuildGamedata() {
  const cats = {};
  for (const [id, c] of Object.entries(_ttCategories)) {
    if (!_ttDefaultCats[id]) cats[id] = { ...c };
  }
  // Only export custom techs, not built-in ones
  const techs = {};
  const costs = {};
  for (const [KEY, t] of Object.entries(_ttTechs)) {
    if (t._builtin) continue; // skip built-in techs
    techs[KEY] = {
      id: t.id, name: t.name, icon: t.icon || 'ğŸ”¬',
      category: t.category, tier: t.tier || 1,
      cost: t.cost || 100, days: t.days || 5,
      requires: t.requires || [],
      description: t.description || '',
      flavorText: t.flavorText || '',
      effects: t.effects || {},
    };
    if (t.materials && Object.keys(t.materials).length) {
      costs[t.id] = { gold: t.cost || 100, materials: t.materials, days: t.days || 5 };
    }
  }
  return { categories: cats, techs, researchCosts: costs };
}

function ttBuildCatFilter() {
  const sel = document.getElementById('tt-cat-filter');
  const cur = sel.value;
  sel.innerHTML = '<option value="">All</option>';
  for (const c of Object.values(_ttCategories).sort((a,b) => a.name.localeCompare(b.name))) {
    sel.innerHTML += `<option value="${c.id}">${c.icon} ${escHtml(c.name)}</option>`;
  }
  sel.value = cur;
  // Also populate the form category dropdown
  const formCat = document.getElementById('tt-category');
  if (formCat) {
    const fc = formCat.value;
    formCat.innerHTML = '';
    for (const c of Object.values(_ttCategories).sort((a,b) => a.name.localeCompare(b.name))) {
      formCat.innerHTML += `<option value="${c.id}">${c.icon} ${escHtml(c.name)}</option>`;
    }
    formCat.value = fc;
  }
}

function ttRender() {
  const q = (document.getElementById('tt-search').value || '').toLowerCase();
  const catFilter = document.getElementById('tt-cat-filter').value;
  const showBuiltin = document.getElementById('tt-show-builtin').checked;
  const showCustom = document.getElementById('tt-show-custom').checked;
  const scr = document.getElementById('tt-list-scroll');
  const keys = Object.keys(_ttTechs).filter(k => {
    const t = _ttTechs[k];
    if (t._builtin && !showBuiltin) return false;
    if (!t._builtin && !showCustom) return false;
    if (catFilter && t.category !== catFilter) return false;
    return !q || t.name.toLowerCase().includes(q) || t.id.toLowerCase().includes(q);
  }).sort((a,b) => {
    const ta = _ttTechs[a], tb = _ttTechs[b];
    // Custom techs first, then built-in
    if (ta._builtin !== tb._builtin) return ta._builtin ? 1 : -1;
    if (ta.category !== tb.category) return (ta.category||'').localeCompare(tb.category||'');
    return (ta.tier||1) - (tb.tier||1) || ta.name.localeCompare(tb.name);
  });
  const totalCustom = Object.values(_ttTechs).filter(t => !t._builtin).length;
  const totalBuiltin = Object.values(_ttTechs).filter(t => t._builtin).length;
  document.getElementById('tt-count').textContent = `${totalCustom} custom Â· ${totalBuiltin} built-in`;
  if (!keys.length) {
    scr.innerHTML = `<div class="list-empty">${q||catFilter ? 'No matches.' : 'No techs loaded.'}</div>`;
    return;
  }
  scr.innerHTML = '';
  let lastSection = null;
  for (const KEY of keys) {
    const t = _ttTechs[KEY];
    const section = t._builtin ? 'builtin' : 'custom';
    if (section !== lastSection) {
      lastSection = section;
      const hdr = document.createElement('div');
      hdr.style.cssText = 'padding:6px 9px 3px;font-size:9px;font-weight:700;text-transform:uppercase;letter-spacing:.08em;color:var(--text-dim);border-bottom:1px solid var(--border);margin-bottom:2px';
      hdr.textContent = t._builtin ? `ğŸ“¦ Built-in (${totalBuiltin})` : `âœï¸ Custom (${totalCustom})`;
      scr.appendChild(hdr);
    }
    const cat = _ttCategories[t.category] || {};
    const card = document.createElement('div');
    card.className = `tt-card${KEY === _ttSelected ? ' selected' : ''}${t._builtin ? ' builtin' : ''}`;
    const badge = t._builtin
      ? '<span class="tt-badge badge-builtin" title="Part of the base game">base</span>'
      : '<span class="tt-badge badge-custom" title="Custom tech">mod</span>';
    card.innerHTML =
      `<div class="tc-icon">${t.icon || 'ğŸ”¬'}</div>` +
      `<div class="tc-info">` +
        `<div class="tc-name">${escHtml(t.name)} ${badge}</div>` +
        `<div class="tc-id">${escHtml(t.id)} Â· T${t.tier||1}</div>` +
      `</div>` +
      `<span style="font-size:10px;color:${cat.color||'var(--text-dim)'};opacity:.8">${cat.icon||''} ${escHtml(cat.name||t.category||'')}</span>`;
    card.addEventListener('click', () => ttSelect(KEY));
    scr.appendChild(card);
  }
}

function ttSelect(KEY) {
  _ttSelected = KEY;
  ttRender();
  const t = _ttTechs[KEY];
  if (!t) return;
  const isBuiltin = !!t._builtin;
  document.getElementById('tt-no-sel').style.display = 'none';
  document.getElementById('tt-form').style.display = 'block';

  // Show/hide built-in notice
  let notice = document.getElementById('tt-builtin-notice');
  if (!notice) {
    notice = document.createElement('div');
    notice.id = 'tt-builtin-notice';
    document.getElementById('tt-form').insertBefore(notice, document.getElementById('tt-form').firstChild);
  }
  if (isBuiltin) {
    notice.style.display = 'block';
    notice.innerHTML = 'ğŸ”’ <strong>Built-in tech</strong> â€” this is part of the base game\'s tech tree and cannot be edited. You can create new custom techs that <em>require</em> this tech as a prerequisite.';
  } else {
    notice.style.display = 'none';
  }

  document.getElementById('tt-id').value = t.id;
  document.getElementById('tt-name').value = t.name;
  document.getElementById('tt-icon').value = t.icon || '';
  document.getElementById('tt-icon-preview').textContent = t.icon || 'ğŸ”¬';
  document.getElementById('tt-category').value = t.category || 'agriculture';
  document.getElementById('tt-tier').value = t.tier || 1;
  document.getElementById('tt-cost').value = t.cost || 100;
  document.getElementById('tt-days').value = t.days || 5;
  document.getElementById('tt-materials').value = t.materials ? JSON.stringify(t.materials) : '';
  document.getElementById('tt-desc').value = t.description || '';
  document.getElementById('tt-flavor').value = t.flavorText || '';
  document.getElementById('tt-effects').value = t.effects ? JSON.stringify(t.effects) : '';
  _ttSelectedPrereqs = new Set(t.requires || []);
  ttRenderPrereqTags();

  // Disable/enable form fields based on built-in status
  const formFields = ['tt-id','tt-name','tt-icon','tt-category','tt-tier','tt-cost','tt-days','tt-materials','tt-desc','tt-flavor','tt-effects'];
  for (const fid of formFields) {
    const el = document.getElementById(fid);
    if (el) {
      el.disabled = isBuiltin;
      el.style.opacity = isBuiltin ? '0.5' : '1';
    }
  }
  // Disable prereq editing for built-in
  const prereqBox = document.getElementById('tt-prereqs-tags');
  if (prereqBox) {
    prereqBox.style.pointerEvents = isBuiltin ? 'none' : '';
    prereqBox.style.opacity = isBuiltin ? '0.5' : '1';
  }
  // Hide save/delete for built-in
  const actions = document.querySelector('#tt-form .form-actions');
  if (actions) actions.style.display = isBuiltin ? 'none' : '';
}

let _ttSelectedPrereqs = new Set();

function ttRenderPrereqTags() {
  const container = document.getElementById('tt-prereqs-tags');
  if (!_ttSelectedPrereqs.size) {
    container.innerHTML = '<span style="font-size:11px;color:var(--text-dim);font-style:italic">None â€” click to add prerequisites</span>';
    return;
  }
  container.innerHTML = '';
  for (const pid of _ttSelectedPrereqs) {
    // Find the tech with this id (works for both built-in and custom)
    const pt = Object.values(_ttTechs).find(t => t.id === pid);
    const label = pt ? `${pt.icon} ${pt.name}` : pid;
    const badgeHtml = pt && pt._builtin ? ' <span style="font-size:7px;color:#8b949e">(base)</span>' : '';
    container.innerHTML += `<span class="tt-tag">${escHtml(label)}${badgeHtml}<span class="tag-x" onclick="event.stopPropagation();_ttSelectedPrereqs.delete('${pid}');ttRenderPrereqTags();markDirty()">&times;</span></span>`;
  }
}

function ttOpenPrereqPicker() {
  const modal = document.getElementById('tt-prereq-modal');
  const list = document.getElementById('tt-prereq-list');
  list.innerHTML = '';
  const curId = document.getElementById('tt-id').value.trim();
  // Show ALL techs (built-in + custom) except self, so custom techs can depend on built-in ones
  const sorted = Object.values(_ttTechs).filter(t => t.id !== curId).sort((a,b) => {
    // Built-in first, then custom
    if (a._builtin !== b._builtin) return a._builtin ? -1 : 1;
    if (a.category !== b.category) return (a.category||'').localeCompare(b.category||'');
    return a.name.localeCompare(b.name);
  });
  if (!sorted.length) { list.innerHTML = '<div style="padding:12px;color:var(--text-dim);font-style:italic">No other techs to link to. Create more techs first.</div>'; }
  let lastSection = null;
  let lastCat = '';
  for (const t of sorted) {
    const section = t._builtin ? 'builtin' : 'custom';
    if (section !== lastSection) {
      lastSection = section;
      lastCat = '';
      list.innerHTML += `<div style="padding:8px 4px 3px;font-size:9px;font-weight:700;color:var(--text-dim);text-transform:uppercase;letter-spacing:.08em;border-bottom:1px solid var(--border);margin-top:4px">${t._builtin ? 'ğŸ“¦ Built-in Techs' : 'âœï¸ Custom Techs'}</div>`;
    }
    if (t.category !== lastCat) {
      lastCat = t.category;
      const cat = _ttCategories[t.category] || {};
      list.innerHTML += `<div style="padding:6px 4px 2px;font-size:10px;font-weight:700;color:${cat.color||'var(--text-dim)'};text-transform:uppercase;letter-spacing:.06em">${cat.icon||''} ${escHtml(cat.name||t.category||'Other')}</div>`;
    }
    const checked = _ttSelectedPrereqs.has(t.id) ? 'checked' : '';
    const badge = t._builtin ? ' <span style="font-size:8px;color:#8b949e;opacity:.7">(base)</span>' : '';
    list.innerHTML += `<label><input type="checkbox" value="${t.id}" ${checked} onchange="if(this.checked)_ttSelectedPrereqs.add('${t.id}');else _ttSelectedPrereqs.delete('${t.id}');ttRenderPrereqTags();markDirty()"><span>${t.icon} ${escHtml(t.name)}${badge}</span></label>`;
  }
  modal.classList.add('open');
}

function ttClosePrereqPicker() {
  document.getElementById('tt-prereq-modal').classList.remove('open');
}

function ttSave() {
  if (!_ttSelected) return;
  const newId = document.getElementById('tt-id').value.trim().replace(/\s+/g, '_').toLowerCase();
  if (!newId) { ttMsg('ID is required.', true); return; }
  let matObj = {};
  const matStr = document.getElementById('tt-materials').value.trim();
  if (matStr) { try { matObj = JSON.parse(matStr); } catch(e) { ttMsg('Invalid materials JSON.', true); return; } }
  let effObj = {};
  const effStr = document.getElementById('tt-effects').value.trim();
  if (effStr) { try { effObj = JSON.parse(effStr); } catch(e) { ttMsg('Invalid effects JSON.', true); return; } }
  const tech = {
    id: newId,
    name: document.getElementById('tt-name').value.trim() || newId,
    icon: document.getElementById('tt-icon').value.trim() || 'ğŸ”¬',
    category: document.getElementById('tt-category').value,
    tier: parseInt(document.getElementById('tt-tier').value) || 1,
    cost: parseInt(document.getElementById('tt-cost').value) || 100,
    days: parseInt(document.getElementById('tt-days').value) || 5,
    requires: [..._ttSelectedPrereqs],
    materials: matObj,
    description: document.getElementById('tt-desc').value.trim(),
    flavorText: document.getElementById('tt-flavor').value.trim(),
    effects: effObj,
  };
  // If KEY changed, rename
  const oldId = _ttTechs[_ttSelected].id;
  const newKEY = newId.toUpperCase().replace(/-/g, '_');
  if (newKEY !== _ttSelected) {
    delete _ttTechs[_ttSelected];
    _ttSelected = newKEY;
  }
  // Update prerequisite references in other techs if id changed
  if (oldId !== newId) {
    for (const t of Object.values(_ttTechs)) {
      if (t.requires) t.requires = t.requires.map(r => r === oldId ? newId : r);
    }
  }
  _ttTechs[_ttSelected] = tech;
  ttRender();
  ttDrawTree();
  markDirty();
  // Push tech list to sprite editor for object tech requirements
  pushTechListToSpriteEditor();
  ttMsg('Saved.', false);
}

function ttDelete() {
  if (!_ttSelected) return;
  const t = _ttTechs[_ttSelected];
  if (!confirm(`Delete tech "${t.name}"?`)) return;
  const delId = t.id;
  // Remove from other techs' prerequisites
  for (const ot of Object.values(_ttTechs)) {
    if (ot.requires) ot.requires = ot.requires.filter(r => r !== delId);
  }
  delete _ttTechs[_ttSelected];
  _ttSelected = null;
  document.getElementById('tt-no-sel').style.display = '';
  document.getElementById('tt-form').style.display = 'none';
  ttRender();
  ttDrawTree();
  markDirty();
  pushTechListToSpriteEditor();
}

function ttAddTech() {
  let n = 1;
  while (_ttTechs[`NEW_TECH_${n}`]) n++;
  const KEY = `NEW_TECH_${n}`;
  _ttTechs[KEY] = {
    id: `new_tech_${n}`, name: `New Tech ${n}`, icon: 'ğŸ”¬',
    category: document.getElementById('tt-cat-filter').value || 'agriculture',
    tier: 1, cost: 100, days: 5, requires: [],
    materials: {}, description: '', flavorText: '', effects: {},
  };
  ttRender();
  ttSelect(KEY);
  document.getElementById('tt-id').focus();
  markDirty();
  pushTechListToSpriteEditor();
}

function ttAddCategory() {
  const name = prompt('New category name:');
  if (!name) return;
  const id = name.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_|_$/g, '');
  if (_ttCategories[id]) { toast('Category already exists.', 'err'); return; }
  const icon = prompt('Icon emoji (e.g. ğŸ”¥):', 'âš¡') || 'âš¡';
  const color = prompt('Color hex (e.g. #ff9800):', '#58a6ff') || '#58a6ff';
  _ttCategories[id] = { id, name, icon, color };
  ttBuildCatFilter();
  markDirty();
  toast(`Category "${name}" added`, 'ok');
}

function ttMsg(msg, isErr) {
  const el = document.getElementById('tt-msg');
  el.textContent = msg;
  el.style.color = isErr ? 'var(--red)' : 'var(--green)';
  if (!isErr) setTimeout(() => { if (el.textContent === msg) el.textContent = ''; }, 2000);
}

// â”€â”€ Tech Tree Canvas Drawing â”€â”€
let _ttPanX = 40, _ttPanY = 40, _ttZoom = 1;
let _ttIsPanning = false, _ttPanStartX = 0, _ttPanStartY = 0, _ttPanOrigX = 0, _ttPanOrigY = 0;
let _ttNodePositions = {};  // tech id â†’ {x, y} in local (pre-transform) coords
let _ttNodeW = 140, _ttNodeH = 48;

function ttDrawTree() {
  const cvs = document.getElementById('tt-canvas');
  if (!cvs) return;
  const panel = document.getElementById('tt-tree-panel');
  const rect = panel.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  cvs.width = rect.width * dpr;
  cvs.height = (rect.height - 40) * dpr;
  cvs.style.width = rect.width + 'px';
  cvs.style.height = (rect.height - 40) + 'px';
  const ctx = cvs.getContext('2d');
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  ctx.clearRect(0, 0, rect.width, rect.height);

  const showBuiltin = document.getElementById('tt-show-builtin').checked;
  const showCustom = document.getElementById('tt-show-custom').checked;
  const techs = Object.values(_ttTechs).filter(t => {
    if (t._builtin && !showBuiltin) return false;
    if (!t._builtin && !showCustom) return false;
    return true;
  });
  if (!techs.length) {
    ctx.fillStyle = '#8b949e'; ctx.font = '13px sans-serif';
    ctx.textAlign = 'center'; ctx.fillText('Add technologies to see the tree', rect.width/2, (rect.height-40)/2);
    return;
  }

  // Apply pan + zoom transform
  ctx.save();
  ctx.translate(_ttPanX, _ttPanY);
  ctx.scale(_ttZoom, _ttZoom);

  // Zoom indicator
  ctx.restore();
  ctx.save();
  ctx.fillStyle = 'rgba(139,148,158,0.5)'; ctx.font = '10px sans-serif'; ctx.textAlign = 'right'; ctx.textBaseline = 'bottom';
  ctx.fillText(`${Math.round(_ttZoom*100)}%`, rect.width - 8, rect.height - 48);
  ctx.restore();
  ctx.save();
  ctx.translate(_ttPanX, _ttPanY);
  ctx.scale(_ttZoom, _ttZoom);

  // Group by category, then by tier
  const catGroups = {};
  for (const t of techs) {
    const cat = t.category || 'other';
    if (!catGroups[cat]) catGroups[cat] = [];
    catGroups[cat].push(t);
  }
  // Sort within each category by tier
  for (const arr of Object.values(catGroups)) arr.sort((a,b) => (a.tier||1) - (b.tier||1));

  const NODE_W = 140, NODE_H = 48, GAP_X = 36, GAP_Y = 24;
  const positions = {}; // tech id â†’ {x, y}

  // Layout: each category gets a row-band, techs arranged by tier columns
  const catKeys = Object.keys(catGroups).sort();
  let curY = 10;
  for (const cat of catKeys) {
    const catInfo = _ttCategories[cat] || {};
    // Category label
    ctx.fillStyle = catInfo.color || '#8b949e';
    ctx.font = 'bold 11px sans-serif'; ctx.textAlign = 'left';
    ctx.fillText(`${catInfo.icon||''} ${catInfo.name||cat}`, 10, curY + 10);
    curY += 22;

    // Group by tier within category
    const byTier = {};
    for (const t of catGroups[cat]) {
      const tier = t.tier || 1;
      if (!byTier[tier]) byTier[tier] = [];
      byTier[tier].push(t);
    }
    const tiers = Object.keys(byTier).map(Number).sort((a,b) => a-b);
    let maxRowH = 0;
    for (const tier of tiers) {
      const col = tier - 1;
      const colTechs = byTier[tier];
      for (let i = 0; i < colTechs.length; i++) {
        const x = 10 + col * (NODE_W + GAP_X);
        const y = curY + i * (NODE_H + GAP_Y);
        positions[colTechs[i].id] = { x, y };
        maxRowH = Math.max(maxRowH, (i+1) * (NODE_H + GAP_Y));
      }
    }
    curY += maxRowH + 16;
  }

  // Draw edges (prerequisite lines)
  ctx.lineWidth = 1.5;
  for (const t of techs) {
    const pos = positions[t.id];
    if (!pos) continue;
    for (const req of (t.requires || [])) {
      const rpos = positions[req];
      if (!rpos) continue;
      ctx.strokeStyle = 'rgba(88,166,255,0.3)';
      ctx.beginPath();
      ctx.moveTo(rpos.x + NODE_W, rpos.y + NODE_H/2);
      ctx.lineTo(pos.x, pos.y + NODE_H/2);
      ctx.stroke();
      // Arrow head
      const ax = pos.x, ay = pos.y + NODE_H/2;
      ctx.fillStyle = 'rgba(88,166,255,0.4)';
      ctx.beginPath();
      ctx.moveTo(ax, ay);
      ctx.lineTo(ax - 6, ay - 4);
      ctx.lineTo(ax - 6, ay + 4);
      ctx.closePath(); ctx.fill();
    }
  }

  // Draw nodes
  for (const t of techs) {
    const pos = positions[t.id];
    if (!pos) continue;
    const cat = _ttCategories[t.category] || {};
    const isSelected = _ttSelected && _ttTechs[_ttSelected] && _ttTechs[_ttSelected].id === t.id;
    const isBuiltin = !!t._builtin;
    // Node box â€” built-in techs use a dimmer, dotted border style
    ctx.fillStyle = isSelected ? '#0b2a4a' : (isBuiltin ? '#12161d' : '#161b22');
    ctx.strokeStyle = isSelected ? '#58a6ff' : (isBuiltin ? '#30363d' : (cat.color || '#30363d'));
    ctx.lineWidth = isSelected ? 2 : 1;
    if (isBuiltin && !isSelected) ctx.setLineDash([3, 2]); else ctx.setLineDash([]);
    ctx.beginPath();
    ctx.roundRect(pos.x, pos.y, NODE_W, NODE_H, 6);
    ctx.fill(); ctx.stroke();
    ctx.setLineDash([]);
    // Icon
    ctx.font = '16px serif'; ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
    ctx.globalAlpha = isBuiltin ? 0.7 : 1;
    ctx.fillText(t.icon || 'ğŸ”¬', pos.x + 6, pos.y + NODE_H/2);
    // Name
    ctx.fillStyle = isBuiltin ? '#8b949e' : '#c9d1d9'; ctx.font = 'bold 10px sans-serif'; ctx.textBaseline = 'top';
    const maxTextW = NODE_W - 32;
    let displayName = t.name;
    while (ctx.measureText(displayName).width > maxTextW && displayName.length > 3) displayName = displayName.slice(0,-1);
    if (displayName !== t.name) displayName += 'â€¦';
    ctx.fillText(displayName, pos.x + 26, pos.y + 8);
    // Tier + builtin badge
    ctx.fillStyle = '#8b949e'; ctx.font = '9px sans-serif';
    ctx.fillText(`T${t.tier||1} Â· ${t.cost||0}g${isBuiltin ? ' Â· base' : ''}`, pos.x + 26, pos.y + 24);
    ctx.globalAlpha = 1;
    // Prereq count badge
    if (t.requires && t.requires.length) {
      ctx.fillStyle = 'rgba(88,166,255,0.15)';
      ctx.beginPath(); ctx.roundRect(pos.x + NODE_W - 22, pos.y + 4, 18, 14, 3); ctx.fill();
      ctx.fillStyle = '#58a6ff'; ctx.font = '9px sans-serif'; ctx.textAlign = 'center';
      ctx.fillText(t.requires.length, pos.x + NODE_W - 13, pos.y + 7);
    }
    ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
  }
  // Store positions for hit-testing
  _ttNodePositions = positions;
  _ttNodeW = NODE_W; _ttNodeH = NODE_H;
  ctx.restore();
}

// â”€â”€ Pan & Zoom event handlers â”€â”€
{
  const cvs = document.getElementById('tt-canvas');
  if (cvs) {
    let _ttDragDist = 0;  // track total drag movement to distinguish click vs pan

    // Pan: middle-click drag or left-click drag
    cvs.addEventListener('mousedown', e => {
      // left button (0) or middle button (1)
      if (e.button === 0 || e.button === 1) {
        _ttIsPanning = true;
        _ttDragDist = 0;
        _ttPanStartX = e.clientX;
        _ttPanStartY = e.clientY;
        _ttPanOrigX = _ttPanX;
        _ttPanOrigY = _ttPanY;
        cvs.style.cursor = 'grabbing';
        e.preventDefault();
      }
    });
    window.addEventListener('mousemove', e => {
      if (!_ttIsPanning) return;
      const dx = e.clientX - _ttPanStartX;
      const dy = e.clientY - _ttPanStartY;
      _ttDragDist = Math.abs(dx) + Math.abs(dy);
      _ttPanX = _ttPanOrigX + dx;
      _ttPanY = _ttPanOrigY + dy;
      ttDrawTree();
    });
    window.addEventListener('mouseup', e => {
      if (_ttIsPanning) {
        const wasDrag = _ttDragDist > 4;
        _ttIsPanning = false;
        cvs.style.cursor = 'grab';
        // If it was a click (not a drag), hit-test nodes
        if (!wasDrag && e.button === 0) {
          const rect = cvs.getBoundingClientRect();
          const mx = (e.clientX - rect.left - _ttPanX) / _ttZoom;
          const my = (e.clientY - rect.top - _ttPanY) / _ttZoom;
          let hit = null;
          for (const [tid, pos] of Object.entries(_ttNodePositions)) {
            if (mx >= pos.x && mx <= pos.x + _ttNodeW && my >= pos.y && my <= pos.y + _ttNodeH) {
              hit = tid; break;
            }
          }
          if (hit) {
            // Find the KEY in _ttTechs whose .id matches
            const key = Object.keys(_ttTechs).find(k => _ttTechs[k].id === hit);
            if (key) { ttSelect(key); }
          }
        }
      }
    });

    // Zoom: mouse wheel with zoom-toward-cursor
    cvs.addEventListener('wheel', e => {
      e.preventDefault();
      const rect = cvs.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const oldZoom = _ttZoom;
      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      _ttZoom = Math.min(3, Math.max(0.15, _ttZoom * delta));
      // Adjust pan so the point under the cursor stays fixed
      _ttPanX = mx - (_ttZoom / oldZoom) * (mx - _ttPanX);
      _ttPanY = my - (_ttZoom / oldZoom) * (my - _ttPanY);
      ttDrawTree();
    }, { passive: false });

    // Prevent context-menu on middle-click
    cvs.addEventListener('contextmenu', e => e.preventDefault());
  }
}

// Resize observer for the tree canvas
new ResizeObserver(() => ttDrawTree()).observe(document.getElementById('tt-tree-panel') || document.body);

// â”€â”€ Push tech list to sprite editor â”€â”€
function pushTechListToSpriteEditor() {
  const iframe = document.getElementById('iframe-sprite');
  if (!iframe || !iframe.contentWindow) return;
  // Include both built-in and custom techs so objects can reference any tech
  const techList = Object.values(_ttTechs).map(t => ({ id: t.id, name: t.name, icon: t.icon, category: t.category, _builtin: !!t._builtin }));
  try {
    iframe.contentWindow.postMessage({ type: 'techListUpdate', techs: techList }, '*');
  } catch(e) { /* ignore */ }
}
</script>
</body>
</html>
