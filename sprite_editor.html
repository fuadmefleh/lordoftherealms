<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Sprite Editor â€” Lord of the Realms</title>
<style>
*{box-sizing:border-box;margin:0;padding:0}
:root{--bg:#0d1117;--panel:#161b22;--border:#21262d;--border2:#30363d;--text:#c9d1d9;--text-dim:#8b949e;--blue:#58a6ff;--green:#3fb950;--red:#f85149;--gold:#e6a817;--hover:#1c2129}
body{background:var(--bg);color:var(--text);font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;font-size:13px;height:100vh;display:flex;flex-direction:column;overflow:hidden}

/* â”€â”€ Toolbar â”€â”€ */
#toolbar{display:flex;align-items:center;gap:10px;padding:6px 12px;background:var(--panel);border-bottom:1px solid var(--border);flex-shrink:0;flex-wrap:wrap}
#toolbar h1{font-size:14px;font-weight:700;color:var(--gold);margin-right:4px;white-space:nowrap}
.tb-sep{width:1px;height:20px;background:var(--border2);margin:0 2px}
.tb-group{display:flex;align-items:center;gap:6px}
.tb-lbl{font-size:11px;color:var(--text-dim);white-space:nowrap}
button{background:#21262d;border:1px solid var(--border2);color:var(--text);padding:4px 10px;border-radius:5px;cursor:pointer;font-size:12px;transition:background .12s,border-color .12s}
button:hover{background:#2d333b;border-color:#484f58}
button.active{background:#0b2a4a;border-color:var(--blue);color:var(--blue)}
button.green{background:#0e2a17;border-color:var(--green);color:var(--green)}
button.gold{background:#2a1f00;border-color:var(--gold);color:var(--gold)}
button.danger{background:#2a0d0d;border-color:var(--red);color:var(--red)}
button.blue{background:#0b2a4a;border-color:var(--blue);color:var(--blue)}
input[type="number"],input[type="text"],select{background:#0d1117;border:1px solid var(--border2);color:var(--text);padding:3px 7px;border-radius:4px;font-size:12px}
input[type="number"]{width:52px}
input[type="text"]{width:140px}
input:focus,select:focus{outline:none;border-color:var(--blue)}

.mode-tab{padding:4px 14px;font-weight:600;border-radius:4px;font-size:12px}
.mode-tab.active{background:#2a1f00;border-color:var(--gold);color:var(--gold)}

/* â”€â”€ Collapsible Sections â”€â”€ */
.collapse-chevron{cursor:pointer;font-size:14px;color:var(--text-dim);user-select:none;margin-right:4px;display:inline-block;transition:color .12s;line-height:1}
.collapse-chevron:hover{color:var(--text)}
#palette-panel.pal-collapsed #palette-cats,
#palette-panel.pal-collapsed #palette-sheets{display:none!important}
#n9b-panel.section-collapsed #n9b-list,
#n9b-panel.section-collapsed #n9b-props{display:none!important}
#n9b-panel.section-collapsed .n9b-panel-body{display:none!important}
#wcat-panel.section-collapsed #wcat-list,
#wcat-panel.section-collapsed #wcat-props{display:none!important}
#wcat-panel.section-collapsed .wcat-panel-body{display:none!important}

/* â”€â”€ 9-Tile Brush UI â”€â”€ */
.n9b-panel{border-top:1px solid var(--border);overflow-y:auto;flex-shrink:0;max-height:45vh;padding:8px}
.n9b-panel h3{font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:.08em;color:var(--text-dim);margin-bottom:6px}
.n9b-card{background:var(--bg);border:1px solid var(--border);border-radius:4px;margin-bottom:4px;padding:4px 7px;cursor:pointer;display:flex;align-items:center;gap:5px}
.n9b-card:hover{border-color:var(--blue)}
.n9b-card.selected{border-color:var(--blue);background:#14263d}
.n9b-name{flex:1;font-size:11px;font-weight:500;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.n9b-preview{width:48px;height:48px;border:1px solid var(--border);border-radius:3px;image-rendering:pixelated;flex-shrink:0}
.n9b-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:2px;margin-top:6px}
.n9b-cell{aspect-ratio:1;border:1px solid var(--border);border-radius:2px;background:var(--bg);cursor:pointer;position:relative;overflow:hidden}
.n9b-cell:hover{border-color:var(--blue)}
.n9b-cell.assigned{border-color:rgba(63,185,80,.5)}
.n9b-cell.selected-slot{border-color:var(--gold);border-width:2px;box-shadow:0 0 4px rgba(230,168,23,.3)}
.n9b-cell canvas{display:block;width:100%;height:100%;image-rendering:pixelated}
.n9b-cell .n9b-lbl{position:absolute;bottom:0;left:0;right:0;font-size:7px;color:var(--text-dim);background:rgba(0,0,0,.65);text-align:center;line-height:1.3}

/* â”€â”€ Window Catalog UI â”€â”€ */
.wcat-panel{border-top:1px solid var(--border);overflow-y:auto;flex-shrink:0;max-height:35vh;padding:8px}
.wcat-panel h3{font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:.08em;color:var(--text-dim);margin-bottom:6px}
.wcat-list{display:flex;flex-wrap:wrap;gap:4px;margin-bottom:6px}
.wcat-card{background:var(--bg);border:1px solid var(--border);border-radius:4px;padding:3px;cursor:pointer;display:flex;flex-direction:column;align-items:center;gap:2px;min-width:56px}
.wcat-card:hover{border-color:var(--blue)}
.wcat-card.selected{border-color:var(--gold);background:#2a1f00}
.wcat-card.picking{border-color:var(--green);box-shadow:0 0 6px rgba(63,185,80,.4);animation:wcat-pulse 1s infinite}
@keyframes wcat-pulse{0%,100%{box-shadow:0 0 4px rgba(63,185,80,.3)}50%{box-shadow:0 0 10px rgba(63,185,80,.6)}}
.wcat-card canvas{width:32px;height:32px;image-rendering:pixelated;border:1px solid var(--border);border-radius:2px;background:#0a0e14}
.wcat-card .wcat-name{font-size:9px;color:var(--text);max-width:60px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;text-align:center}

/* â”€â”€ Door Catalog UI â”€â”€ */
.dcat-panel{border-top:1px solid var(--border);overflow-y:auto;flex-shrink:0;max-height:35vh;padding:8px}
.dcat-panel h3{font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:.08em;color:var(--text-dim);margin-bottom:6px}
.dcat-list{display:flex;flex-wrap:wrap;gap:4px;margin-bottom:6px}
.dcat-card{background:var(--bg);border:1px solid var(--border);border-radius:4px;padding:3px;cursor:pointer;display:flex;flex-direction:column;align-items:center;gap:2px;min-width:56px}
.dcat-card:hover{border-color:var(--blue)}
.dcat-card.selected{border-color:var(--gold);background:#2a1f00}
.dcat-card.picking{border-color:var(--green);box-shadow:0 0 6px rgba(63,185,80,.4);animation:wcat-pulse 1s infinite}
.dcat-card canvas{width:96px;height:64px;image-rendering:pixelated;border:1px solid var(--border);border-radius:2px;background:#0a0e14}
.dcat-card .dcat-name{font-size:9px;color:var(--text);max-width:60px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;text-align:center}
#dcat-panel.section-collapsed #dcat-list,
#dcat-panel.section-collapsed #dcat-props{display:none!important}
#dcat-panel.section-collapsed .dcat-panel-body{display:none!important}

/* â”€â”€ Procedural Building Modal â”€â”€ */
.pbg-overlay{position:fixed;inset:0;background:rgba(0,0,0,.55);z-index:10000;display:flex;align-items:center;justify-content:center;animation:pbg-fadein .15s}
@keyframes pbg-fadein{from{opacity:0}to{opacity:1}}
@keyframes pbg-scalein{from{transform:scale(.95);opacity:0}to{transform:scale(1);opacity:1}}
.pbg-modal{background:var(--panel);border:1px solid var(--border);border-radius:8px;padding:20px 24px;min-width:440px;max-width:560px;box-shadow:0 8px 32px rgba(0,0,0,.6);animation:pbg-scalein .15s;max-height:90vh;overflow-y:auto}
.pbg-modal h3{margin:0 0 14px;font-size:15px;font-weight:700;color:var(--gold)}
.pbg-section{margin-bottom:14px;padding:10px 12px;background:var(--bg);border:1px solid var(--border);border-radius:6px}
.pbg-section h4{font-size:11px;font-weight:600;color:var(--text-dim);text-transform:uppercase;letter-spacing:.5px;margin:0 0 8px}
.pbg-row{display:flex;align-items:center;gap:8px;margin-bottom:6px}
.pbg-row:last-child{margin-bottom:0}
.pbg-row label{font-size:12px;color:var(--text);min-width:90px}
.pbg-row select,.pbg-row input[type="number"]{flex:1;max-width:180px}
.pbg-row input[type="range"]{flex:1;max-width:140px;accent-color:var(--blue)}
.pbg-row .range-val{font-size:11px;color:var(--text-dim);min-width:18px;text-align:center}
.pbg-row input[type="checkbox"]{accent-color:var(--blue)}
.pbg-preview{margin:10px 0;text-align:center}
.pbg-preview canvas{border:1px solid var(--border);border-radius:4px;image-rendering:pixelated;background:#0a0e14;max-width:100%}
.pbg-btns{display:flex;justify-content:flex-end;gap:8px;margin-top:14px}
.pbg-btns button{padding:6px 16px;font-size:12px;border-radius:4px}
.pbg-btns button.primary{background:var(--blue);border-color:var(--blue);color:#fff;font-weight:600}
.pbg-btns button.primary:hover{filter:brightness(1.15)}
/* â”€â”€ Main layout â”€â”€ */
#main{display:flex;flex:1;overflow:hidden}

/* â”€â”€ Left: Palette â”€â”€ */
#palette-panel{width:320px;min-width:180px;max-width:700px;flex-shrink:0;background:var(--panel);border-right:1px solid var(--border);display:flex;flex-direction:column;overflow:hidden;position:relative}
#pal-header{display:flex;align-items:center;justify-content:space-between;padding:8px 12px 6px;border-bottom:1px solid var(--border);flex-shrink:0}
#pal-header h2{font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:.08em;color:var(--text-dim)}
#pal-header button{font-size:10px;padding:2px 8px}
#palette-cats{display:flex;flex-wrap:wrap;gap:3px;padding:7px 8px;border-bottom:1px solid var(--border);flex-shrink:0;overflow-x:hidden}
.cat-btn{padding:3px 8px;font-size:11px;border-radius:3px}
.cat-btn.active{background:#0b2a4a;border-color:var(--blue);color:var(--blue)}
#palette-sheets{flex:1;overflow-y:auto;overflow-x:auto;padding:8px}
.sheet-block{margin-bottom:12px;display:inline-block;min-width:100%;vertical-align:top}
.sheet-name{font-size:10px;color:var(--text-dim);margin-bottom:4px;padding:2px 4px;background:var(--bg);border-radius:3px;display:flex;align-items:center;justify-content:space-between}
.sheet-name span{max-width:200px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.sheet-canvas-wrap{position:relative;cursor:crosshair;display:block;border:1px solid var(--border)}
.sheet-canvas-wrap:hover{border-color:var(--border2)}
canvas.palette-canvas{display:block;image-rendering:pixelated}
.stamp-highlight{position:absolute;border:2px solid var(--gold);pointer-events:none;background:rgba(230,168,23,0.15)}
#pal-resizer{position:absolute;right:0;top:0;width:5px;height:100%;cursor:col-resize;z-index:10;background:transparent}
#pal-resizer:hover,#pal-resizer.dragging{background:var(--blue);opacity:.4}

/* â”€â”€ Center: Canvas â”€â”€ */
#canvas-area{flex:1;display:flex;flex-direction:column;overflow:hidden;background:#060a0f}
#canvas-toolbar{display:flex;align-items:center;gap:8px;padding:6px 10px;background:var(--panel);border-bottom:1px solid var(--border);flex-shrink:0;flex-wrap:wrap}
.tool-btn{min-width:32px;padding:4px 8px;font-size:12px}
#layer-btns .tool-btn.active{background:#0e2a17;border-color:var(--green);color:var(--green)}
#canvas-wrap{flex:1;position:relative;overflow:hidden}
#build-canvas{position:absolute;image-rendering:pixelated;cursor:crosshair}
.zoom-badge{font-size:11px;color:var(--text-dim);font-family:monospace;min-width:42px;text-align:center}

/* â”€â”€ Right: Properties â”€â”€ */
#props-panel{width:270px;flex-shrink:0;background:var(--panel);border-left:1px solid var(--border);display:flex;flex-direction:column;overflow-y:auto;overflow-x:hidden}
.rp-section{padding:10px 12px;border-bottom:1px solid var(--border)}
.rp-section h3{font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:.08em;color:var(--text-dim);margin-bottom:8px}
.field-row{display:flex;align-items:center;gap:6px;margin-bottom:6px}
.field-row label{font-size:11px;color:var(--text-dim);min-width:58px}
.field-row input,.field-row select{flex:1}

/* â”€â”€ Catalog Modal â”€â”€ */
.catalog-overlay{position:fixed;inset:0;background:rgba(0,0,0,.55);z-index:10000;display:flex;align-items:center;justify-content:center;animation:pbg-fadein .15s}
.catalog-modal{background:var(--panel);border:1px solid var(--border);border-radius:8px;box-shadow:0 8px 32px rgba(0,0,0,.6);animation:pbg-scalein .15s;width:980px;max-width:96vw;max-height:84vh;display:flex;flex-direction:column;overflow:hidden}
.catalog-header{display:flex;align-items:center;justify-content:space-between;padding:14px 18px 10px;border-bottom:1px solid var(--border)}
.catalog-header h3{font-size:15px;font-weight:700;color:var(--gold);margin:0}
.catalog-header .cat-close{background:none;border:none;color:var(--text-dim);font-size:18px;cursor:pointer;padding:2px 6px;border-radius:4px}
.catalog-header .cat-close:hover{color:var(--text);background:var(--hover)}
.catalog-tabs{display:flex;gap:0;border-bottom:1px solid var(--border);flex-shrink:0}
.catalog-tabs button{flex:1;padding:8px 12px;font-size:12px;font-weight:600;background:none;border:none;border-bottom:2px solid transparent;color:var(--text-dim);cursor:pointer;transition:all .12s}
.catalog-tabs button:hover{color:var(--text);background:var(--hover)}
.catalog-tabs button.active{color:var(--gold);border-bottom-color:var(--gold)}
.catalog-body{flex:1;overflow-y:auto;padding:12px 16px}
.catalog-list{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:8px;align-content:start}
.catalog-footer{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:9px 12px;border-top:1px solid var(--border);background:var(--bg)}
.catalog-page-info{font-size:11px;color:var(--text-dim);white-space:nowrap}
.catalog-pager{display:flex;align-items:center;gap:6px}
.catalog-pager button{font-size:11px;padding:4px 10px;min-width:72px}
.catalog-empty{color:var(--text-dim);font-size:12px;font-style:italic;padding:20px 0;text-align:center}
.catalog-empty{grid-column:1 / -1}
.item-card{background:var(--bg);border:1px solid var(--border);border-radius:4px;padding:7px 9px;margin-bottom:5px}
.item-card .item-title{font-size:12px;font-weight:600;color:var(--gold);margin-bottom:3px}
.item-card .item-meta{font-size:10px;color:var(--text-dim);margin-bottom:5px}
.item-card .item-acts{display:flex;gap:4px}
.item-card .item-acts button{flex:1;padding:2px 0;font-size:10px}
.item-card.object-card,.item-card.building-card{display:flex;align-items:center;gap:10px;padding:10px;border-radius:6px;transition:border-color .12s,transform .12s,box-shadow .12s}
.item-card.object-card:hover,.item-card.building-card:hover{border-color:var(--border2);box-shadow:0 4px 14px rgba(0,0,0,.35);transform:translateY(-1px)}
.obj-thumb-wrap{width:72px;height:72px;flex-shrink:0;display:flex;align-items:center;justify-content:center;background:#0a0e14;border:1px solid var(--border2);border-radius:6px;overflow:hidden}
.obj-thumb{width:64px;height:64px;image-rendering:pixelated;display:block}
.item-main{min-width:0;flex:1}
.item-main .item-meta{line-height:1.4;word-break:break-word;margin-bottom:7px}
#stamp-preview{display:flex;align-items:center;gap:8px;min-height:40px;padding:8px 12px;border-bottom:1px solid var(--border);background:var(--bg)}
#stamp-preview canvas{border:1px solid var(--border2);image-rendering:pixelated;max-width:96px;max-height:96px}
#stamp-preview .stamp-info{font-size:11px;color:var(--text-dim);line-height:1.5}

/* â”€â”€ Terrain multiselect â”€â”€ */
.terrain-ms{position:relative;flex:1}
.terrain-ms-toggle{width:100%;padding:3px 6px;font-size:11px;background:var(--bg);border:1px solid var(--border);color:var(--text);border-radius:3px;cursor:pointer;text-align:left;min-height:24px;display:flex;align-items:center;gap:4px;flex-wrap:wrap}
.terrain-ms-toggle .placeholder{color:var(--text-dim)}
.terrain-ms-tag{background:rgba(245,197,66,0.15);color:var(--gold);border:1px solid rgba(245,197,66,0.3);border-radius:3px;padding:1px 5px;font-size:10px;display:inline-flex;align-items:center;gap:2px;white-space:nowrap}
.terrain-ms-tag .tag-x{cursor:pointer;opacity:.6;font-size:9px}
.terrain-ms-tag .tag-x:hover{opacity:1}
.terrain-ms-drop{display:none;position:absolute;top:100%;left:0;right:0;max-height:260px;overflow-y:auto;background:var(--panel);border:1px solid var(--border);border-radius:0 0 4px 4px;z-index:999;box-shadow:0 8px 24px rgba(0,0,0,.5)}
.terrain-ms-drop.open{display:block}
.terrain-ms-drop input[type=text]{width:100%;padding:5px 8px;font-size:11px;border:none;border-bottom:1px solid var(--border);background:var(--bg);color:var(--text);box-sizing:border-box}
.tms-group{padding:2px 0}
.tms-group-label{font-size:9px;text-transform:uppercase;letter-spacing:.06em;color:var(--text-dim);padding:4px 8px 2px;font-weight:600}
.tms-opt{display:flex;align-items:center;gap:6px;padding:3px 8px;cursor:pointer;font-size:11px;color:var(--text)}
.tms-opt:hover{background:rgba(245,197,66,0.08)}
.tms-opt input[type=checkbox]{margin:0;accent-color:var(--gold)}
.tms-opt.hidden{display:none}

/* â”€â”€ Resource row â”€â”€ */
.res-row{display:flex;align-items:center;gap:4px;flex:1}
.res-row select{flex:1;min-width:0}
.res-row input{width:50px}

/* â”€â”€ Terrain Brush UI â”€â”€ */
.tset-panel{border-top:1px solid var(--border);overflow-y:auto;flex:1}
.tset-panel h3{font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:.08em;color:var(--text-dim);margin-bottom:6px}
.tset-card{background:var(--bg);border:1px solid var(--border);border-radius:4px;margin-bottom:4px;overflow:hidden}
.tset-card.selected{border-color:var(--blue)}
.tset-hdr{display:flex;align-items:center;gap:5px;padding:4px 7px;cursor:pointer}
.tset-badge{font-size:9px;padding:1px 5px;border-radius:8px;font-weight:600;text-transform:uppercase}
.tset-badge.corner{background:#0e2a17;color:var(--green);border:1px solid var(--green)}
.tset-badge.edge{background:#2a1f00;color:var(--gold);border:1px solid var(--gold)}
.tset-badge.mixed{background:#1e0f3a;color:#a371f7;border:1px solid #a371f7}
.tset-name{flex:1;font-size:11px;font-weight:500;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.tr-row{display:flex;align-items:center;gap:5px;padding:2px 7px 2px 14px;cursor:pointer;font-size:11px;border-radius:3px;margin:1px 3px}
.tr-row:hover{background:var(--hover)}
.tr-row.selected{background:#14263d;outline:1px solid var(--blue)}
.tr-swatch{width:12px;height:12px;border-radius:3px;flex-shrink:0;border:1px solid rgba(255,255,255,.12)}
.tr-label{flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.tset-props-row{display:flex;align-items:center;gap:5px;margin:3px 0;font-size:11px}
.tset-props-row label{width:52px;color:var(--text-dim);flex-shrink:0}
.tset-props-row input,.tset-props-row select{flex:1;min-width:0}
input[type="color"].tset-color{padding:1px;width:24px;height:20px;cursor:pointer;background:none;border:1px solid var(--border2);border-radius:3px}

/* â”€â”€ Terrain set creation popup â”€â”€ */
.tbrush-popup{position:fixed;z-index:9999;background:var(--panel);border:1px solid var(--border2);border-radius:6px;padding:12px;box-shadow:0 8px 32px rgba(0,0,0,.6);min-width:240px;max-width:300px}
.tbrush-popup h4{font-size:11px;color:var(--gold);text-transform:uppercase;letter-spacing:.06em;margin-bottom:8px;font-weight:700}
.tbrush-popup .tp-row{display:flex;gap:4px;margin-bottom:6px;align-items:center}
.tbrush-popup .tp-row label{font-size:11px;color:var(--text-dim);min-width:40px}
.tbrush-popup .tp-row input{flex:1;font-size:11px}
.tbrush-popup .tp-types{display:flex;gap:4px;margin-bottom:8px}
.tbrush-popup .tp-type-btn{flex:1;padding:6px 4px;font-size:11px;font-weight:600;text-align:center;border-radius:4px;cursor:pointer}
.tbrush-popup .tp-footer{display:flex;gap:4px;justify-content:flex-end;margin-top:8px}

/* â”€â”€ Palette terrain overlay â”€â”€ */
canvas.pal-terrain-overlay{position:absolute;top:0;left:0;pointer-events:none;image-rendering:pixelated}

/* â”€â”€ Pattern assignment grid â”€â”€ */
.pat-grid{display:grid;gap:2px;margin-top:6px;max-height:200px;overflow-y:auto}
.pat-cell{width:100%;aspect-ratio:1;border:1px solid var(--border);border-radius:2px;background:var(--bg);cursor:pointer;position:relative;overflow:hidden}
.pat-cell:hover{border-color:var(--blue)}
.pat-cell.assigned{border-color:rgba(63,185,80,.5)}
.pat-cell.sel-pat{border-color:var(--gold);border-width:2px;box-shadow:0 0 4px rgba(230,168,23,.3)}
.pat-cell canvas{display:block;width:100%;height:100%;image-rendering:pixelated}
.pat-cell .pat-idx{position:absolute;bottom:0;right:0;font-size:7px;color:var(--text-dim);background:rgba(0,0,0,.65);padding:0 2px;line-height:1.3}

::-webkit-scrollbar{width:6px;height:6px}
::-webkit-scrollbar-track{background:transparent}
::-webkit-scrollbar-thumb{background:#30363d;border-radius:3px}
</style>
</head>
<body>

<!-- â”€â”€ Toolbar â”€â”€ -->
<div id="toolbar">
  <h1>ğŸ¨ Sprite Editor</h1>
  <div class="tb-sep"></div>

  <div class="tb-group" id="mode-btns">
    <button class="mode-tab active" id="mode-building" onclick="setEditorMode('building')">ğŸ›ï¸ Building</button>
    <button class="mode-tab"        id="mode-object"   onclick="setEditorMode('object')">ğŸŒ³ Object</button>
  </div>

  <div class="tb-sep"></div>

  <div class="tb-group">
    <label class="tb-lbl">Grid</label>
    <input type="number" id="grid-w" value="12" min="1" max="64" title="Width in tiles">
    <label class="tb-lbl">Ã—</label>
    <input type="number" id="grid-h" value="12" min="1" max="64" title="Height in tiles">
    <button onclick="resizeGrid()">Resize</button>
    <button onclick="autofitGrid()" title="Shrink grid to fit painted tiles (Shift+F)">âœ‚ Autofit</button>
  </div>

  <div class="tb-sep"></div>

  <div class="tb-group" id="tool-btns">
    <label class="tb-lbl">Tool</label>
    <button class="tool-btn active" id="tool-paint"   onclick="setTool('paint')"   title="Paint tile (P)">ğŸ–Œ Paint</button>
    <button class="tool-btn"        id="tool-select"  onclick="setTool('select')"  title="Select &amp; move tiles (S)">â¬œ Select</button>
    <button class="tool-btn"        id="tool-erase"   onclick="setTool('erase')"   title="Erase (E)">ğŸ—‘ Erase</button>
    <button class="tool-btn"        id="tool-fill"    onclick="setTool('fill')"    title="Flood-fill with stamp (F)">ğŸª£ Fill</button>
    <button class="tool-btn"        id="tool-eyedrop" onclick="setTool('eyedrop')" title="Pick tile from canvas (I)">ğŸ’‰ Pick</button>
    <button class="tool-btn"        id="tool-impass"  onclick="setTool('impass')"  title="Toggle impassable (X)">â›” Block</button>
    <button class="tool-btn"        id="tool-marker"  onclick="setTool('marker')"  title="Toggle marker (D/N)">ğŸšª Door</button>
    <button class="tool-btn"        id="tool-origin"  onclick="setTool('origin')"  title="Set spawn origin â€” the tile that becomes (0,0) when placed in-game (O)">ğŸ“Œ Origin</button>
    <button class="tool-btn"        id="tool-tbrush"  onclick="setTool('tbrush')" title="Terrain Brush â€” auto-tile using terrain sets (T)">ğŸ” Terrain</button>
  </div>

  <div class="tb-sep"></div>

  <div class="tb-group">
    <button onclick="newItem()">ï¼‹ New</button>
    <button onclick="showProcgenModal()" id="btn-procgen" class="gold" title="Procedurally generate a building">ğŸ—ï¸ Generate</button>
    <button onclick="saveItem()" class="green">ğŸ’¾ Save</button>
    <button onclick="openCatalog()" title="Browse saved buildings &amp; objects">ğŸ“‹ Catalog</button>
  </div>
</div>

<!-- â”€â”€ Main â”€â”€ -->
<div id="main">

  <!-- Palette -->
  <div id="palette-panel">
    <div id="pal-resizer"></div>
    <div id="pal-header">
      <h2><span class="collapse-chevron" onclick="togglePalette()" title="Collapse/Expand palette">â–¾</span>Palette</h2>
      <button onclick="loadCustomSheet()" title="Load a custom PNG spritesheet">ğŸ“‚ Add Sheet</button>
    </div>
    <div id="palette-cats"></div>
    <div id="palette-sheets"><div style="color:var(--text-dim);font-size:12px;padding:10px">Select a category above</div></div>

    <!-- 9-Tile Brushes panel (building mode) -->
    <div id="n9b-panel" class="n9b-panel rp-section" style="display:none">
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px">
        <h3><span class="collapse-chevron" onclick="toggleSection('n9b-panel')" title="Collapse/Expand">â–¾</span>ğŸ§± 9-Tile Brushes</h3>
        <div style="display:flex;gap:3px">
          <button onclick="n9b_add()" style="font-size:10px;padding:1px 6px" class="green">ï¼‹ New</button>
        </div>
      </div>
      <div id="n9b-list" style="max-height:160px;overflow-y:auto"></div>
      <div id="n9b-props" style="display:none;margin-top:6px;padding-top:6px;border-top:1px solid var(--border)">
        <div class="tset-props-row"><label>Name</label><input type="text" id="n9b-name" onchange="n9b_onNameChange()" style="font-size:11px"></div>
        <div style="margin-top:4px;font-size:10px;color:var(--text-dim);text-transform:uppercase;font-weight:600;margin-bottom:2px">Cost per tile</div>
        <div style="display:flex;gap:4px;flex-wrap:wrap;margin-bottom:4px">
          <div class="tset-props-row" style="flex:1;min-width:60px"><label style="font-size:10px">Gold</label><input type="number" id="n9b-cost-gold" value="0" min="0" max="9999" onchange="n9b_onCostChange()" style="font-size:11px;width:50px"></div>
                    <div id="n9b-cost-resource-rows" style="display:flex;gap:4px;flex-wrap:wrap;flex:1"></div>
        </div>
        <div style="display:flex;gap:3px;margin-top:4px">
          <button onclick="n9b_remove()" style="font-size:10px;padding:1px 6px" class="danger">âœ• Delete</button>
          <button onclick="n9b_autoFromSelection()" style="font-size:10px;padding:1px 6px" class="gold" title="Select a 3Ã—3 region in the palette, then click this to assign all 9 tiles">âš¡ From Selection</button>
        </div>
        <div style="margin-top:6px;font-size:10px;color:var(--text-dim)">
          Click a slot below, then click a palette tile to assign it.
        </div>
        <div id="n9b-grid" class="n9b-grid"></div>
      </div>
    </div>

    <!-- Door Catalog panel (building mode) -->
    <div id="dcat-panel" class="dcat-panel rp-section" style="display:none">
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px">
        <h3><span class="collapse-chevron" onclick="toggleSection('dcat-panel')" title="Collapse/Expand">â–¾</span>ğŸšª Door Catalog</h3>
        <div style="display:flex;gap:3px">
          <button onclick="dcat_add()" style="font-size:10px;padding:1px 6px" class="green">ï¼‹ New</button>
        </div>
      </div>
      <div id="dcat-list" class="dcat-list"></div>
      <div id="dcat-props" style="display:none;margin-top:6px;padding-top:6px;border-top:1px solid var(--border)">
        <div class="tset-props-row"><label>Name</label><input type="text" id="dcat-name" onchange="dcat_onNameChange()" style="font-size:11px"></div>
        <div style="display:flex;gap:3px;margin-top:4px;flex-wrap:wrap">
          <button onclick="dcat_remove()" style="font-size:10px;padding:1px 6px" class="danger">âœ• Delete</button>
          <button onclick="dcat_pickDoor()" style="font-size:10px;padding:1px 6px" id="dcat-pick-door-btn" class="gold" title="Pick the door panel (1Ã—2) from palette">ğŸšª Pick Door</button>
          <button onclick="dcat_pickFrame()" style="font-size:10px;padding:1px 6px" id="dcat-pick-frame-btn" class="blue" title="Pick the door frame (1Ã—2) from palette">ğŸ–¼ Pick Frame</button>
        </div>
        <div id="dcat-pick-hint" style="margin-top:4px;font-size:10px;color:var(--green);display:none"></div>
        <div style="margin-top:6px;display:flex;gap:8px">
          <div><label style="font-size:10px;color:var(--text-dim)">Frame (3Ã—2)</label>
            <canvas id="dcat-preview-frame" width="96" height="64" style="display:block;margin-top:4px;image-rendering:pixelated;border:1px solid var(--border);border-radius:3px;background:#0a0e14"></canvas></div>
          <div><label style="font-size:10px;color:var(--text-dim)">Door (1Ã—2)</label>
            <canvas id="dcat-preview-door" width="32" height="64" style="display:block;margin-top:4px;image-rendering:pixelated;border:1px solid var(--border);border-radius:3px;background:#0a0e14"></canvas></div>
          <div><label style="font-size:10px;color:var(--text-dim)">Combined</label>
            <canvas id="dcat-preview" width="96" height="64" style="display:block;margin-top:4px;image-rendering:pixelated;border:1px solid var(--border);border-radius:3px;background:#0a0e14"></canvas></div>
        </div>
      </div>
    </div>

    <!-- Window Catalog panel (building mode) -->
    <div id="wcat-panel" class="wcat-panel rp-section" style="display:none">
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px">
        <h3><span class="collapse-chevron" onclick="toggleSection('wcat-panel')" title="Collapse/Expand">â–¾</span>ğŸªŸ Window Catalog</h3>
        <div style="display:flex;gap:3px">
          <button onclick="wcat_add()" style="font-size:10px;padding:1px 6px" class="green">ï¼‹ New</button>
        </div>
      </div>
      <div id="wcat-list" class="wcat-list"></div>
      <div id="wcat-props" style="display:none;margin-top:6px;padding-top:6px;border-top:1px solid var(--border)">
        <div class="tset-props-row"><label>Name</label><input type="text" id="wcat-name" onchange="wcat_onNameChange()" style="font-size:11px"></div>
        <div style="display:flex;gap:3px;margin-top:4px">
          <button onclick="wcat_remove()" style="font-size:10px;padding:1px 6px" class="danger">âœ• Delete</button>
          <button onclick="wcat_pick()" style="font-size:10px;padding:1px 6px" class="gold" id="wcat-pick-btn" title="Click this, then click a tile in the palette to assign it">ğŸ¯ Pick from Palette</button>
        </div>
        <div id="wcat-pick-hint" style="margin-top:4px;font-size:10px;color:var(--green);display:none">
          â¬… Click a tile in the palette to assign it as this window.
        </div>
        <div style="margin-top:6px">
          <label style="font-size:10px;color:var(--text-dim)">Preview</label>
          <canvas id="wcat-preview" width="64" height="64" style="display:block;margin-top:4px;image-rendering:pixelated;border:1px solid var(--border);border-radius:3px;background:#0a0e14"></canvas>
        </div>
      </div>
    </div>
  </div>

  <!-- Canvas -->
  <div id="canvas-area">
    <div id="canvas-toolbar">
      <div class="tb-group" id="layer-section">
        <div class="tb-group" id="layer-btns">
          <label class="tb-lbl">Layer</label>
          <button class="tool-btn active" id="layer-floor"   onclick="setLayer('floor')">Floor</button>
          <button class="tool-btn"        id="layer-walls"   onclick="setLayer('walls')">Walls</button>
          <button class="tool-btn"        id="layer-roof"    onclick="setLayer('roof')">Roof</button>
          <button class="tool-btn"        id="layer-overlay" onclick="setLayer('overlay')">Overlay</button>
        </div>
        <div class="tb-sep"></div>
        <div class="tb-group">
          <label class="tb-lbl">Visibility</label>
          <button class="tool-btn active" id="vis-floor"   onclick="toggleVis('floor')">Floor</button>
          <button class="tool-btn active" id="vis-walls"   onclick="toggleVis('walls')">Walls</button>
          <button class="tool-btn active" id="vis-roof"    onclick="toggleVis('roof')">Roof</button>
          <button class="tool-btn active" id="vis-overlay" onclick="toggleVis('overlay')">Overlay</button>
        </div>
        <div class="tb-sep"></div>
        <button onclick="clearLayer()" title="Clear current layer">Clear Layer</button>
        <div class="tb-sep"></div>
      </div>
      <div class="tb-group">
        <label class="tb-lbl">Zoom</label>
        <button onclick="zoomCanvas(-1)">âˆ’</button>
        <span class="zoom-badge" id="zoom-badge">100%</span>
        <button onclick="zoomCanvas(1)">+</button>
        <button onclick="fitCanvas()">Fit</button>
      </div>
      <div class="tb-sep"></div>
      <div class="tb-group">
        <label class="tb-lbl">Rotate</label>
        <button class="tool-btn" onclick="rotateStampOrSelection(-1)" title="Rotate 90Â° counter-clockwise (Shift+R)">â†º CCW</button>
        <button class="tool-btn" onclick="rotateStampOrSelection(1)"  title="Rotate 90Â° clockwise (R)">â†» CW</button>
      </div>
      <div class="tb-sep"></div>
      <div class="tb-group">
        <button onclick="clearAll()" class="danger" title="Wipe everything on canvas">Clear All</button>
      </div>
    </div>
    <div id="canvas-wrap">
      <canvas id="build-canvas"></canvas>
    </div>
  </div>

  <!-- Properties -->
  <div id="props-panel">
    <div id="stamp-preview">
      <canvas id="stamp-canvas" width="96" height="96"></canvas>
      <div class="stamp-info" id="stamp-info">No stamp selected<br>Click a tile in the palette</div>
    </div>

    <!-- Terrain Sets panel (visible when terrain brush is active) -->
    <div id="tbrush-panel" class="tset-panel rp-section" style="display:none">
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px">
        <h3>ğŸ” Terrain Sets</h3>
        <div style="display:flex;gap:3px">
          <button onclick="tbrush_addSet()" style="font-size:10px;padding:1px 6px" class="green">ï¼‹ Set</button>
          <button onclick="tbrush_autoAssign()" style="font-size:10px;padding:1px 6px" class="gold" title="Auto-assign LPC terrain patterns">âš¡ Auto</button>
        </div>
      </div>
      <div id="tbrush-sets" style="max-height:240px;overflow-y:auto"></div>
      <div id="tbrush-props" style="display:none;margin-top:6px;padding-top:6px;border-top:1px solid var(--border)">
        <div class="tset-props-row"><label>Set Name</label><input type="text" id="tbs-name" onchange="tbrush_onSetPropChange()" style="font-size:11px"></div>
        <div class="tset-props-row"><label>Type</label><select id="tbs-type" onchange="tbrush_onSetPropChange()" style="font-size:11px"><option value="corner">Corner</option><option value="edge">Edge</option><option value="mixed">Mixed</option></select></div>
        <div style="display:flex;gap:3px;margin-top:4px">
          <button onclick="tbrush_addTerrain()" style="font-size:10px;padding:1px 6px;flex:1" class="green">ï¼‹ Terrain</button>
          <button onclick="tbrush_removeTerrain()" style="font-size:10px;padding:1px 6px" class="danger" id="tbs-rm-terrain" disabled>âœ• Terrain</button>
          <button onclick="tbrush_removeSet()" style="font-size:10px;padding:1px 6px" class="danger">âœ• Set</button>
        </div>
        <div id="tbrush-terrain-props" style="display:none;margin-top:4px;padding-top:4px;border-top:1px solid var(--border)">
          <div class="tset-props-row"><label>Name</label><input type="text" id="tbt-name" onchange="tbrush_onTerrainPropChange()" style="font-size:11px"></div>
          <div class="tset-props-row"><label>Color</label><input type="color" id="tbt-color" class="tset-color" onchange="tbrush_onTerrainPropChange()"></div>
        </div>
        <div style="margin-top:4px;font-size:10px;color:var(--text-dim)">
          <strong>Quick start:</strong> Select tiles in the palette â†’ choose set type. Or click a pattern below then click a palette tile to assign it.
        </div>
        <div id="tbrush-pat-info" style="margin-top:3px;font-size:10px;color:var(--text-dim)"></div>
        <div id="tbrush-pat-grid" class="pat-grid"></div>
      </div>
    </div>

    <!-- Building Properties -->
    <div id="bld-props" class="rp-section">
      <h3>Building Properties</h3>
      <div class="field-row"><label>Name</label>
        <input type="text" id="bld-name" placeholder="e.g. stone_inn"></div>
      <div class="field-row"><label>Type</label>
        <select id="bld-type">
          <option value="house">ğŸ  House</option>
          <option value="tavern">ğŸº Tavern</option>
          <option value="blacksmith">âš’ï¸ Blacksmith</option>
          <option value="church">â›ª Church</option>
          <option value="market">ğŸ›’ Market</option>
          <option value="barracks">âš”ï¸ Barracks</option>
          <option value="warehouse">ğŸ“¦ Warehouse</option>
          <option value="farm">ğŸŒ¾ Farm</option>
          <option value="castle">ğŸ° Castle</option>
          <option value="tower">ğŸ—¼ Tower</option>
          <option value="decoration">âœ¨ Decoration</option>
          <option value="other">ğŸ“Œ Other</option>
        </select></div>
      <div class="field-row"><label>Tags</label>
        <input type="text" id="bld-tags" placeholder="indoor, nocturnalâ€¦"></div>
    </div>

    <!-- Object Properties -->
    <div id="obj-props" class="rp-section" style="display:none">
      <h3>Object Properties</h3>
      <div class="field-row"><label>Name</label>
        <input type="text" id="obj-name" placeholder="e.g. oak_tree"></div>
      <div class="field-row"><label>Type</label>
        <select id="obj-type">
          <option value="tree">ğŸŒ³ Tree</option>
          <option value="rock">ğŸª¨ Rock</option>
          <option value="plant">ğŸŒ¿ Plant</option>
          <option value="decoration">âœ¨ Decoration</option>
          <option value="furniture">ğŸª‘ Furniture</option>
          <option value="building">ğŸ  Building</option>
          <option value="other">ğŸ“Œ Other</option>
        </select></div>
      <div class="field-row"><label>Interact Anim</label>
        <select id="obj-animation">
          <option value="none">â€” None</option>
          <option value="combat_1h_slash">âš”ï¸ Chop / Slash</option>
          <option value="combat_1h_halfslash">ğŸª“ Half Swing</option>
          <option value="legacy_swing">â›ï¸ Swing (Mine/Dig)</option>
          <option value="sitting">ğŸª‘ Sit</option>
          <option value="idle">ğŸ§ Idle / Inspect</option>
          <option value="emotes">ğŸ™ Emote / Pray</option>
          <option value="climb">ğŸ§— Climb</option>
        </select></div>
      <div class="field-row"><label>Terrain</label>
        <div class="terrain-ms" id="terrain-ms">
          <div class="terrain-ms-toggle" id="tms-toggle" onclick="toggleTerrainDropdown()">
            <span class="placeholder">Click to select terrainsâ€¦</span>
          </div>
          <div class="terrain-ms-drop" id="tms-drop">
            <input type="text" id="tms-search" placeholder="Filter terrainsâ€¦" oninput="filterTerrainOptions()">
            <div id="tms-options"></div>
          </div>
        </div>
      </div>
      <div class="field-row"><label>Resource</label>
        <div class="res-row">
          <select id="obj-resource">
            <option value="">â€” None</option>
          </select>
          <input type="number" id="obj-resource-amount" value="1" min="1" max="99" step="1" title="Amount per harvest">
        </div>
      </div>
      <div class="field-row"><label>Weight</label>
        <input type="number" id="obj-weight" value="1" min="0" step="0.1" style="width:60px" title="Relative spawn probability"></div>
      <div class="field-row"><label>Resistance</label>
        <input type="number" id="obj-resistance" value="0" min="0" max="95" step="5" style="width:55px" title="Damage resistance 0â€“95. 0=normal, 50=twice as tough, 90=very hard rock"></div>
      <div class="field-row"><label>Spawn After</label>
        <input type="text" id="obj-spawn-after" placeholder="e.g. stump_1" style="width:130px" title="Object ID to spawn at the origin tile after this object is collected / destroyed"></div>
      <div class="field-row" style="flex-direction:column;align-items:flex-start;gap:4px">
        <label>Required Techs <span style="font-size:10px;color:var(--text-dim)">(technologies needed to build/use this object)</span></label>
        <div id="obj-req-techs-tags" style="display:flex;flex-wrap:wrap;gap:4px;min-height:24px;padding:4px;background:#0d1117;border:1px solid var(--border2);border-radius:4px;width:100%;cursor:pointer" onclick="openObjTechPicker()"></div>
        <div style="font-size:10px;color:var(--text-dim);line-height:1.4">Click to select which researched technologies are required before this object can be built.</div>
      </div>
      <div class="field-row" style="flex-direction:column;align-items:flex-start;gap:4px">
        <label>Health States <span style="font-size:10px;color:var(--text-dim)">(visual damage stages â€” optional)</span></label>
        <div id="health-states-list" style="width:100%"></div>
        <div style="display:flex;gap:4px;align-items:center;flex-wrap:wrap;margin-top:2px">
          <input type="text" id="hs-label" placeholder="Damaged" style="width:70px" title="Label for this health state">
          <input type="number" id="hs-min-hp" value="50" min="0" max="99" step="1" style="width:44px" title="Min health % at which this visual appears">
          <span style="font-size:10px;color:var(--text-dim)">% min</span>
          <button onclick="addHealthStateFromCanvas()" style="font-size:11px;padding:2px 8px" title="Capture the current canvas tiles as tiles for this health state">+ Capture</button>
        </div>
        <div style="font-size:10px;color:var(--text-dim);line-height:1.4">Paint a damage stage on the canvas, then capture it as a health state.</div>
      </div>
      <div class="field-row" style="flex-direction:column;align-items:flex-start;gap:4px">
        <label>Season Variants <span style="font-size:10px;color:var(--text-dim)">(different look per season â€” optional)</span></label>
        <div id="season-variants-list" style="width:100%"></div>
        <div style="display:flex;gap:4px;align-items:center;flex-wrap:wrap;margin-top:2px">
          <select id="sv-season" style="font-size:11px">
            <option value="spring">ğŸŒ¸ Spring</option>
            <option value="summer">â˜€ï¸ Summer</option>
            <option value="autumn">ğŸ‚ Autumn</option>
            <option value="winter">â„ï¸ Winter</option>
          </select>
          <button onclick="captureSeasonVariant()" style="font-size:11px;padding:2px 8px" title="Capture current canvas as this season's appearance">+ Capture</button>
        </div>
        <div style="font-size:10px;color:var(--text-dim);line-height:1.4">Paint that season's look on the canvas, then capture it. Seasons not captured fall back to the default tiles.</div>
      </div>
      <div class="field-row" style="flex-direction:column;align-items:flex-start;gap:4px">
        <label>Growth Stages <span style="font-size:10px;color:var(--text-dim)">(morph over time â€” optional)</span></label>
        <div id="growth-states-list" style="width:100%"></div>
        <div style="display:flex;gap:4px;align-items:center;flex-wrap:wrap;margin-top:2px">
          <input type="text" id="gs-label" placeholder="Mature" style="width:70px" title="Label for this growth stage">
          <input type="number" id="gs-days" value="7" min="0" max="9999" step="1" style="width:52px" title="Days from planting to reach this stage">
          <span style="font-size:10px;color:var(--text-dim)">days</span>
          <button onclick="addGrowthStateFromCanvas()" style="font-size:11px;padding:2px 8px" title="Capture current canvas as this growth stage">+ Capture</button>
        </div>
        <div style="font-size:10px;color:var(--text-dim);line-height:1.4">Paint a growth stage, capture it. Stage at day 0 = initial look. Stages are sorted by day automatically.</div>
      </div>
      <div class="field-row" style="flex-direction:column;align-items:flex-start;gap:4px">
        <label>Rotation Variants <span style="font-size:10px;color:var(--text-dim)">(different look per facing â€” optional)</span></label>
        <div id="rotation-variants-list" style="width:100%"></div>
        <div style="display:flex;gap:4px;align-items:center;flex-wrap:wrap;margin-top:2px">
          <input type="text" id="rv-label" placeholder="e.g. Facing East" style="width:100px" title="Label for this rotation variant">
          <button onclick="addRotationVariantFromCanvas()" style="font-size:11px;padding:2px 8px" title="Capture current canvas as a rotation variant">+ Capture</button>
        </div>
        <div style="font-size:10px;color:var(--text-dim);line-height:1.4">Paint each rotation, then capture it. Default tiles are the base look. Press R in-game to cycle variants.</div>
      </div>
      <div class="field-row" style="flex-direction:column;align-items:flex-start;gap:4px">
        <label>Color Variants <span style="font-size:10px;color:var(--text-dim)">(visual alternatives â€” press T to cycle)</span></label>
        <div id="color-variants-list" style="width:100%"></div>
        <div style="display:flex;gap:4px;align-items:center;flex-wrap:wrap;margin-top:2px">
          <input type="text" id="cv-label" placeholder="e.g. Red" style="width:100px" title="Label for this color variant">
          <button onclick="addColorVariantFromCanvas()" style="font-size:11px;padding:2px 8px" title="Capture current tiles + rotations + seasons as a color variant">+ Capture</button>
        </div>
        <div style="font-size:10px;color:var(--text-dim);line-height:1.4">Create the object with its rotations &amp; seasons, then capture as a color variant. Each variant is a complete alternative look. Press T to cycle.</div>
      </div>
    </div>

  </div>

</div>

<!-- Catalog Modal -->
<div id="catalog-overlay" class="catalog-overlay" style="display:none" onclick="if(event.target===this)closeCatalog()">
  <div class="catalog-modal">
    <div class="catalog-header">
      <h3>ğŸ“‹ Catalog</h3>
      <button class="cat-close" onclick="closeCatalog()" title="Close">âœ•</button>
    </div>
    <div class="catalog-tabs">
      <button id="cat-tab-bld" class="active" onclick="setCatalogTab('building')">ğŸ  Buildings (<span id="cat-bld-count">0</span>)</button>
      <button id="cat-tab-obj" onclick="setCatalogTab('object')">ğŸŒ³ Objects (<span id="cat-obj-count">0</span>)</button>
    </div>
    <div class="catalog-body">
            <div id="cat-bld-cards" class="catalog-list">No buildings saved yet</div>
            <div id="cat-obj-cards" class="catalog-list" style="display:none">No objects saved yet</div>
    </div>
        <div class="catalog-footer">
            <div id="cat-page-info" class="catalog-page-info">0 items</div>
            <div class="catalog-pager">
                <button id="cat-page-prev" onclick="changeCatalogPage(-1)">â—€ Prev</button>
                <button id="cat-page-next" onclick="changeCatalogPage(1)">Next â–¶</button>
            </div>
        </div>
  </div>
</div>

<!-- Terrain Set creation popup (positioned fixed, hidden by default) -->
<div id="tbrush-popup" class="tbrush-popup" style="display:none">
  <h4>ğŸ” Define Terrain Set</h4>
  <div class="tp-row">
    <label>Name</label>
    <input type="text" id="tp-name" value="New Terrain">
  </div>
  <div class="tp-types">
    <button class="tp-type-btn" style="background:#0e2a17;border-color:var(--green);color:var(--green)" onclick="_tbrush_commitPopup('corner')">ğŸ”² Corner</button>
    <button class="tp-type-btn" style="background:#2a1f00;border-color:var(--gold);color:var(--gold)" onclick="_tbrush_commitPopup('edge')">â¬œ Edge</button>
    <button class="tp-type-btn" style="background:#1e0f3a;border-color:#a371f7;color:#a371f7" onclick="_tbrush_commitPopup('mixed')">â—† Mixed</button>
  </div>
  <div id="tp-existing" style="display:none;margin-bottom:6px">
    <button onclick="_tbrush_commitPopup('existing')" style="width:100%;font-size:11px;padding:5px" class="gold">
      â†³ Add to <span id="tp-existing-name">current set</span>
    </button>
  </div>
  <div id="tp-info" style="font-size:10px;color:var(--text-dim);margin-top:2px"></div>
  <div class="tp-footer">
    <button onclick="_tbrush_cancelPopup()" style="font-size:11px">Cancel</button>
  </div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PALETTE DATA â€” all LPC sheets organised by category
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const PALETTE_DATA = {
  'Structures': [
    'assets/lpc/Structure/Structures/Brick House A.png',
    'assets/lpc/Structure/Structures/Brick House B.png',
    'assets/lpc/Structure/Structures/Paneled House A.png',
  ],
  'Walls': [
    'assets/lpc/Structure/Walls/walls.png',
    'assets/lpc/Structure/Walls/Brick Wall A.png',
    'assets/lpc/Structure/Walls/Brick Wall B.png',
    'assets/lpc/Structure/Walls/Adobe Brick Wall.png',
    'assets/lpc/Structure/Walls/Adobe Stucco Wall.png',
    'assets/lpc/Structure/Walls/Grainy Plain Wall.png',
    'assets/lpc/Structure/Walls/Jagged Stone Walls.png',
    'assets/lpc/Structure/Walls/Drywall.png',
    'assets/lpc/Structure/Walls/Painted Walls.png',
    'assets/lpc/Structure/Walls/Siding, Plain.png',
    'assets/lpc/Structure/Walls/Panels A.png',
    'assets/lpc/Structure/Walls/Molding.png',
    'assets/lpc/Structure/Walls/Half-Wall Paneling A.png',
    'assets/lpc/Structure/Walls/Diamond Wallpaper.png',
    'assets/lpc/Structure/Walls/Floral Wallpaper A.png',
    'assets/lpc/Structure/Walls/Floral Wallpaper B.png',
    'assets/lpc/Structure/Walls/Striped Wallpaper A.png',
    'assets/lpc/Structure/Walls/Striped Wallpaper B.png',
    'assets/lpc/Structure/Walls/Striped Wallpaper C.png',
    'assets/lpc/Structure/Walls/Brick Wall Block Edging.png',
    'assets/lpc/Structure/Walls/CutawayOverlay.png',
  ],
  'Floors': [
    'assets/lpc/Structure/Floor/floors.png',
    'assets/lpc/Structure/Floor/Wood Floor A.png',
    'assets/lpc/Structure/Floor/Wood Floor B.png',
    'assets/lpc/Structure/Floor/Tile A.png',
    'assets/lpc/Structure/Floor/Tile B.png',
    'assets/lpc/Structure/Floor/Tile C.png',
    'assets/lpc/Structure/Floor/Diamond Tile A.png',
    'assets/lpc/Structure/Floor/Diamond Tile B.png',
    'assets/lpc/Structure/Floor/Diamond Tile C.png',
    'assets/lpc/Structure/Floor/Herringbone A.png',
    'assets/lpc/Structure/Floor/Floral Carpet A.png',
    'assets/lpc/Structure/Floor/Floral Carpet B.png',
    'assets/lpc/Structure/Floor/Geometric Carpet A.png',
    'assets/lpc/Structure/Floor/Geometric Carpet B.png',
    'assets/lpc/Structure/Floor/Geometric Carpet C.png',
    'assets/lpc/Structure/Floor/Gritty Dirt.png',
    'assets/lpc/Structure/Floor/Subfloor.png',
  ],
  'Roofing': [
    'assets/lpc/Structure/Roofing/Gable Shingle Roof A.png',
    'assets/lpc/Structure/Roofing/Hipped Shingle Roof A.png',
    'assets/lpc/Structure/Roofing/Flat Shingle Roof A.png',
    'assets/lpc/Structure/Roofing/Adobe Brick Roof.png',
    'assets/lpc/Structure/Roofing/Adobe Stucco Roof.png',
    'assets/lpc/Structure/Roofing/Brick Chimney A.png',
    'assets/lpc/Structure/Roofing/Roof Trim.png',
  ],
  'Doors': [
    'assets/lpc/Structure/Doors/32x48px Doors/Doorframe A.png',
    'assets/lpc/Structure/Doors/32x48px Doors/Doorframe A Shadows.png',
    'assets/lpc/Structure/Doors/32x48px Doors/Doorframe B.png',
    'assets/lpc/Structure/Doors/32x48px Doors/DoorFrame B Shadows.png',
    'assets/lpc/Structure/Doors/32x48px Doors/12 Panel Door A.png',
    'assets/lpc/Structure/Doors/32x48px Doors/12 Panel Door B.png',
    'assets/lpc/Structure/Doors/32x48px Doors/Barred Prison Door A.png',
    'assets/lpc/Structure/Doors/32x64px Doors/Doorframe A.png',
    'assets/lpc/Structure/Doors/32x64px Doors/Doorframe A Shadows.png',
    'assets/lpc/Structure/Doors/32x64px Doors/15 Panel Door A.png',
    'assets/lpc/Structure/Doors/64x64px Arched Doors/Arched Doorway A.png',
    'assets/lpc/Structure/Doors/64x64px Arched Doors/Arched Doorway A Shadows.png',
    'assets/lpc/Structure/Doors/64x64px Arched Doors/Arched Double Doors A.png',
  ],
  'Windows': [
    'assets/lpc/Structure/Windows/Stone Windows A.png',
    'assets/lpc/Structure/Windows/Stone Windows A - Emission.png',
    'assets/lpc/Structure/Windows/Ornamental Windows A.png',
    'assets/lpc/Structure/Windows/Ornamental Windows A - Emission.png',
    'assets/lpc/Structure/Windows/Ornamental Windows B.png',
    'assets/lpc/Structure/Windows/Ornamental Windows B - Emission.png',
    'assets/lpc/Structure/Windows/Window Awning A.png',
    'assets/lpc/Structure/Windows/Window Awnings A.png',
  ],
  'Wall Borders': [
    'assets/lpc/Structure/Wall Borders/Plain Edged Border.png',
    'assets/lpc/Structure/Wall Borders/Plain Edged Border - A.png',
    'assets/lpc/Structure/Wall Borders/Plain Smooth Border.png',
    'assets/lpc/Structure/Wall Borders/Decorative Border A.png',
    'assets/lpc/Structure/Wall Borders/Formal Crown Molding.png',
    'assets/lpc/Structure/Wall Borders/Pillar Crown Molding.png',
    'assets/lpc/Structure/Wall Borders/Textured Wood Border.png',
  ],
  'Fences & Signs': [
    'assets/lpc/Structure/Fences/Plain Fence A.png',
    'assets/lpc/Structure/Fences/Ornamental Fence A.png',
    'assets/lpc/Structure/Fences/Ornamental Fence B.png',
    'assets/lpc/Structure/Signs/Sign Backgrounds A.png',
    'assets/lpc/Structure/Signs/Sign Icons A.png',
  ],
  'Pillars & Stairs': [
    'assets/lpc/Structure/Pillars/Stone Pillar A.png',
    'assets/lpc/Structure/Pillars/Floral Pillar A.png',
    'assets/lpc/Structure/Stairs/Cement Stairs A.png',
    'assets/lpc/Structure/Stairs/Short Steps A.png',
    'assets/lpc/Structure/Stairs/Formal Interior Stairs A.png',
    'assets/lpc/Structure/Stairs/Wood Interior Stairs A.png',
    'assets/lpc/Structure/Stairs/Wood Interior Stairs B.png',
    'assets/lpc/Structure/Stairs/Wood Interior Stairs Wall.png',
    'assets/lpc/Structure/Platforms/Cement Platform A.png',
    'assets/lpc/Structure/Platforms/Dias with Steps A.png',
  ],
  'Bridges & Misc': [
    'assets/lpc/Structure/Bridges/Wood Bridge A - No Rails.png',
    'assets/lpc/Structure/Bridges/Wood Bridge A - Rails.png',
    'assets/lpc/Structure/Bridges/Rope Bridge A - No Rails.png',
    'assets/lpc/Structure/Bridges/Rope Bridge A - Rails.png',
    'assets/lpc/Structure/Bridges/Drawbridge A.png',
    'assets/lpc/Structure/Misc/Fountain A.png',
    'assets/lpc/Structure/Misc/Pool A.png',
    'assets/lpc/Structure/Misc/Trellis A.png',
    'assets/lpc/Structure/Misc/Drain A.png',
    'assets/lpc/Structure/Misc/Prison A.png',
  ],
  'Trees': [
    'assets/lpc/Terrain/trees_spring.png',
    'assets/lpc/Terrain/trees_summer.png',
    'assets/lpc/Terrain/trees_autumn.png',
    'assets/lpc/Terrain/trees_winter.png',
  ],
  'Plants': [
    'assets/lpc/Terrain/plants_spring.png',
    'assets/lpc/Terrain/plants_summer.png',
    'assets/lpc/Terrain/plants_autumn.png',
    'assets/lpc/Terrain/plants_winter.png',
    'assets/lpc/Terrain/flowers.png',
    'assets/lpc/Terrain/mushrooms.png',
    'assets/lpc/Terrain/wildflowers_spring.png',
    'assets/lpc/Terrain/wildflowers_summer.png',
    'assets/lpc/Terrain/wildflowers_autumn.png',
    'assets/lpc/Terrain/wildflowers_winter.png',
  ],
  'Rocks & Cliffs': [
    'assets/lpc/Terrain/Rocks, Grasslands.png',
    'assets/lpc/Terrain/Rocks, Cliffs.png',
    'assets/lpc/Terrain/cliff_spring.png',
    'assets/lpc/Terrain/cliff_summer.png',
    'assets/lpc/Terrain/cliff_autumn.png',
    'assets/lpc/Terrain/cliff_winter.png',
    'assets/lpc/Terrain/cliff_winter_ice.png',
  ],
  'Terrain': [
    'assets/lpc/Terrain/terrain_spring.png',
    'assets/lpc/Terrain/terrain_summer.png',
    'assets/lpc/Terrain/terrain_autumn.png',
    'assets/lpc/Terrain/terrain_winter.png',
    'assets/lpc/Terrain/terrain_winter_ice.png',
    'assets/lpc/Terrain/tilled_soil.png',
    'assets/lpc/Terrain/ice-shallows.png',
    'assets/lpc/Terrain/Waterfall.png',
  ],
  'Furniture': [
    'assets/lpc/Objects/Furniture/Barrel.png',
    'assets/lpc/Objects/Furniture/Bin.png',
    'assets/lpc/Objects/Furniture/Cabinet.png',
    'assets/lpc/Objects/Furniture/Cauldron.png',
    'assets/lpc/Objects/Furniture/Chest.png',
    'assets/lpc/Objects/Furniture/Countertop.png',
    'assets/lpc/Objects/Furniture/Crate.png',
    'assets/lpc/Objects/Furniture/Dresser.png',
    'assets/lpc/Objects/Furniture/End Table.png',
    'assets/lpc/Objects/Furniture/Fireplace.png',
    'assets/lpc/Objects/Furniture/Fireplace, Cast Iron.png',
    'assets/lpc/Objects/Furniture/Ladder.png',
    'assets/lpc/Objects/Furniture/Planter.png',
    'assets/lpc/Objects/Furniture/Shelf.png',
    'assets/lpc/Objects/Furniture/Stone Slab.png',
    'assets/lpc/Objects/Furniture/Table, Rough Wood.png',
    'assets/lpc/Objects/Furniture/Table, Ornate Wood.png',
    'assets/lpc/Objects/Furniture/Table, Card.png',
    'assets/lpc/Objects/Furniture/Table, Workshop.png',
    'assets/lpc/Objects/Furniture/Trough.png',
    'assets/lpc/Objects/Furniture/Wolf Stone.png',
    'assets/lpc/Objects/Furniture/Standing Screen.png',
    'assets/lpc/Objects/Furniture/Mirror, Standing.png',
    'assets/lpc/Objects/Furniture/Desk, Vanity.png',
  ],
  'Seating': [
    'assets/lpc/Objects/Furniture/Seating/Bar Stools.png',
    'assets/lpc/Objects/Furniture/Seating/Chair, Dining A.png',
    'assets/lpc/Objects/Furniture/Seating/Chair, Dining B.png',
    'assets/lpc/Objects/Furniture/Seating/Chair, Dining C.png',
    'assets/lpc/Objects/Furniture/Seating/Chair, Sofa A.png',
    'assets/lpc/Objects/Furniture/Seating/Chair, Sofa B.png',
    'assets/lpc/Objects/Furniture/Seating/Chair, Sofa C.png',
    'assets/lpc/Objects/Furniture/Seating/Chair, Dining D.png',
    'assets/lpc/Objects/Furniture/Seating/Thrones.png',
  ],
'Beds': [
    'assets/lpc/Objects/Furniture/Beds/Beds, Child Headboards.png',
    'assets/lpc/Objects/Furniture/Beds/Beds, Child Mattresses.png',
    'assets/lpc/Objects/Furniture/Beds/Beds, Child.png',
    'assets/lpc/Objects/Furniture/Beds/Beds, Double B.png',
    'assets/lpc/Objects/Furniture/Beds/Beds, Double C - Overlays.png',
    'assets/lpc/Objects/Furniture/Beds/Beds, Double C.png',
    'assets/lpc/Objects/Furniture/Beds/Beds, Double Headboards.png',
    'assets/lpc/Objects/Furniture/Beds/Beds, Double Mattresses.png',
    'assets/lpc/Objects/Furniture/Beds/Beds, Double.png',
    'assets/lpc/Objects/Furniture/Beds/Beds, Single  A.png',
    'assets/lpc/Objects/Furniture/Beds/Beds, Single B.png',
    'assets/lpc/Objects/Furniture/Beds/Beds, Single C.png',
    'assets/lpc/Objects/Furniture/Beds/Beds, Single Headboards.png',
    'assets/lpc/Objects/Furniture/Beds/Beds, Single Mattresses.png',
    'assets/lpc/Objects/Furniture/Beds/Beds, Single A.png',
    'assets/lpc/Objects/Furniture/Beds/Beds, Single B.png',
    'assets/lpc/Objects/Furniture/Beds/Beds, Double.png',
    'assets/lpc/Objects/Furniture/Beds/Beds, Double B.png',
    ],
  'Rugs': [
    'assets/lpc/Objects/Furniture/Rugs/Diamond Rug, tiling.png',
    'assets/lpc/Objects/Furniture/Rugs/Rainbow Checkered Rug.png',
    'assets/lpc/Objects/Furniture/Rugs/Rainbow Rug.png',
    'assets/lpc/Objects/Furniture/Rugs/Swirling Vine Rug.png',
  ],
  'Crafting': [
    'assets/lpc/Objects/Furniture/Smithing/Anvils.png',
    'assets/lpc/Objects/Furniture/Smithing/Bellows.png',
    'assets/lpc/Objects/Furniture/Smithing/Coal Piles.png',
    'assets/lpc/Objects/Furniture/Smithing/Forge A.png',
    'assets/lpc/Objects/Furniture/Smithing/Furnace A.png',
    'assets/lpc/Objects/Furniture/Smithing/Grindstone.png',
    'assets/lpc/Objects/Furniture/Smithing/Smelter.png',
    'assets/lpc/Objects/Furniture/Smithing/Workbench, Smith.png',
    'assets/lpc/Objects/Furniture/Sewing & Weaving/Dress Form.png',
    'assets/lpc/Objects/Furniture/Sewing & Weaving/Loom.png',
    'assets/lpc/Objects/Furniture/Sewing & Weaving/Spinning Wheel.png',
    'assets/lpc/Objects/Furniture/Sewing & Weaving/Workbench, Sewing.png',
    'assets/lpc/Objects/Furniture/Workbench, Carpentry.png',
    'assets/lpc/Objects/Furniture/Sawhorse.png',
  ],
  'Small Items': [
    'assets/lpc/Objects/Small Items/Baskets A.png',
    'assets/lpc/Objects/Small Items/Boxes.png',
    'assets/lpc/Objects/Small Items/Buckets.png',
    'assets/lpc/Objects/Small Items/Dungeon Elements.png',
    'assets/lpc/Objects/Small Items/Fire, Camp.png',
    'assets/lpc/Objects/Small Items/Fire, Fireplace.png',
    'assets/lpc/Objects/Small Items/Flowers.png',
    'assets/lpc/Objects/Small Items/Games.png',
    'assets/lpc/Objects/Small Items/Hay & Straw.png',
    'assets/lpc/Objects/Small Items/Lumber.png',
    'assets/lpc/Objects/Small Items/Pillows.png',
    'assets/lpc/Objects/Small Items/Skeletons A.png',
    'assets/lpc/Objects/Small Items/Tools, Carpentry.png',
    'assets/lpc/Objects/Small Items/Tools, Smithing.png',
    'assets/lpc/Objects/Small Items/Dishes A.png',
    'assets/lpc/Objects/Small Items/Fireplace, Accessories A.png',
    'assets/lpc/Objects/Small Items/Kitchen Clutter A.png',
    'assets/lpc/Objects/Small Items/Sawdust.png',
    'assets/lpc/Objects/Small Items/Ores & Ingots/Ore, Iron.png',
    'assets/lpc/Objects/Small Items/Ores & Ingots/Ore, Gold.png',
    'assets/lpc/Objects/Small Items/Ores & Ingots/Ore, Coal.png',
    'assets/lpc/Objects/Small Items/Ores & Ingots/Ore, Copper.png',
    'assets/lpc/Objects/Small Items/Ores & Ingots/Alloys.png',
  ],
  'Lighting': [
    'assets/lpc/Objects/Furniture/Lighting, Floor.png',
    'assets/lpc/Objects/Furniture/Lighting, Outdoors.png',
    'assets/lpc/Objects/Small Items/Lighting, Table.png',
    'assets/lpc/Objects/Wall Items/Lighting, Wall.png',
  ],
  'Wall Decor': [
    'assets/lpc/Objects/Wall Items/Curtains.png',
    'assets/lpc/Objects/Wall Items/Mirrors.png',
    'assets/lpc/Objects/Wall Items/Paintings, Abstract.png',
    'assets/lpc/Objects/Wall Items/Paintings, Landscape.png',
    'assets/lpc/Objects/Wall Items/Paintings, Portraits.png',
    'assets/lpc/Objects/Wall Items/Paintings, Still Life.png',
    'assets/lpc/Objects/Wall Items/Posters.png',
    'assets/lpc/Objects/Small Items/Tabletop Portraits.png',
  ],
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const TILE = 32;
const PAL_ZOOM = 1;

let editorMode    = 'building';  // 'building' | 'object'
let currentCategory = null;
let activeStamp   = null;
let activeTool    = 'paint';

// â”€â”€ Canvas & grid (per-mode, saved/restored on switch) â”€â”€
let gridW = 12, gridH = 12;
let canvasZoom = 2, panX = 20, panY = 20;
let meta = {};
let undoStack = [], redoStack = [];

// â”€â”€ Building-mode data (always alive) â”€â”€
let layers = { floor:{}, walls:{}, roof:{}, overlay:{} };
let activeLayer   = 'floor';
let visibleLayers = new Set(['floor','walls','roof','overlay']);
let buildings     = [];
let buildingEditIdx = -1;

// â”€â”€ Object-mode data (always alive) â”€â”€
let objLayers         = { base:{}, detail:{}, top:{} };
let activeObjLayer    = 'base';
let visibleObjLayers  = new Set(['base','detail','top']);
let objDefs           = [];
let objEditIdx        = -1;
let _objHealthStates  = [];  // Array of {label, minHealthPct, tiles: {key:cell,...}}
let _objSeasonVariants = {}; // { spring|summer|autumn|winter: {key:cell,...} }
let _objGrowthStates  = [];  // Array of {label, daysToReach, tiles: {key:cell,...}}
let _objRotationVariants = []; // Array of {label, tiles: {key:cell,...}}
let _objColorVariants = []; // Array of {label, objLayers, meta, originQ, originR, gridW, gridH, rotationVariants, seasonVariants}
let _activeColorVariantIdx = -1; // -1 = base, 0+ = color variant index
let _objRequiredTechs = []; // Array of tech IDs required to build this object
let _availableTechs   = []; // Array of {id, name, icon, category} from parent tech editor
let _resourceTypes = [
    { id: 'wood', name: 'Wood', icon: 'ğŸªµ', color: '#8b5a2b', buildCostEligible: true },
    { id: 'timber', name: 'Timber', icon: 'ğŸŒ²', color: '#8b5a2b', buildCostEligible: true },
    { id: 'stone', name: 'Stone', icon: 'â›°ï¸', color: '#808080', buildCostEligible: true },
    { id: 'iron', name: 'Iron', icon: 'â›ï¸', color: '#8a7a7a', buildCostEligible: true },
];
let _objOriginQ       = null; // Grid col of the origin/anchor tile (null = use top-left painted tile)
let _objOriginR       = null; // Grid row of the origin/anchor tile
let _bldOriginQ       = null; // Building origin col (null = use top-left painted tile)
let _bldOriginR       = null; // Building origin row

function _setResourceTypes(resourceTypes) {
    if (Array.isArray(resourceTypes) && resourceTypes.length) {
        _resourceTypes = resourceTypes
            .map(r => ({
                id: String(r.id || '').trim(),
                name: String(r.name || r.id || '').trim(),
                icon: String(r.icon || 'ğŸ“¦'),
                color: String(r.color || '#888888'),
                buildCostEligible: !!r.buildCostEligible,
            }))
            .filter(r => r.id);
    }
    _refreshResourceMenus();
}

function _getBuildCostResourceTypes() {
    const eligible = _resourceTypes.filter(r => r.buildCostEligible);
    if (eligible.length) return eligible;
    return _resourceTypes.filter(r => ['wood', 'timber', 'stone', 'iron'].includes(r.id));
}

function _refreshResourceMenus() {
    _renderObjResourceOptions();
    _renderN9bCostRows();
}

function _renderObjResourceOptions() {
    const sel = document.getElementById('obj-resource');
    if (!sel) return;
    const selected = sel.value || '';
    const opts = [..._resourceTypes].sort((a, b) => a.name.localeCompare(b.name));
    sel.innerHTML = '<option value="">â€” None</option>';
    for (const r of opts) {
        const o = document.createElement('option');
        o.value = r.id;
        o.textContent = `${r.icon || 'ğŸ“¦'} ${r.name}`;
        sel.appendChild(o);
    }
        if (selected && !opts.some(r => r.id === selected)) {
            const fallback = document.createElement('option');
            fallback.value = selected;
            fallback.textContent = `ğŸ“¦ ${selected}`;
            sel.appendChild(fallback);
        }
        sel.value = selected || '';
}

function _renderN9bCostRows(selectedResources = null) {
    const wrap = document.getElementById('n9b-cost-resource-rows');
    if (!wrap) return;
    const costMap = selectedResources || (_n9b_selIdx >= 0 ? ((_nineTileBrushes[_n9b_selIdx].cost || {}).resources || {}) : {});
    const defs = [..._getBuildCostResourceTypes()].sort((a, b) => a.name.localeCompare(b.name));
    wrap.innerHTML = '';
    for (const r of defs) {
        const row = document.createElement('div');
        row.className = 'tset-props-row';
        row.style.cssText = 'flex:1;min-width:64px';
        const label = document.createElement('label');
        label.style.fontSize = '10px';
        label.textContent = `${r.icon || 'ğŸ“¦'} ${r.name}`;
        const input = document.createElement('input');
        input.type = 'number';
        input.min = '0';
        input.max = '999';
        input.value = String(costMap[r.id] || 0);
        input.style.cssText = 'font-size:11px;width:56px';
        input.dataset.resId = r.id;
        input.onchange = n9b_onCostChange;
        row.appendChild(label);
        row.appendChild(input);
        wrap.appendChild(row);
    }
}

// â”€â”€ Saved mode states (for restoring on switch) â”€â”€
let _savedBuildingState = null;
let _savedObjectState   = null;

// Camera
let isPanning = false, panStart = null;
let isDragging = false;

// Selection
let selDrawing = false, selRect = null;
let selFloat   = null, selOffset = { dq:0, dr:0 };
let selMoving  = false, selMoveAnchor = null;

// Image cache
const imgCache = new Map();

// Palette drag
const palHighlightDivs = new Map();
let palDragging = false, palDragMeta = null;
let palDragStart = null, palDragLive = null;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TERRAIN BRUSH STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let _tbrush_sets = [
    {
        name: 'LPC Ground',
        type: 'corner',
        terrains: [
            { name: 'Grass', color: '#5c9a2e' },
            { name: 'Dirt',  color: '#8b6914' },
            { name: 'Sand',  color: '#d4b96e' },
            { name: 'Water', color: '#2175aa' },
        ],
        tileAssignments: {} // patternKey â†’ { sheetPath, sx, sy }
    },
    {
        name: 'Paths',
        type: 'edge',
        terrains: [
            { name: 'Ground', color: '#5c9a2e' },
            { name: 'Path',   color: '#a08050' },
        ],
        tileAssignments: {}
    },
];
let _tbrush_selSet = -1;
let _tbrush_selTerrain = -1;
let _tbrush_editMode = false; // When true, palette clicks assign tiles to patterns
let _tbrush_selectedPattern = null; // Pattern key selected in the grid for manual assignment
let _tbrush_popup = { visible: false, sheetPath: '', c1:0, r1:0, c2:0, r2:0 };
const _palOverlayCanvases = new Map(); // sheetPath â†’ overlay canvas element

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
/** Returns the tile map that paint/erase/fill operate on */
function getTileStore() {
    return editorMode === 'building' ? layers[activeLayer] : objLayers[activeObjLayer];
}

function slugify(s) { return s.toLowerCase().replace(/[^a-z0-9]+/g,'_').replace(/^_|_$/g,''); }
function escHtml(s) { return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function init() {
    buildPaletteCats();
    _refreshResourceMenus();
    resizeObserver();
    initBuildCanvas();
    initPaletteResizer();
    refreshHealthStatesList();
    refreshSeasonVariantsList();
    refreshGrowthStatesList();
    // import-input removed â€” import is handled by parent editor
    document.addEventListener('keydown', onKey);
    document.addEventListener('mouseup', (event) => {
        if (_tbrush_popup.visible) return; // Don't process while popup is open
        if (!palDragging) return;
        palDragging = false;
        if (palDragStart && palDragMeta) {
            const c1 = Math.min(palDragStart.col, palDragLive.col);
            const r1 = Math.min(palDragStart.row, palDragLive.row);
            const c2 = Math.max(palDragStart.col, palDragLive.col);
            const r2 = Math.max(palDragStart.row, palDragLive.row);
            // Terrain brush: handle palette clicks/selections
            if (activeTool === 'tbrush') {
                const isSingle = (c1 === c2 && r1 === r2);
                if (isSingle && _tbrush_selSet >= 0 && _tbrush_selectedPattern) {
                    // Single click with a pattern selected in the grid â†’ assign to that pattern
                    const tset = _tbrush_sets[_tbrush_selSet];
                    tset.tileAssignments[_tbrush_selectedPattern] = {
                        sheetPath: palDragMeta.path, sx: c1 * TILE, sy: r1 * TILE
                    };
                    _tbrush_selectedPattern = null;
                    tbrush_refreshUI();
                    _tbrush_updatePaletteOverlays();
                } else if (isSingle && _tbrush_selSet >= 0 && _tbrush_selTerrain >= 0) {
                    // Single click with terrain selected â†’ assign as all-this-terrain pattern
                    _tbrush_assignFromPalette(palDragMeta.path, c1, r1, c2, r2);
                } else {
                    // Multi-tile selection (or no set selected) â†’ show define-set popup
                    _tbrush_showCreatePopup(palDragMeta.path, c1, r1, c2, r2, event.clientX, event.clientY);
                }
                return;
            }
            // 9-tile brush: single-click with a slot selected â†’ assign tile to slot
            if (_n9b_selIdx >= 0 && _n9b_selSlot) {
                const isSingle = (c1 === c2 && r1 === r2);
                if (isSingle) {
                    n9b_assignPaletteTile(palDragMeta.path, c1, r1);
                    return;
                }
            }
            // Door catalog: picking mode â†’ assign 1Ã—2 tile
            if (_dcat_picking && _dcat_selIdx >= 0) {
                const isSingle = (c1 === c2 && r1 === r2);
                if (isSingle) {
                    dcat_assignPaletteTile(palDragMeta.path, c1, r1);
                    return;
                }
            }
            // Window catalog: picking mode â†’ assign tile
            if (_wcat_picking && _wcat_selIdx >= 0) {
                const isSingle = (c1 === c2 && r1 === r2);
                if (isSingle) {
                    wcat_assignPaletteTile(palDragMeta.path, c1, r1);
                    return;
                }
            }
            const baseName = palDragMeta.path.split('/').pop().replace(/\.[^.]+$/, '');
            setStamp(palDragMeta.path, c1, r1, c2, r2, baseName);
        }
    });
    renderBuildCanvas();
}

function initPaletteResizer() {
    const handle = document.getElementById('pal-resizer');
    const panel  = document.getElementById('palette-panel');
    let startX, startW;
    handle.addEventListener('mousedown', e => {
        e.preventDefault();
        startX = e.clientX; startW = panel.offsetWidth;
        handle.classList.add('dragging');
        const onMove = ev => { panel.style.width = Math.max(180, Math.min(700, startW + ev.clientX - startX)) + 'px'; };
        const onUp   = () => { handle.classList.remove('dragging'); document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp); };
        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
    });
}

function resizeObserver() {
    new ResizeObserver(() => renderBuildCanvas()).observe(document.getElementById('canvas-wrap'));
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MODE SWITCHING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function setEditorMode(mode) {
    if (mode === editorMode) return;
    if (selFloat) commitSelection();

    // Save current canvas state
    const saved = {
        gridW, gridH, meta: JSON.parse(JSON.stringify(meta)),
        undoStack: undoStack.slice(), redoStack: redoStack.slice(),
        zoom: canvasZoom, panX, panY,
    };
    if (editorMode === 'building') {
        saved.layers = JSON.parse(JSON.stringify(layers));
        saved.activeLayer = activeLayer;
        saved.visLayers = [...visibleLayers];
        saved.editIdx = buildingEditIdx;
        saved.originQ = _bldOriginQ;
        saved.originR = _bldOriginR;
        _savedBuildingState = saved;
    } else {
        saved.objLayers = JSON.parse(JSON.stringify(objLayers));
        saved.activeObjLayer = activeObjLayer;
        saved.visObjLayers = [...visibleObjLayers];
        saved.editIdx = objEditIdx;
        saved.healthStates = JSON.parse(JSON.stringify(_objHealthStates));
        saved.originQ = _objOriginQ;
        saved.originR = _objOriginR;
        saved.seasonVariants = JSON.parse(JSON.stringify(_objSeasonVariants));
        saved.growthStates = JSON.parse(JSON.stringify(_objGrowthStates));
        saved.rotationVariants = JSON.parse(JSON.stringify(_objRotationVariants));
        saved.colorVariants = JSON.parse(JSON.stringify(_objColorVariants));
        _savedObjectState = saved;
    }

    editorMode = mode;

    // Update toolbar button labels / visibility for the new mode
    {
        const markerBtn = document.getElementById('tool-marker');
        if (markerBtn) markerBtn.textContent = mode === 'object' ? 'ğŸ¯ Interact' : 'ğŸšª Door';
        const originBtn = document.getElementById('tool-origin');
        if (originBtn) originBtn.style.display = '';
    }
    const restore = mode === 'building' ? _savedBuildingState : _savedObjectState;
    if (restore) {
        gridW = restore.gridW; gridH = restore.gridH;
        meta  = restore.meta;
        undoStack = restore.undoStack; redoStack = restore.redoStack;
        canvasZoom = restore.zoom; panX = restore.panX; panY = restore.panY;
        if (mode === 'building') {
            layers = restore.layers; activeLayer = restore.activeLayer;
            visibleLayers = new Set(restore.visLayers);
            buildingEditIdx = restore.editIdx;
            _bldOriginQ = restore.originQ != null ? restore.originQ : null;
            _bldOriginR = restore.originR != null ? restore.originR : null;
        } else {
            objLayers = restore.objLayers || { base: restore.tiles || {}, detail:{}, top:{} };
            activeObjLayer = restore.activeObjLayer || 'base';
            visibleObjLayers = restore.visObjLayers ? new Set(restore.visObjLayers) : new Set(['base','detail','top']);
            objEditIdx = restore.editIdx;
            _objHealthStates = restore.healthStates || [];
            refreshHealthStatesList();
            _objOriginQ = restore.originQ != null ? restore.originQ : null;
            _objOriginR = restore.originR != null ? restore.originR : null;
            _objSeasonVariants = restore.seasonVariants ? JSON.parse(JSON.stringify(restore.seasonVariants)) : {};
            refreshSeasonVariantsList();
            _objGrowthStates = restore.growthStates ? JSON.parse(JSON.stringify(restore.growthStates)) : [];
            refreshGrowthStatesList();
            _objRotationVariants = restore.rotationVariants ? JSON.parse(JSON.stringify(restore.rotationVariants)) : [];
            refreshRotationVariantsList();
            _objColorVariants = restore.colorVariants ? JSON.parse(JSON.stringify(restore.colorVariants)) : [];
            refreshColorVariantsList();
        }
    } else {
        // Defaults
        if (mode === 'building') {
            gridW = 12; gridH = 12;
            layers = { floor:{}, walls:{}, roof:{}, overlay:{} };
            activeLayer = 'floor'; visibleLayers = new Set(['floor','walls','roof','overlay']);
            meta = {}; buildingEditIdx = -1;
            _bldOriginQ = null; _bldOriginR = null;
        } else {
            gridW = 8; gridH = 8;
            objLayers = { base:{}, detail:{}, top:{} };
            activeObjLayer = 'base';
            visibleObjLayers = new Set(['base','detail','top']);
            meta = {}; objEditIdx = -1;
        }
        undoStack = []; redoStack = [];
        canvasZoom = 2; panX = 20; panY = 20;
    }

    document.getElementById('grid-w').value = gridW;
    document.getElementById('grid-h').value = gridH;
    updateModeUI();
    refreshLibrary();
    fitCanvas();
}

function updateModeUI() {
    const isB = editorMode === 'building';
    document.getElementById('mode-building').classList.toggle('active', isB);
    document.getElementById('mode-object').classList.toggle('active', !isB);
    document.getElementById('layer-section').style.display  = '';  // Always show layers
    document.getElementById('bld-props').style.display      = isB ? '' : 'none';
    document.getElementById('obj-props').style.display      = isB ? 'none' : '';
    document.getElementById('btn-procgen').style.display    = isB ? '' : 'none';

    // Update layer button labels and state
    const layerNames  = isB ? ['floor','walls','roof','overlay'] : ['base','detail','top'];
    const layerLabels = isB ? ['Floor','Walls','Roof','Overlay'] : ['Base','Detail','Top'];
    const layerBtnIds = ['layer-floor','layer-walls','layer-roof','layer-overlay'];
    const visBtnIds   = ['vis-floor','vis-walls','vis-roof','vis-overlay'];

    for (let i = 0; i < 4; i++) {
        const lb = document.getElementById(layerBtnIds[i]);
        const vb = document.getElementById(visBtnIds[i]);
        if (i < layerNames.length) {
            lb.style.display = '';
            lb.textContent = layerLabels[i];
            lb.onclick = () => setLayer(layerNames[i]);
            lb.classList.toggle('active', isB ? activeLayer === layerNames[i] : activeObjLayer === layerNames[i]);
            vb.style.display = '';
            vb.textContent = layerLabels[i];
            vb.onclick = () => toggleVis(layerNames[i]);
            vb.classList.toggle('active', isB ? visibleLayers.has(layerNames[i]) : visibleObjLayers.has(layerNames[i]));
        } else {
            lb.style.display = 'none';
            vb.style.display = 'none';
        }
    }
    // Update marker tool label
    const markerBtn = document.getElementById('tool-marker');
    markerBtn.innerHTML = isB ? 'ğŸšª Door' : 'ğŸ¯ Interact';
    markerBtn.title = isB ? 'Place door marker (D)' : 'Toggle interaction point (N)';
    // Refresh 9-tile brush panel visibility
    n9b_refreshUI();
    // Refresh door catalog panel visibility
    dcat_refreshUI();
    // Refresh window catalog panel visibility
    wcat_refreshUI();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PALETTE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildPaletteCats() {
    const cats = document.getElementById('palette-cats');
    cats.innerHTML = '';
    for (const cat of Object.keys(PALETTE_DATA)) {
        const btn = document.createElement('button');
        btn.className = 'cat-btn';
        btn.textContent = cat;
        btn.onclick = () => showCategory(cat, btn);
        cats.appendChild(btn);
    }
}

function showCategory(cat, btn) {
    document.querySelectorAll('.cat-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    currentCategory = cat;
    const container = document.getElementById('palette-sheets');
    container.innerHTML = '';
    const paths = PALETTE_DATA[cat];
    for (const path of paths) {
        const block = document.createElement('div');
        block.className = 'sheet-block';
        const label = document.createElement('div');
        label.className = 'sheet-name';
        const baseName = path.split('/').pop().replace(/\.[^.]+$/, '');
        label.innerHTML = `<span title="${path}">${baseName}</span>`;
        block.appendChild(label);
        const wrap = document.createElement('div');
        wrap.className = 'sheet-canvas-wrap';
        block.appendChild(wrap);
        const cvs = document.createElement('canvas');
        cvs.className = 'palette-canvas';
        wrap.appendChild(cvs);
        const highlight = document.createElement('div');
        highlight.className = 'stamp-highlight';
        highlight.style.display = 'none';
        wrap.appendChild(highlight);
        // Terrain brush overlay canvas (shows colored indicators on assigned tiles)
        const terrOverlay = document.createElement('canvas');
        terrOverlay.className = 'pal-terrain-overlay';
        terrOverlay.style.display = 'none';
        wrap.appendChild(terrOverlay);
        container.appendChild(block);
        loadImage(path).then(img => {
            if (!img) { label.innerHTML += ` <span style="color:var(--red);font-size:10px">âš  missing</span>`; return; }
            const cols = Math.floor(img.width / TILE);
            const rows = Math.floor(img.height / TILE);
            const dispW = img.width * PAL_ZOOM, dispH = img.height * PAL_ZOOM;
            cvs.width = dispW; cvs.height = dispH;
            wrap.style.width = dispW + 'px'; wrap.style.height = dispH + 'px';
            const ctx = cvs.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, dispW, dispH);
            ctx.strokeStyle = 'rgba(255,255,255,0.18)'; ctx.lineWidth = 0.5;
            for (let c = 0; c <= cols; c++) { ctx.beginPath(); ctx.moveTo(c*TILE*PAL_ZOOM,0); ctx.lineTo(c*TILE*PAL_ZOOM,dispH); ctx.stroke(); }
            for (let r = 0; r <= rows; r++) { ctx.beginPath(); ctx.moveTo(0,r*TILE*PAL_ZOOM); ctx.lineTo(dispW,r*TILE*PAL_ZOOM); ctx.stroke(); }
            label.innerHTML = `<span title="${path}">${baseName}</span><span style="font-size:10px;color:var(--text-dim)">${cols}Ã—${rows}</span>`;
            // Register and size the terrain overlay canvas
            terrOverlay.width = dispW; terrOverlay.height = dispH;
            terrOverlay.style.width = dispW + 'px'; terrOverlay.style.height = dispH + 'px';
            _palOverlayCanvases.set(path, terrOverlay);
            palHighlightDivs.set(path, highlight);
            updatePaletteHighlight(path, highlight);
            // Draw terrain overlays if tbrush is active
            if (activeTool === 'tbrush') _tbrush_updatePaletteOverlays();
            cvs.addEventListener('mousedown', e => {
                if (e.button !== 0) return;
                e.preventDefault();
                const rect = cvs.getBoundingClientRect();
                const col = Math.max(0, Math.min(cols-1, Math.floor((e.clientX - rect.left) / PAL_ZOOM / TILE)));
                const row = Math.max(0, Math.min(rows-1, Math.floor((e.clientY - rect.top)  / PAL_ZOOM / TILE)));
                palDragging = true; palDragMeta = { path, cols, rows };
                palDragStart = { col, row }; palDragLive = { col, row };
                updatePalDragHighlight();
            });
            cvs.addEventListener('mousemove', e => {
                if (!palDragging || palDragMeta.path !== path) return;
                const rect = cvs.getBoundingClientRect();
                palDragLive = {
                    col: Math.max(0, Math.min(cols-1, Math.floor((e.clientX - rect.left) / PAL_ZOOM / TILE))),
                    row: Math.max(0, Math.min(rows-1, Math.floor((e.clientY - rect.top)  / PAL_ZOOM / TILE)))
                };
                updatePalDragHighlight();
            });
        });
    }
}

function updatePalDragHighlight() {
    if (!palDragging || !palDragStart || !palDragLive || !palDragMeta) return;
    const hl = palHighlightDivs.get(palDragMeta.path);
    if (!hl) return;
    const c1 = Math.min(palDragStart.col, palDragLive.col), r1 = Math.min(palDragStart.row, palDragLive.row);
    const c2 = Math.max(palDragStart.col, palDragLive.col), r2 = Math.max(palDragStart.row, palDragLive.row);
    hl.style.display='block'; hl.style.left=(c1*TILE*PAL_ZOOM)+'px'; hl.style.top=(r1*TILE*PAL_ZOOM)+'px';
    hl.style.width=((c2-c1+1)*TILE*PAL_ZOOM)+'px'; hl.style.height=((r2-r1+1)*TILE*PAL_ZOOM)+'px';
}

function updatePaletteHighlight(path, highlight) {
    if (!activeStamp || activeStamp.sheetPath !== path) { highlight.style.display = 'none'; return; }
    const s = activeStamp;
    if (s._palC1 == null) return;
    highlight.style.display='block'; highlight.style.left=(s._palC1*TILE*PAL_ZOOM)+'px'; highlight.style.top=(s._palR1*TILE*PAL_ZOOM)+'px';
    highlight.style.width=((s._palC2-s._palC1+1)*TILE*PAL_ZOOM)+'px'; highlight.style.height=((s._palR2-s._palR1+1)*TILE*PAL_ZOOM)+'px';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CUSTOM SHEET LOADING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function loadCustomSheet() {
    const input = document.createElement('input');
    input.type = 'file'; input.accept = 'image/*';
    input.onchange = e => {
        const file = e.target.files[0];
        if (!file) return;
        const assetPath = prompt('Asset path for this sheet (relative to project root):', `assets/${file.name}`);
        if (!assetPath) return;
        const reader = new FileReader();
        reader.onload = ev => {
            const img = new Image();
            img.onload = () => {
                imgCache.set(assetPath, img);
                const baseName = file.name.replace(/\.[^.]+$/, '');
                const catName = `ğŸ“‚ ${baseName}`;
                PALETTE_DATA[catName] = [assetPath];
                buildPaletteCats();
                // Auto-show the new category
                const btns = document.querySelectorAll('#palette-cats .cat-btn');
                const lastBtn = btns[btns.length - 1];
                if (lastBtn) showCategory(catName, lastBtn);
            };
            img.src = ev.target.result;
        };
        reader.readAsDataURL(file);
    };
    input.click();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  STAMP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function setStamp(sheetPath, palC1, palR1, palC2, palR2, baseName) {
    const sW = palC2 - palC1 + 1, sH = palR2 - palR1 + 1;
    const stampTiles = [];
    for (let dr = 0; dr < sH; dr++)
        for (let dc = 0; dc < sW; dc++)
            stampTiles.push({ localCol: dc, localRow: dr, sx: (palC1+dc)*TILE, sy: (palR1+dr)*TILE });
    const label = (sW===1 && sH===1) ? `${baseName} [${palC1},${palR1}]` : `${baseName} [${palC1},${palR1} â†’ ${palC2},${palR2}]`;
    for (const [p, hl] of palHighlightDivs) { if (p !== sheetPath) hl.style.display = 'none'; }
    activeStamp = { sheetPath, stampCols: sW, stampRows: sH, tiles: stampTiles, label, _palC1: palC1, _palR1: palR1, _palC2: palC2, _palR2: palR2 };
    document.getElementById('stamp-info').innerHTML = `<strong>${escHtml(baseName)}</strong><br>${sW}Ã—${sH} tile${sW*sH!==1?'s':''}`;
    refreshStampPreview();
    if (activeTool === 'eyedrop') setTool('paint');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  STAMP PREVIEW
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function refreshStampPreview() {
    if (!activeStamp) return;
    const PREVIEW = 96;
    const sCvs = document.getElementById('stamp-canvas');
    sCvs.width = sCvs.height = PREVIEW;
    const sCtx = sCvs.getContext('2d');
    sCtx.imageSmoothingEnabled = false;
    sCtx.clearRect(0, 0, PREVIEW, PREVIEW);
    const W = activeStamp.stampCols, H = activeStamp.stampRows;
    const tileDisp = Math.min(PREVIEW / W, PREVIEW / H);
    const ox = Math.round((PREVIEW - W * tileDisp) / 2);
    const oy = Math.round((PREVIEW - H * tileDisp) / 2);
    loadImage(activeStamp.sheetPath).then(img => {
        if (!img) return;
        sCtx.clearRect(0, 0, PREVIEW, PREVIEW);
        sCtx.imageSmoothingEnabled = false;
        for (const t of activeStamp.tiles) {
            const px = ox + t.localCol * tileDisp;
            const py = oy + t.localRow * tileDisp;
            if (t.rotation) {
                sCtx.save();
                sCtx.translate(px + tileDisp/2, py + tileDisp/2);
                sCtx.rotate(t.rotation * Math.PI / 180);
                sCtx.drawImage(img, t.sx, t.sy, TILE, TILE, -tileDisp/2, -tileDisp/2, tileDisp, tileDisp);
                sCtx.restore();
            } else {
                sCtx.drawImage(img, t.sx, t.sy, TILE, TILE, px, py, tileDisp, tileDisp);
            }
        }
    });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ROTATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
/** Rotate the active stamp 90Â° CW (dir=1) or CCW (dir=-1).
 *  Rearranges tile positions AND stores per-tile visual rotation.
 */
function rotateStamp(dir) {
    if (!activeStamp) return;
    const W = activeStamp.stampCols, H = activeStamp.stampRows;
    activeStamp.tiles = activeStamp.tiles.map(t => {
        let newLC, newLR;
        if (dir > 0) { newLC = H - 1 - t.localRow; newLR = t.localCol; }
        else         { newLC = t.localRow;           newLR = W - 1 - t.localCol; }
        const newRot = (((t.rotation || 0) + dir * 90) % 360 + 360) % 360;
        return { ...t, localCol: newLC, localRow: newLR, rotation: newRot || undefined };
    });
    activeStamp.stampCols = H;
    activeStamp.stampRows = W;
    const baseName = activeStamp.sheetPath.split('/').pop().replace(/\.[^.]+$/, '');
    const rotSymbol = dir > 0 ? ' â†»' : ' â†º';
    document.getElementById('stamp-info').innerHTML =
        `<strong>${escHtml(baseName)}</strong><br>${H}\u00d7${W} tile${H*W!==1?'s':''}${rotSymbol}`;
    refreshStampPreview();
    renderBuildCanvas();
}

/** Rotate the current floating selection 90Â° CW (dir=1) or CCW (dir=-1). */
function rotateSelection(dir) {
    if (!selFloat) return;
    pushUndo();
    const W = selFloat.q2 - selFloat.q1 + 1;
    const H = selFloat.r2 - selFloat.r1 + 1;
    const rotateStore = (store, applyVisualRot) => {
        const out = {};
        for (const [key, cell] of Object.entries(store)) {
            const [q, r] = key.split(',').map(Number);
            const lq = q - selFloat.q1, lr = r - selFloat.r1;
            let newLQ, newLR;
            if (dir > 0) { newLQ = H - 1 - lr; newLR = lq; }
            else         { newLQ = lr;          newLR = W - 1 - lq; }
            const nq = selFloat.q1 + newLQ, nr = selFloat.r1 + newLR;
            if (applyVisualRot) {
                const newRot = (((cell.rotation || 0) + dir * 90) % 360 + 360) % 360;
                const newCell = { ...cell };
                if (newRot) newCell.rotation = newRot; else delete newCell.rotation;
                out[`${nq},${nr}`] = newCell;
            } else {
                out[`${nq},${nr}`] = { ...cell };
            }
        }
        return out;
    };
    if (editorMode === 'building') {
        selFloat.floor   = rotateStore(selFloat.floor   || {}, true);
        selFloat.walls   = rotateStore(selFloat.walls   || {}, true);
        selFloat.roof    = rotateStore(selFloat.roof    || {}, true);
        selFloat.overlay = rotateStore(selFloat.overlay || {}, true);
    } else {
        selFloat.tiles   = rotateStore(selFloat.tiles   || {}, true);
    }
    selFloat.meta = rotateStore(selFloat.meta || {}, false);
    // Swap bounding-box dimensions (width â†” height, anchor stays at q1,r1)
    selFloat.q2 = selFloat.q1 + H - 1;
    selFloat.r2 = selFloat.r1 + W - 1;
    renderBuildCanvas();
}

/** Rotate the stamp (paint mode) or the active floating selection. */
function rotateStampOrSelection(dir) {
    if (activeTool === 'select' && selFloat) rotateSelection(dir);
    else rotateStamp(dir);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TOOL / LAYER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function setTool(t) {
    if (activeTool === 'select' && t !== 'select') commitSelection();
    activeTool = t;
    document.querySelectorAll('#tool-btns .tool-btn').forEach(b => b.classList.remove('active'));
    document.getElementById('tool-' + t)?.classList.add('active');
    const cvs = document.getElementById('build-canvas');
    cvs.style.cursor = t === 'erase' ? 'not-allowed' : t === 'eyedrop' ? 'copy' : 'crosshair';
    // Clear manual pattern selection when switching tools
    _tbrush_selectedPattern = null;
    // Show/hide terrain brush panel + palette overlays
    tbrush_refreshUI();
    _tbrush_updatePaletteOverlays();
}

function setLayer(l) {
    if (editorMode === 'building') {
        activeLayer = l;
    } else {
        activeObjLayer = l;
    }
    updateModeUI();
}

function toggleVis(l) {
    if (editorMode === 'building') {
        if (visibleLayers.has(l)) visibleLayers.delete(l); else visibleLayers.add(l);
    } else {
        if (visibleObjLayers.has(l)) visibleObjLayers.delete(l); else visibleObjLayers.add(l);
    }
    updateModeUI();
    renderBuildCanvas();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GRID RESIZE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function resizeGrid() {
    const nw = Math.max(1, Math.min(64, parseInt(document.getElementById('grid-w').value) || gridW));
    const nh = Math.max(1, Math.min(64, parseInt(document.getElementById('grid-h').value) || gridH));
    if (!confirm(`Resize to ${nw}Ã—${nh}? Tiles outside the new bounds will be removed.`)) return;
    pushUndo();
    gridW = nw; gridH = nh;
    const clipStore = store => { for (const key of Object.keys(store)) { const [q, r] = key.split(',').map(Number); if (q >= gridW || r >= gridH) delete store[key]; } };
    if (editorMode === 'building') { for (const lyr of Object.values(layers)) clipStore(lyr); }
    else { for (const lyr of Object.values(objLayers)) clipStore(lyr); }
    clipStore(meta);
    fitCanvas();
}

function autofitGrid() {
    // Collect every occupied cell key across all relevant stores
    const keys = new Set();
    if (editorMode === 'building') {
        for (const lyr of Object.values(layers))
            for (const k of Object.keys(lyr)) keys.add(k);
    } else {
        for (const lyr of Object.values(objLayers))
            for (const k of Object.keys(lyr)) keys.add(k);
    }
    for (const k of Object.keys(meta)) keys.add(k);

    if (!keys.size) { alert('Nothing on the canvas to fit.'); return; }

    let minQ = Infinity, minR = Infinity, maxQ = -Infinity, maxR = -Infinity;
    for (const k of keys) {
        const [q, r] = k.split(',').map(Number);
        if (q < minQ) minQ = q;
        if (q > maxQ) maxQ = q;
        if (r < minR) minR = r;
        if (r > maxR) maxR = r;
    }

    // Tight fit â€” no padding
    const newMinQ = minQ;
    const newMinR = minR;
    const newW = maxQ - minQ + 1;
    const newH = maxR - minR + 1;

    if (newW === gridW && newH === gridH && newMinQ === 0 && newMinR === 0) {
        alert('Grid already fits the content.'); return;
    }

    pushUndo();

    // Shift all tiles so that newMinQ,newMinR becomes 0,0
    const shiftStore = store => {
        const entries = Object.entries(store);
        for (const [k] of entries) delete store[k];
        for (const [k, v] of entries) {
            const [q, r] = k.split(',').map(Number);
            store[`${q - newMinQ},${r - newMinR}`] = v;
        }
    };
    if (editorMode === 'building') {
        for (const lyr of Object.values(layers)) shiftStore(lyr);
    } else {
        for (const lyr of Object.values(objLayers)) shiftStore(lyr);
        // Also shift the explicit origin point if set
        if (_objOriginQ != null) {
            _objOriginQ -= newMinQ;
            _objOriginR -= newMinR;
        }
    }
    shiftStore(meta);

    gridW = newW; gridH = newH;
    document.getElementById('grid-w').value = gridW;
    document.getElementById('grid-h').value = gridH;
    fitCanvas();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BUILD CANVAS â€” setup
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function initBuildCanvas() {
    const cvs = document.getElementById('build-canvas');
    cvs.addEventListener('mousedown', onCanvasDown);
    cvs.addEventListener('mousemove', onCanvasMove);
    cvs.addEventListener('mouseup',   onCanvasUp);
    cvs.addEventListener('mouseleave',onCanvasUp);
    cvs.addEventListener('wheel',     onCanvasWheel, { passive:false });
    cvs.addEventListener('contextmenu', e => e.preventDefault());
    fitCanvas();
}

function fitCanvas() {
    const wrap = document.getElementById('canvas-wrap');
    const r = wrap.getBoundingClientRect();
    const fitZoom = Math.min((r.width-40)/(gridW*TILE), (r.height-40)/(gridH*TILE));
    canvasZoom = Math.max(0.5, Math.min(8, fitZoom));
    document.getElementById('zoom-badge').textContent = Math.round(canvasZoom*100)+'%';
    panX = Math.round((r.width - gridW*TILE*canvasZoom)/2);
    panY = Math.round((r.height - gridH*TILE*canvasZoom)/2);
    renderBuildCanvas();
}

function zoomCanvas(dir) {
    const steps = [0.25,0.5,0.75,1,1.5,2,3,4,6,8];
    let idx = steps.findIndex(s => s >= canvasZoom - 0.01);
    if (idx < 0) idx = steps.length-1;
    idx = Math.max(0, Math.min(steps.length-1, idx + dir));
    const wrap = document.getElementById('canvas-wrap'), r = wrap.getBoundingClientRect();
    const cx = r.width/2, cy = r.height/2, prev = canvasZoom;
    canvasZoom = steps[idx];
    panX = Math.round(cx - (cx-panX)*(canvasZoom/prev));
    panY = Math.round(cy - (cy-panY)*(canvasZoom/prev));
    document.getElementById('zoom-badge').textContent = Math.round(canvasZoom*100)+'%';
    renderBuildCanvas();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BUILD CANVAS â€” render
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawTiles(ctx, store, ds) {
    for (const [key, cell] of Object.entries(store)) {
        const [q, r2] = key.split(',').map(Number);
        const x = Math.floor(panX + q*ds), y = Math.floor(panY + r2*ds);
        const img = imgCache.get(cell.sheetPath);
        if (!img || !img.complete) continue;
        const cds = Math.ceil(ds);
        if (cell.rotation) {
            ctx.save();
            ctx.translate(x + cds/2, y + cds/2);
            ctx.rotate(cell.rotation * Math.PI / 180);
            ctx.drawImage(img, cell.sx, cell.sy, cell.sw, cell.sh, -cds/2, -cds/2, cds, cds);
            ctx.restore();
        } else {
            ctx.drawImage(img, cell.sx, cell.sy, cell.sw, cell.sh, x, y, cds, cds);
        }
    }
}

function drawTilesWithOffset(ctx, store, offset, ds) {
    for (const [key, cell] of Object.entries(store)) {
        const [oq, or_] = key.split(',').map(Number);
        const nq = oq+offset.dq, nr = or_+offset.dr;
        const x = Math.floor(panX + nq*ds), y = Math.floor(panY + nr*ds);
        const img = imgCache.get(cell.sheetPath);
        if (!img || !img.complete) continue;
        const cds = Math.ceil(ds);
        if (cell.rotation) {
            ctx.save();
            ctx.translate(x + cds/2, y + cds/2);
            ctx.rotate(cell.rotation * Math.PI / 180);
            ctx.drawImage(img, cell.sx, cell.sy, cell.sw, cell.sh, -cds/2, -cds/2, cds, cds);
            ctx.restore();
        } else {
            ctx.drawImage(img, cell.sx, cell.sy, cell.sw, cell.sh, x, y, cds, cds);
        }
    }
}

function renderBuildCanvas() {
    const wrap = document.getElementById('canvas-wrap');
    const cvs  = document.getElementById('build-canvas');
    const r = wrap.getBoundingClientRect();
    if (!r.width || !r.height) return;
    cvs.width = r.width; cvs.height = r.height;
    cvs.style.width = r.width+'px'; cvs.style.height = r.height+'px';
    const ctx = cvs.getContext('2d');
    ctx.clearRect(0,0,cvs.width,cvs.height);
    ctx.imageSmoothingEnabled = false;
    const ds = Math.round(TILE * canvasZoom);

    // Grid background + checkerboard
    ctx.fillStyle = '#0a1018';
    ctx.fillRect(panX, panY, gridW*ds, gridH*ds);
    for (let r2=0; r2<gridH; r2++) for (let q=0; q<gridW; q++) {
        ctx.fillStyle = (q+r2)%2===0 ? '#101820' : '#0c141c';
        ctx.fillRect(Math.floor(panX+q*ds), Math.floor(panY+r2*ds), Math.ceil(ds), Math.ceil(ds));
    }

    // â”€â”€ Draw tiles â”€â”€
    if (editorMode === 'building') {
        for (const lyrName of ['floor','walls','roof','overlay']) {
            if (!visibleLayers.has(lyrName)) continue;
            drawTiles(ctx, layers[lyrName], ds);
        }
    } else {
        for (const lyrName of ['base','detail','top']) {
            if (!visibleObjLayers.has(lyrName)) continue;
            drawTiles(ctx, objLayers[lyrName], ds);
        }
    }

    // â”€â”€ Meta overlays â”€â”€
    for (const [key, m] of Object.entries(meta)) {
        const [q, r2] = key.split(',').map(Number);
        const x = Math.floor(panX+q*ds), y = Math.floor(panY+r2*ds);
        if (m.impassable) {
            ctx.fillStyle = 'rgba(248,81,73,0.3)'; ctx.fillRect(x,y,Math.ceil(ds),Math.ceil(ds));
            if (ds >= 14) { ctx.font = `${Math.min(ds*0.5,18)}px serif`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.globalAlpha=0.7; ctx.fillText('â›”',x+ds/2,y+ds/2); ctx.globalAlpha=1; }
        }
        if (editorMode === 'building' && m.door) {
            ctx.fillStyle = 'rgba(63,185,80,0.3)'; ctx.fillRect(x,y,Math.ceil(ds),Math.ceil(ds));
            if (ds >= 14) { ctx.font = `${Math.min(ds*0.5,18)}px serif`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.globalAlpha=0.8; ctx.fillText('ğŸšª',x+ds/2,y+ds/2); ctx.globalAlpha=1; }
        }
        if (editorMode === 'object' && m.interactionPoint) {
            ctx.fillStyle = 'rgba(88,166,255,0.3)'; ctx.fillRect(x,y,Math.ceil(ds),Math.ceil(ds));
            if (ds >= 14) { ctx.font = `${Math.min(ds*0.5,18)}px serif`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.globalAlpha=0.8; ctx.fillText('ğŸ¯',x+ds/2,y+ds/2); ctx.globalAlpha=1; }
        }
    }

    // â”€â”€ Grid lines â”€â”€
    ctx.strokeStyle = 'rgba(255,255,255,0.12)'; ctx.lineWidth = 0.5;
    for (let q=0; q<=gridW; q++) { const x=Math.floor(panX+q*ds)+0.5; ctx.beginPath(); ctx.moveTo(x,panY); ctx.lineTo(x,panY+gridH*ds); ctx.stroke(); }
    for (let r2=0; r2<=gridH; r2++) { const y=Math.floor(panY+r2*ds)+0.5; ctx.beginPath(); ctx.moveTo(panX,y); ctx.lineTo(panX+gridW*ds,y); ctx.stroke(); }

    // Outer border
    ctx.strokeStyle='#30363d'; ctx.lineWidth=1;
    ctx.strokeRect(Math.floor(panX),Math.floor(panY),Math.ceil(gridW*ds),Math.ceil(gridH*ds));

    // Tile coords
    if (ds >= 40) {
        ctx.fillStyle='rgba(255,255,255,0.2)'; ctx.font=`${Math.min(9,ds*0.22)}px monospace`; ctx.textAlign='left'; ctx.textBaseline='top';
        for (let r2=0; r2<gridH; r2++) for (let q=0; q<gridW; q++)
            ctx.fillText(`${q},${r2}`, Math.floor(panX+q*ds)+1, Math.floor(panY+r2*ds)+1);
    }

    // â”€â”€ Origin marker â”€â”€
    {
        // Resolve the effective origin (explicit or implicit top-left of painted tiles)
        let oq, or_;
        if (editorMode === 'object') {
            oq = _objOriginQ; or_ = _objOriginR;
            if (oq == null) {
                let minOQ = Infinity, minOR = Infinity;
                for (const ln of ['base','detail','top']) {
                    for (const k of Object.keys(objLayers[ln])) {
                        const [cq, cr] = k.split(',').map(Number);
                        if (cq < minOQ) minOQ = cq;
                        if (cr < minOR) minOR = cr;
                    }
                }
                if (minOQ !== Infinity) { oq = minOQ; or_ = minOR; }
            }
        } else {
            oq = _bldOriginQ; or_ = _bldOriginR;
            if (oq == null) {
                let minOQ = Infinity, minOR = Infinity;
                for (const lyr of Object.values(layers)) {
                    for (const k of Object.keys(lyr)) {
                        const [cq, cr] = k.split(',').map(Number);
                        if (cq < minOQ) minOQ = cq;
                        if (cr < minOR) minOR = cr;
                    }
                }
                if (minOQ !== Infinity) { oq = minOQ; or_ = minOR; }
            }
        }
        if (oq != null) {
            const ox = Math.floor(panX + oq * ds), oy2 = Math.floor(panY + or_ * ds), sz = Math.ceil(ds);
            ctx.fillStyle = 'rgba(255,100,200,0.22)';
            ctx.fillRect(ox, oy2, sz, sz);
            ctx.strokeStyle = '#ff64c8'; ctx.lineWidth = Math.max(1.5, ds * 0.06);
            ctx.strokeRect(ox + ctx.lineWidth/2, oy2 + ctx.lineWidth/2,
                           sz - ctx.lineWidth, sz - ctx.lineWidth);
            if (ds >= 16) {
                ctx.fillStyle = '#ff64c8';
                ctx.font = `bold ${Math.min(10, ds * 0.28)}px sans-serif`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                const isExplicit = editorMode === 'object' ? _objOriginQ != null : _bldOriginQ != null;
                const label = isExplicit ? 'ğŸ“Œ origin' : 'ğŸ“Œ auto';
                ctx.fillText(label, ox + sz / 2, oy2 + sz / 2);
            }
        }
    }

    // â”€â”€ Selection overlay â”€â”€
    if (activeTool === 'select') {
        if (selFloat) {
            ctx.globalAlpha = 0.82;
            if (editorMode === 'building') {
                for (const ln of ['floor','walls','roof','overlay']) {
                    if (!visibleLayers.has(ln)) continue;
                    drawTilesWithOffset(ctx, selFloat[ln] || {}, selOffset, ds);
                }
            } else {
                drawTilesWithOffset(ctx, selFloat.tiles || {}, selOffset, ds);
            }
            ctx.globalAlpha = 1;
            const fq1 = selFloat.q1+selOffset.dq, fr1 = selFloat.r1+selOffset.dr;
            const fq2 = selFloat.q2+selOffset.dq, fr2 = selFloat.r2+selOffset.dr;
            const fx = Math.floor(panX+fq1*ds), fy = Math.floor(panY+fr1*ds);
            const fw = Math.ceil((fq2-fq1+1)*ds), fh = Math.ceil((fr2-fr1+1)*ds);
            ctx.strokeStyle='#58a6ff'; ctx.lineWidth=1.5;
            ctx.setLineDash([5,3]); ctx.strokeRect(fx+0.5,fy+0.5,fw-1,fh-1); ctx.setLineDash([]);
            ctx.fillStyle='#58a6ff';
            for (const [hx,hy] of [[fx,fy],[fx+fw,fy],[fx,fy+fh],[fx+fw,fy+fh]]) ctx.fillRect(hx-3,hy-3,6,6);
        }
        if (selDrawing && selRect) {
            const norm = getNormalizedSelRect();
            const rx=Math.floor(panX+norm.q1*ds), ry=Math.floor(panY+norm.r1*ds);
            const rw=Math.ceil((norm.q2-norm.q1+1)*ds), rh=Math.ceil((norm.r2-norm.r1+1)*ds);
            ctx.fillStyle='rgba(88,166,255,0.1)'; ctx.fillRect(rx,ry,rw,rh);
            ctx.strokeStyle='#58a6ff'; ctx.lineWidth=1; ctx.setLineDash([4,3]); ctx.strokeRect(rx+0.5,ry+0.5,rw-1,rh-1); ctx.setLineDash([]);
        }
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BUILD CANVAS â€” events
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function screenToTile(sx, sy) {
    const ds = TILE*canvasZoom;
    const q = Math.floor((sx-panX)/ds), r = Math.floor((sy-panY)/ds);
    return { q, r, valid: q>=0 && q<gridW && r>=0 && r<gridH };
}
function screenToTileRaw(sx, sy) {
    const ds = TILE*canvasZoom;
    return { q: Math.floor((sx-panX)/ds), r: Math.floor((sy-panY)/ds) };
}
function canvasRect() { return document.getElementById('build-canvas').getBoundingClientRect(); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UNDO / REDO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function snapshotState() {
    if (editorMode === 'building') return JSON.stringify({ m:'b', layers, meta, gridW, gridH });
    return JSON.stringify({ m:'o', objLayers, meta, gridW, gridH });
}
function pushUndo() { undoStack.push(snapshotState()); if (undoStack.length>50) undoStack.shift(); redoStack = []; }
function applySnapshot(snap) {
    selFloat=null; selRect=null; selOffset={dq:0,dr:0}; selDrawing=selMoving=false; selMoveAnchor=null;
    const s = JSON.parse(snap);
    gridW = s.gridW; gridH = s.gridH; meta = s.meta;
    if (s.m === 'b') layers = s.layers;
    else if (s.objLayers) objLayers = s.objLayers;
    else if (s.tiles) objLayers = { base: s.tiles, detail:{}, top:{} }; // legacy compat
    document.getElementById('grid-w').value = gridW;
    document.getElementById('grid-h').value = gridH;
    renderBuildCanvas();
}
function undo() { if (!undoStack.length) return; redoStack.push(snapshotState()); applySnapshot(undoStack.pop()); }
function redo() { if (!redoStack.length) return; undoStack.push(snapshotState()); applySnapshot(redoStack.pop()); }

function getNormalizedSelRect() {
    if (!selRect) return null;
    return { q1: Math.min(selRect.q1,selRect.q2), r1: Math.min(selRect.r1,selRect.r2),
             q2: Math.max(selRect.q1,selRect.q2), r2: Math.max(selRect.r1,selRect.r2) };
}

function commitSelection() {
    if (!selFloat) { selRect=null; selDrawing=false; renderBuildCanvas(); return; }
    const placeTile = (store, floatStore) => {
        for (const [key, cell] of Object.entries(floatStore || {})) {
            const [q, r] = key.split(',').map(Number);
            const nq = q+selOffset.dq, nr = r+selOffset.dr;
            if (nq>=0 && nq<gridW && nr>=0 && nr<gridH) store[`${nq},${nr}`] = cell;
        }
    };
    if (editorMode === 'building') {
        for (const ln of ['floor','walls','roof','overlay']) placeTile(layers[ln], selFloat[ln]);
    } else {
        for (const ln of ['base','detail','top']) placeTile(objLayers[ln], selFloat[ln]);
    }
    for (const [key, m] of Object.entries(selFloat.meta || {})) {
        const [q, r] = key.split(',').map(Number);
        const nq = q+selOffset.dq, nr = r+selOffset.dr;
        if (nq>=0 && nq<gridW && nr>=0 && nr<gridH) meta[`${nq},${nr}`] = m;
    }
    selFloat=null; selRect=null; selOffset={dq:0,dr:0}; selDrawing=selMoving=false; selMoveAnchor=null;
    renderBuildCanvas();
}

function cancelSelection() {
    if (selFloat) {
        if (editorMode === 'building') {
            for (const ln of ['floor','walls','roof','overlay'])
                for (const [key, cell] of Object.entries(selFloat[ln] || {})) layers[ln][key] = cell;
        } else {
            for (const ln of ['base','detail','top'])
                for (const [key, cell] of Object.entries(selFloat[ln] || {})) objLayers[ln][key] = cell;
        }
        for (const [key, m] of Object.entries(selFloat.meta || {})) meta[key] = m;
    }
    selFloat=null; selRect=null; selOffset={dq:0,dr:0}; selDrawing=selMoving=false; selMoveAnchor=null;
    renderBuildCanvas();
}

function onCanvasDown(e) {
    e.preventDefault();
    const rect = canvasRect();
    const sx = e.clientX-rect.left, sy = e.clientY-rect.top;
    if (e.button===1 || e.button===2 || (e.button===0 && e.altKey)) {
        isPanning = true; panStart = { x:sx-panX, y:sy-panY };
        document.getElementById('build-canvas').style.cursor = 'grabbing'; return;
    }
    if (activeTool === 'select') {
        const { q, r } = screenToTileRaw(sx,sy);
        const cq = Math.max(0,Math.min(gridW-1,q)), cr = Math.max(0,Math.min(gridH-1,r));
        if (selFloat) {
            const fq1=selFloat.q1+selOffset.dq, fr1=selFloat.r1+selOffset.dr;
            const fq2=selFloat.q2+selOffset.dq, fr2=selFloat.r2+selOffset.dr;
            if (cq>=fq1 && cq<=fq2 && cr>=fr1 && cr<=fr2) {
                selMoving=true; selMoveAnchor={q:cq,r:cr};
                document.getElementById('build-canvas').style.cursor='move'; return;
            } else { commitSelection(); }
        }
        pushUndo(); selDrawing=true; selRect={q1:cq,r1:cr,q2:cq,r2:cr}; isDragging=true; return;
    }
    if (selFloat) commitSelection();
    isDragging = true; pushUndo(); applyTool(sx,sy);
}

function onCanvasMove(e) {
    const rect = canvasRect();
    const sx = e.clientX-rect.left, sy = e.clientY-rect.top;
    if (isPanning) { panX=sx-panStart.x; panY=sy-panStart.y; renderBuildCanvas(); return; }
    if (activeTool === 'select') {
        const { q, r } = screenToTileRaw(sx,sy);
        const cq = Math.max(0,Math.min(gridW-1,q)), cr = Math.max(0,Math.min(gridH-1,r));
        if (selDrawing) { selRect.q2=cq; selRect.r2=cr; renderBuildCanvas(); }
        else if (selMoving && selMoveAnchor) { selOffset.dq=cq-selMoveAnchor.q; selOffset.dr=cr-selMoveAnchor.r; renderBuildCanvas(); }
        else if (selFloat) {
            const fq1=selFloat.q1+selOffset.dq, fr1=selFloat.r1+selOffset.dr, fq2=selFloat.q2+selOffset.dq, fr2=selFloat.r2+selOffset.dr;
            document.getElementById('build-canvas').style.cursor = (cq>=fq1&&cq<=fq2&&cr>=fr1&&cr<=fr2)?'move':'crosshair';
        }
        return;
    }
    if (isDragging) applyTool(sx,sy);
}

function onCanvasUp(e) {
    if (activeTool === 'select' && selDrawing) {
        selDrawing=false; isDragging=false;
        const norm = getNormalizedSelRect();
        if (norm) {
            const floatMeta = {};
            const liftTiles = (store) => {
                const lifted = {};
                for (let r2=norm.r1; r2<=norm.r2; r2++) for (let q=norm.q1; q<=norm.q2; q++) {
                    const key = `${q},${r2}`;
                    if (store[key]) { lifted[key] = store[key]; delete store[key]; }
                }
                return lifted;
            };
            for (let r2=norm.r1; r2<=norm.r2; r2++) for (let q=norm.q1; q<=norm.q2; q++) {
                const key = `${q},${r2}`;
                if (meta[key]) { floatMeta[key] = meta[key]; delete meta[key]; }
            }
            if (editorMode === 'building') {
                selFloat = { floor: liftTiles(layers.floor), walls: liftTiles(layers.walls),
                             roof: liftTiles(layers.roof), overlay: liftTiles(layers.overlay),
                             meta: floatMeta, q1:norm.q1, r1:norm.r1, q2:norm.q2, r2:norm.r2 };
            } else {
                selFloat = { base: liftTiles(objLayers.base), detail: liftTiles(objLayers.detail),
                             top: liftTiles(objLayers.top), meta: floatMeta,
                             q1:norm.q1, r1:norm.r1, q2:norm.q2, r2:norm.r2 };
            }
            selOffset = { dq:0, dr:0 };
        } else { selRect=null; }
        renderBuildCanvas(); return;
    }
    if (selMoving) { selMoving=false; selMoveAnchor=null; document.getElementById('build-canvas').style.cursor='move'; return; }
    isDragging=false; isPanning=false; panStart=null;
    document.getElementById('build-canvas').style.cursor = activeTool==='erase'?'not-allowed':activeTool==='eyedrop'?'copy':'crosshair';
}

function onCanvasWheel(e) {
    e.preventDefault();
    const rect = canvasRect(), sx=e.clientX-rect.left, sy=e.clientY-rect.top;
    const factor = e.deltaY>0 ? 0.85 : 1.18, prev = canvasZoom;
    canvasZoom = Math.max(0.5,Math.min(8,canvasZoom*factor));
    panX = Math.round(sx-(sx-panX)*(canvasZoom/prev)); panY = Math.round(sy-(sy-panY)*(canvasZoom/prev));
    document.getElementById('zoom-badge').textContent = Math.round(canvasZoom*100)+'%';
    renderBuildCanvas();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  APPLY TOOL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function applyTool(sx, sy) {
    const { q, r, valid } = screenToTile(sx,sy);
    if (!valid) return;
    const key = `${q},${r}`;
    const store = getTileStore();

    if (activeTool === 'paint') {
        if (!activeStamp) return;
        let needLoad = !imgCache.has(activeStamp.sheetPath);
        for (const t of activeStamp.tiles) {
            const tq = q+t.localCol, tr = r+t.localRow;
            if (tq<0 || tq>=gridW || tr<0 || tr>=gridH) continue;
            const cell = { sheetPath: activeStamp.sheetPath, sx: t.sx, sy: t.sy, sw: TILE, sh: TILE };
            if (t.rotation) cell.rotation = t.rotation;
            store[`${tq},${tr}`] = cell;
        }
        if (needLoad) loadImage(activeStamp.sheetPath).then(() => renderBuildCanvas());
        else renderBuildCanvas();
    } else if (activeTool === 'erase') {
        delete store[key];
        renderBuildCanvas();
    } else if (activeTool === 'fill') {
        if (!activeStamp) return;
        floodFill(q, r);
    } else if (activeTool === 'eyedrop') {
        if (editorMode === 'building') {
            for (const lyr of ['overlay','roof','walls','floor']) {
                if (visibleLayers.has(lyr) && layers[lyr][key]) {
                    const c = layers[lyr][key];
                    setStamp(c.sheetPath, Math.round(c.sx/TILE), Math.round(c.sy/TILE), Math.round(c.sx/TILE), Math.round(c.sy/TILE), c.sheetPath.split('/').pop().replace(/\.[^.]+$/,''));
                    break;
                }
            }
        } else {
            for (const lyr of ['top','detail','base']) {
                if (visibleObjLayers.has(lyr) && objLayers[lyr][key]) {
                    const c = objLayers[lyr][key];
                    setStamp(c.sheetPath, Math.round(c.sx/TILE), Math.round(c.sy/TILE), Math.round(c.sx/TILE), Math.round(c.sy/TILE), c.sheetPath.split('/').pop().replace(/\.[^.]+$/,''));
                    break;
                }
            }
        }
        setTool('paint');
    } else if (activeTool === 'impass') {
        if (!meta[key]) meta[key] = {};
        meta[key].impassable = !meta[key].impassable;
        const hasAny = meta[key].impassable || meta[key].door || meta[key].interactionPoint;
        if (!hasAny) delete meta[key];
        renderBuildCanvas();
    } else if (activeTool === 'marker') {
        if (editorMode === 'building') {
            // Door: clear all others, set this one
            for (const k of Object.keys(meta)) { if (meta[k]) meta[k].door = false; }
            if (!meta[key]) meta[key] = {};
            meta[key].door = true;
        } else {
            // Interaction point: toggle
            if (!meta[key]) meta[key] = {};
            meta[key].interactionPoint = !meta[key].interactionPoint;
            if (!meta[key].impassable && !meta[key].interactionPoint) delete meta[key];
        }
        renderBuildCanvas();
    } else if (activeTool === 'origin') {
        if (editorMode === 'object') {
            // Toggle: clicking the same cell again clears the explicit origin
            if (_objOriginQ === q && _objOriginR === r) {
                _objOriginQ = null; _objOriginR = null;
            } else {
                _objOriginQ = q; _objOriginR = r;
            }
            renderBuildCanvas();
        } else if (editorMode === 'building') {
            if (_bldOriginQ === q && _bldOriginR === r) {
                _bldOriginQ = null; _bldOriginR = null;
            } else {
                _bldOriginQ = q; _bldOriginR = r;
            }
            renderBuildCanvas();
        }
    } else if (activeTool === 'tbrush') {
        // Terrain Brush â€” auto-tile using the selected terrain set
        if (_tbrush_selSet >= 0 && _tbrush_selTerrain >= 0) {
            const tset = _tbrush_sets[_tbrush_selSet];
            _tb_paint(q, r, _tbrush_selTerrain, tset);
            renderBuildCanvas();
        }
    }
}

function floodFill(startQ, startR) {
    if (!activeStamp) return;
    const sW = activeStamp.stampCols, sH = activeStamp.stampRows;
    const store = getTileStore();
    const target = store[`${startQ},${startR}`];
    const sameCell = c => { if (!c && !target) return true; if (!c || !target) return false; return c.sheetPath===target.sheetPath && c.sx===target.sx && c.sy===target.sy; };
    const anchorTile = activeStamp.tiles[0];
    if (target && target.sheetPath===activeStamp.sheetPath && target.sx===anchorTile.sx && target.sy===anchorTile.sy) return;
    const visited = new Set(), queue = [[startQ,startR]];
    while (queue.length) {
        const [q, r] = queue.shift();
        if (q<0||q>=gridW||r<0||r>=gridH) continue;
        const k = `${q},${r}`;
        if (visited.has(k)) continue;
        visited.add(k);
        if (!sameCell(store[k])) continue;
        const dc = ((q-startQ)%sW+sW)%sW, dr = ((r-startR)%sH+sH)%sH;
        const t = activeStamp.tiles[dr*sW+dc];
        store[k] = { sheetPath: activeStamp.sheetPath, sx: t.sx, sy: t.sy, sw: TILE, sh: TILE };
        for (const [dq, drr] of [[1,0],[-1,0],[0,1],[0,-1]]) queue.push([q+dq, r+drr]);
    }
    if (!imgCache.has(activeStamp.sheetPath)) loadImage(activeStamp.sheetPath).then(() => renderBuildCanvas());
    else renderBuildCanvas();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  IMAGE CACHE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function loadImage(path) {
    if (imgCache.has(path)) return Promise.resolve(imgCache.get(path));
    return new Promise(resolve => {
        const img = new Image();
        img.onload  = () => { imgCache.set(path, img); resolve(img); };
        img.onerror = () => { imgCache.set(path, null); resolve(null); };
        img.src = path;
    });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BUILDING MANAGEMENT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function newBuilding() {
    clearAll(true);
    buildingEditIdx = -1;
    _bldOriginQ = null; _bldOriginR = null;
    document.getElementById('bld-name').value = '';
    document.getElementById('bld-type').value = 'house';
    document.getElementById('bld-tags').value = '';
}

function saveBuilding() {
    const name = document.getElementById('bld-name').value.trim();
    if (!name) { alert('Enter a building name.'); document.getElementById('bld-name').focus(); return; }
    const b = {
        id: slugify(name), name,
        buildingType: document.getElementById('bld-type').value,
        tags: document.getElementById('bld-tags').value.trim().split(',').map(s=>s.trim()).filter(Boolean),
        tileW: TILE, tileH: TILE, width: gridW, height: gridH,
        layers: { floor:{...layers.floor}, walls:{...layers.walls}, roof:{...layers.roof}, overlay:{...layers.overlay} },
        meta: { ...meta },
        originQ: _bldOriginQ != null ? _bldOriginQ : undefined,
        originR: _bldOriginR != null ? _bldOriginR : undefined,
    };
    if (buildingEditIdx >= 0) buildings[buildingEditIdx] = b;
    else { buildings.push(b); buildingEditIdx = buildings.length-1; }
    refreshBuildingList();
}

function loadBuilding(index) {
    const b = buildings[index];
    buildingEditIdx = index;
    gridW = b.width; gridH = b.height;
    document.getElementById('grid-w').value = gridW;
    document.getElementById('grid-h').value = gridH;
    document.getElementById('bld-name').value = b.name;
    document.getElementById('bld-type').value = b.buildingType || 'house';
    document.getElementById('bld-tags').value = (b.tags||[]).join(', ');
    _bldOriginQ = b.originQ != null ? b.originQ : null;
    _bldOriginR = b.originR != null ? b.originR : null;
    layers.floor = {...b.layers.floor}; layers.walls = {...b.layers.walls};
    layers.roof = {...b.layers.roof}; layers.overlay = {...b.layers.overlay};
    meta = { ...b.meta };
    const paths = new Set();
    for (const lyr of Object.values(layers)) for (const c of Object.values(lyr)) paths.add(c.sheetPath);
    Promise.all([...paths].map(loadImage)).then(() => { fitCanvas(); });
}

function deleteBuilding(index) {
    if (!confirm(`Delete "${buildings[index].name}"?`)) return;
    buildings.splice(index, 1);
    if (buildingEditIdx === index) { buildingEditIdx = -1; clearAll(true); }
    else if (buildingEditIdx > index) buildingEditIdx--;
    refreshBuildingList();
}

function refreshBuildingList() {
    const countEl = document.getElementById('cat-bld-count');
    const list = document.getElementById('cat-bld-cards');
    if (countEl) countEl.textContent = buildings.length;
    if (!list) return;
    if (!buildings.length) { list.innerHTML = '<div class="catalog-empty">No buildings saved yet</div>'; return; }
    list.innerHTML = '';
    const range = getCatalogPageRange('building');
    for (let i = range.start; i < range.end; i++) {
        const b = buildings[i];
        const bLayers = b.layers || { floor:{}, walls:{}, roof:{}, overlay:{} };
        const bStores = [bLayers.floor || {}, bLayers.walls || {}, bLayers.roof || {}, bLayers.overlay || {}];
        const bBounds = getLayersOccupiedBounds(bStores);
        const paintedW = bBounds ? (bBounds.maxCol - bBounds.minCol + 1) : Math.max(1, b.width || gridW || 1);
        const paintedH = bBounds ? (bBounds.maxRow - bBounds.minRow + 1) : Math.max(1, b.height || gridH || 1);
        const div = document.createElement('div');
        const thumbId = `cat-bld-thumb-${i}`;
        div.className = 'item-card building-card'; div.style.borderColor = i===buildingEditIdx ? 'var(--gold)' : '';
        div.innerHTML = `<div class="obj-thumb-wrap"><canvas id="${thumbId}" class="obj-thumb" width="64" height="64"></canvas></div>
            <div class="item-main"><div class="item-title">${escHtml(b.name)}</div>
            <div class="item-meta">${b.buildingType} Â· painted ${paintedW}Ã—${paintedH} Â· grid ${b.width}Ã—${b.height}</div>
            <div class="item-acts"><button onclick="loadBuilding(${i});closeCatalog()">âœï¸ Edit</button><button onclick="openInteriorForBuilding(${i});closeCatalog()">ğŸ  Interior</button><button class="danger" onclick="deleteBuilding(${i})">ğŸ—‘</button></div></div>`;
        list.appendChild(div);
        drawCatalogThumbnailFromLayers(document.getElementById(thumbId), bStores, bBounds || {
            minCol: 0,
            minRow: 0,
            maxCol: Math.max(0, (b.width || 1) - 1),
            maxRow: Math.max(0, (b.height || 1) - 1),
        });
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TERRAIN MULTISELECT WIDGET
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const TERRAIN_GROUPS = {
    'Grassland': ['grass','tall_grass','rocks','dirt'],
    'Plains':    ['dry_grass','dirt','rocks','grass'],
    'Woodland':  ['trees','brush','grass','dirt'],
    'Boreal':    ['trees','snow','brush','dirt'],
    'Seasonal Forest':['trees','brush','grass','dirt'],
    'Temp. Rainforest':['trees','brush','mud'],
    'Tropical':  ['trees','brush','grass','mud'],
    'Desert':    ['sand','rocks','dirt'],
    'Savanna':   ['dry_grass','tall_grass','rocks','dirt'],
    'Mountain':  ['rocks','cliff','grass','snow'],
    'Hills':     ['grass','rocks','dirt'],
    'Swamp':     ['bog','mud','trees','grass'],
    'Tundra':    ['snow','dirt','rocks','grass'],
    'Snow':      ['snow','ice','trees','rocks'],
    'Ice':       ['ice','snow','rocks'],
    'Highlands': ['grass','rocks','brush','dirt'],
    'Beach':     ['sand','rocks','grass','dirt'],
    'Island':    ['sand','trees','brush','rocks'],
};

let _selectedTerrains = new Set();

function buildTerrainOptions() {
    const container = document.getElementById('tms-options');
    container.innerHTML = '';
    for (const [group, ids] of Object.entries(TERRAIN_GROUPS)) {
        const g = document.createElement('div'); g.className = 'tms-group';
        const lbl = document.createElement('div'); lbl.className = 'tms-group-label'; lbl.textContent = group;
        g.appendChild(lbl);
        const seen = new Set();
        for (const id of ids) {
            if (seen.has(id)) continue; seen.add(id);
            const opt = document.createElement('label'); opt.className = 'tms-opt'; opt.dataset.id = id;
            const cb = document.createElement('input'); cb.type = 'checkbox'; cb.value = id;
            cb.checked = _selectedTerrains.has(id);
            cb.addEventListener('change', () => { if (cb.checked) _selectedTerrains.add(id); else _selectedTerrains.delete(id); renderTerrainTags(); });
            const span = document.createElement('span'); span.textContent = id.replace(/_/g, ' ');
            opt.appendChild(cb); opt.appendChild(span); g.appendChild(opt);
        }
        container.appendChild(g);
    }
}

function renderTerrainTags() {
    const toggle = document.getElementById('tms-toggle');
    if (!_selectedTerrains.size) {
        toggle.innerHTML = '<span class="placeholder">Click to select terrainsâ€¦</span>';
    } else {
        toggle.innerHTML = [..._selectedTerrains].map(id =>
            `<span class="terrain-ms-tag">${id.replace(/_/g,' ')}<span class="tag-x" onclick="event.stopPropagation();removeTerrainTag('${id}')">&times;</span></span>`
        ).join('');
    }
    // sync checkboxes
    document.querySelectorAll('#tms-options input[type=checkbox]').forEach(cb => { cb.checked = _selectedTerrains.has(cb.value); });
}

function removeTerrainTag(id) { _selectedTerrains.delete(id); renderTerrainTags(); }

function toggleTerrainDropdown() {
    const drop = document.getElementById('tms-drop');
    const isOpen = drop.classList.contains('open');
    if (isOpen) { drop.classList.remove('open'); return; }
    buildTerrainOptions();
    drop.classList.add('open');
    setTimeout(() => document.getElementById('tms-search').focus(), 50);
}

function filterTerrainOptions() {
    const q = document.getElementById('tms-search').value.toLowerCase().replace(/\s+/g,'_');
    document.querySelectorAll('#tms-options .tms-opt').forEach(opt => {
        opt.classList.toggle('hidden', q && !opt.dataset.id.includes(q));
    });
}

// Close dropdown when clicking outside
document.addEventListener('click', e => {
    const ms = document.getElementById('terrain-ms');
    if (ms && !ms.contains(e.target)) document.getElementById('tms-drop').classList.remove('open');
});

function getSelectedTerrains() { return [..._selectedTerrains]; }
function setSelectedTerrains(arr) { _selectedTerrains = new Set(arr || []); renderTerrainTags(); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  HEALTH STATES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function addHealthStateFromCanvas() {
    const allEmpty = ['base','detail','top'].every(ln => Object.keys(objLayers[ln]).length === 0);
    if (allEmpty) {
        alert('Paint tiles on the canvas for this health state first, then capture.');
        return;
    }
    const label  = document.getElementById('hs-label').value.trim() || ('State ' + (_objHealthStates.length + 1));
    const minPct = Math.max(0, Math.min(99, parseInt(document.getElementById('hs-min-hp').value) || 0));
    _objHealthStates.push({ label, minHealthPct: minPct, objLayers: JSON.parse(JSON.stringify(objLayers)) });
    refreshHealthStatesList();
}

function removeHealthState(index) {
    _objHealthStates.splice(index, 1);
    refreshHealthStatesList();
}

function refreshHealthStatesList() {
    const list = document.getElementById('health-states-list');
    if (!list) return;
    if (!_objHealthStates.length) {
        list.innerHTML = '<div style="color:var(--text-dim);font-size:11px;font-style:italic;margin-bottom:2px">No health states defined â€“ object always looks the same.</div>';
        return;
    }
    const sorted = [..._objHealthStates].sort((a, b) => b.minHealthPct - a.minHealthPct);
    list.innerHTML = '';
    for (let i = 0; i < _objHealthStates.length; i++) {
        const hs   = _objHealthStates[i];
        const cnt  = hs.objLayers ? ['base','detail','top'].reduce((s,l) => s + Object.keys(hs.objLayers[l]||{}).length, 0) : Object.keys(hs.tiles||{}).length;
        const div  = document.createElement('div');
        div.style.cssText = 'display:flex;align-items:center;gap:6px;margin:2px 0;font-size:11px;background:rgba(255,255,255,0.04);border-radius:4px;padding:2px 4px';
        div.innerHTML =
            `<span style="color:var(--gold);min-width:32px">\u2265${hs.minHealthPct}%</span>` +
            `<span style="flex:1">${escHtml(hs.label)}</span>` +
            `<span style="color:var(--text-dim)">${cnt}\u00a0tiles</span>` +
            `<button onclick="removeHealthState(${i})" class="danger" style="padding:1px 6px;font-size:10px">\u2715</button>`;
        list.appendChild(div);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SEASON VARIANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function captureSeasonVariant() {
    const allEmpty = ['base','detail','top'].every(ln => Object.keys(objLayers[ln]).length === 0);
    if (allEmpty) {
        alert('Paint tiles on the canvas for this season first, then capture.');
        return;
    }
    const season = document.getElementById('sv-season').value;
    _objSeasonVariants[season] = JSON.parse(JSON.stringify(objLayers));
    refreshSeasonVariantsList();
}

function removeSeasonVariant(season) {
    delete _objSeasonVariants[season];
    refreshSeasonVariantsList();
}

function refreshSeasonVariantsList() {
    const list = document.getElementById('season-variants-list');
    if (!list) return;
    const SEASONS = [
        { key: 'spring', label: 'ğŸŒ¸ Spring' },
        { key: 'summer', label: 'â˜€ï¸ Summer' },
        { key: 'autumn', label: 'ğŸ‚ Autumn' },
        { key: 'winter', label: 'â„ï¸ Winter' },
    ];
    const defined = SEASONS.filter(s => _objSeasonVariants[s.key]);
    if (!defined.length) {
        list.innerHTML = '<div style="color:var(--text-dim);font-size:11px;font-style:italic;margin-bottom:2px">No season variants â€” same look all year.</div>';
        return;
    }
    list.innerHTML = '';
    for (const s of defined) {
        const sv = _objSeasonVariants[s.key];
        const cnt = sv && sv.base !== undefined ? ['base','detail','top'].reduce((sum,l) => sum + Object.keys(sv[l]||{}).length, 0) : Object.keys(sv||{}).length;
        const div = document.createElement('div');
        div.style.cssText = 'display:flex;align-items:center;gap:6px;margin:2px 0;font-size:11px;background:rgba(255,255,255,0.04);border-radius:4px;padding:2px 4px';
        div.innerHTML =
            `<span style="min-width:62px">${s.label}</span>` +
            `<span style="flex:1;color:var(--text-dim)">${cnt}Â tile${cnt!==1?'s':''}</span>` +
            `<button onclick="loadSeasonVariantToCanvas('${s.key}')" style="font-size:10px;padding:1px 5px" title="Load this season's tiles back onto the canvas">ğŸ‘</button>` +
            `<button onclick="removeSeasonVariant('${s.key}')" class="danger" style="padding:1px 6px;font-size:10px">âœ•</button>`;
        list.appendChild(div);
    }
}

/** Load a saved season variant back onto the canvas (for editing). */
function loadSeasonVariantToCanvas(season) {
    const stiles = _objSeasonVariants[season];
    if (!stiles) return;
    pushUndo();
    // Support new multi-layer format and legacy single-layer
    if (stiles.base !== undefined) {
        objLayers = JSON.parse(JSON.stringify(stiles));
    } else {
        objLayers = { base: JSON.parse(JSON.stringify(stiles)), detail: {}, top: {} };
    }
    const paths = new Set();
    for (const ln of ['base','detail','top']) for (const c of Object.values(objLayers[ln])) paths.add(c.sheetPath);
    Promise.all([...paths].map(loadImage)).then(() => renderBuildCanvas());
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GROWTH STATES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function addGrowthStateFromCanvas() {
    const allEmpty = ['base','detail','top'].every(ln => Object.keys(objLayers[ln]).length === 0);
    if (allEmpty) {
        alert('Paint tiles on the canvas for this growth stage first, then capture.');
        return;
    }
    const label = document.getElementById('gs-label').value.trim() || ('Stage ' + (_objGrowthStates.length + 1));
    const daysToReach = Math.max(0, parseInt(document.getElementById('gs-days').value) || 0);
    // Replace any existing stage at the same day threshold
    const existing = _objGrowthStates.findIndex(gs => gs.daysToReach === daysToReach);
    const entry = { label, daysToReach, objLayers: JSON.parse(JSON.stringify(objLayers)) };
    if (existing >= 0) _objGrowthStates[existing] = entry;
    else _objGrowthStates.push(entry);
    _objGrowthStates.sort((a, b) => a.daysToReach - b.daysToReach);
    refreshGrowthStatesList();
}

function removeGrowthState(index) {
    _objGrowthStates.splice(index, 1);
    refreshGrowthStatesList();
}

function refreshGrowthStatesList() {
    const list = document.getElementById('growth-states-list');
    if (!list) return;
    if (!_objGrowthStates.length) {
        list.innerHTML = '<div style="color:var(--text-dim);font-size:11px;font-style:italic;margin-bottom:2px">No growth stages â€” object stays the same forever.</div>';
        return;
    }
    list.innerHTML = '';
    for (let i = 0; i < _objGrowthStates.length; i++) {
        const gs = _objGrowthStates[i];
        const cnt = gs.objLayers ? ['base','detail','top'].reduce((s,l) => s + Object.keys(gs.objLayers[l]||{}).length, 0) : Object.keys(gs.tiles||{}).length;
        const div = document.createElement('div');
        div.style.cssText = 'display:flex;align-items:center;gap:6px;margin:2px 0;font-size:11px;background:rgba(255,255,255,0.04);border-radius:4px;padding:2px 4px';
        div.innerHTML =
            `<span style="color:var(--green);min-width:48px">Day\u00a0${gs.daysToReach}</span>` +
            `<span style="flex:1">${escHtml(gs.label)}</span>` +
            `<span style="color:var(--text-dim)">${cnt}\u00a0tile${cnt!==1?'s':''}</span>` +
            `<button onclick="loadGrowthStateToCanvas(${i})" style="font-size:10px;padding:1px 5px" title="Load onto canvas">\uD83D\uDC41</button>` +
            `<button onclick="removeGrowthState(${i})" class="danger" style="padding:1px 6px;font-size:10px">\u2715</button>`;
        list.appendChild(div);
    }
}

/** Load a saved growth stage back onto the canvas (for editing). */
function loadGrowthStateToCanvas(index) {
    const gs = _objGrowthStates[index];
    if (!gs) return;
    pushUndo();
    // Support new multi-layer format and legacy single-layer
    if (gs.objLayers) {
        objLayers = JSON.parse(JSON.stringify(gs.objLayers));
    } else if (gs.tiles) {
        objLayers = { base: JSON.parse(JSON.stringify(gs.tiles)), detail: {}, top: {} };
    }
    const paths = new Set();
    for (const ln of ['base','detail','top']) for (const c of Object.values(objLayers[ln])) paths.add(c.sheetPath);
    Promise.all([...paths].map(loadImage)).then(() => renderBuildCanvas());
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ROTATION VARIANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function addRotationVariantFromCanvas() {
    const allEmpty = ['base','detail','top'].every(ln => Object.keys(objLayers[ln]).length === 0);
    if (allEmpty) {
        alert('Paint tiles on the canvas for this rotation first, then capture.');
        return;
    }
    const label = document.getElementById('rv-label').value.trim() || ('Rotation ' + (_objRotationVariants.length + 1));
    _objRotationVariants.push({
        label,
        objLayers: JSON.parse(JSON.stringify(objLayers)),
        meta: JSON.parse(JSON.stringify(meta)),
        originQ: _objOriginQ,
        originR: _objOriginR,
        gridW: gridW,
        gridH: gridH,
    });
    refreshRotationVariantsList();
}

function removeRotationVariant(index) {
    _objRotationVariants.splice(index, 1);
    refreshRotationVariantsList();
}

/** Re-capture an existing rotation variant from the current canvas state. */
function recaptureRotationVariant(index) {
    const rv = _objRotationVariants[index];
    if (!rv) return;
    const allEmpty = ['base','detail','top'].every(ln => Object.keys(objLayers[ln]).length === 0);
    if (allEmpty) {
        alert('Paint tiles on the canvas first, then re-capture.');
        return;
    }
    rv.objLayers = JSON.parse(JSON.stringify(objLayers));
    rv.meta = JSON.parse(JSON.stringify(meta));
    rv.originQ = _objOriginQ;
    rv.originR = _objOriginR;
    rv.gridW = gridW;
    rv.gridH = gridH;
    refreshRotationVariantsList();
}

function refreshRotationVariantsList() {
    const list = document.getElementById('rotation-variants-list');
    if (!list) return;
    if (!_objRotationVariants.length) {
        list.innerHTML = '<div style="color:var(--text-dim);font-size:11px;font-style:italic;margin-bottom:2px">No rotation variants â€” object has one fixed look.</div>';
        return;
    }
    list.innerHTML = '';
    for (let i = 0; i < _objRotationVariants.length; i++) {
        const rv = _objRotationVariants[i];
        const cnt = rv.objLayers ? ['base','detail','top'].reduce((s,l) => s + Object.keys(rv.objLayers[l]||{}).length, 0) : Object.keys(rv.tiles||{}).length;
        const sizeStr = (rv.gridW != null && rv.gridH != null) ? `${rv.gridW}\u00d7${rv.gridH}` : '';
        const hasOrigin = rv.originQ != null && rv.originR != null;
        const hasMeta = rv.meta && Object.values(rv.meta).some(m => m && m.interactionPoint);
        const badges = [];
        if (sizeStr) badges.push(sizeStr);
        if (hasOrigin) badges.push('\u2316');
        if (hasMeta) badges.push('\uD83C\uDFAF');
        const div = document.createElement('div');
        div.style.cssText = 'display:flex;align-items:center;gap:6px;margin:2px 0;font-size:11px;background:rgba(255,255,255,0.04);border-radius:4px;padding:2px 4px';
        div.innerHTML =
            `<span style="color:var(--blue);min-width:18px">#${i + 1}</span>` +
            `<span style="flex:1">${escHtml(rv.label)}</span>` +
            `<span style="color:var(--text-dim)">${cnt}\u00a0tile${cnt!==1?'s':''}</span>` +
            (badges.length ? `<span style="color:var(--text-dim);font-size:10px" title="Size / Origin / Interact">${badges.join(' ')}</span>` : '') +
            `<button onclick="loadRotationVariantToCanvas(${i})" style="font-size:10px;padding:1px 5px" title="Load onto canvas">\uD83D\uDC41</button>` +
            `<button onclick="recaptureRotationVariant(${i})" style="font-size:10px;padding:1px 5px" title="Re-capture from current canvas">\uD83D\uDD04</button>` +
            `<button onclick="removeRotationVariant(${i})" class="danger" style="padding:1px 6px;font-size:10px">\u2715</button>`;
        list.appendChild(div);
    }
}

/** Load a saved rotation variant back onto the canvas (for editing). */
function loadRotationVariantToCanvas(index) {
    const rv = _objRotationVariants[index];
    if (!rv) return;
    pushUndo();
    const prevGridW = gridW;
    const prevGridH = gridH;
    // Support new multi-layer format and legacy single-layer
    if (rv.objLayers) {
        objLayers = JSON.parse(JSON.stringify(rv.objLayers));
    } else if (rv.tiles) {
        objLayers = { base: JSON.parse(JSON.stringify(rv.tiles)), detail: {}, top: {} };
    }
    // Restore per-variant meta (interaction points, impassable markers)
    if (rv.meta) {
        meta = JSON.parse(JSON.stringify(rv.meta));
    }
    // Restore per-variant origin
    if (rv.originQ != null) _objOriginQ = rv.originQ;
    if (rv.originR != null) _objOriginR = rv.originR;
    // Eye-preview should never resize the canvas.
    gridW = prevGridW;
    gridH = prevGridH;
    document.getElementById('grid-w').value = gridW;
    document.getElementById('grid-h').value = gridH;
    const paths = new Set();
    for (const ln of ['base','detail','top']) for (const c of Object.values(objLayers[ln])) paths.add(c.sheetPath);
    Promise.all([...paths].map(loadImage)).then(() => { fitCanvas(); renderBuildCanvas(); });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  COLOR VARIANTS
//  Complete alternative looks for an object â€” each variant captures
//  the full visual state: tiles, meta, origin, grid, rotations, seasons.
//  Press T to cycle in-game and in the interior editor.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function addColorVariantFromCanvas() {
    const allEmpty = ['base','detail','top'].every(ln => Object.keys(objLayers[ln]).length === 0);
    if (allEmpty) {
        alert('Paint tiles on the canvas for this variant first, then capture.');
        return;
    }
    const label = document.getElementById('cv-label').value.trim() || ('Variant ' + (_objColorVariants.length + 1));
    _objColorVariants.push({
        label,
        objLayers: JSON.parse(JSON.stringify(objLayers)),
        meta: JSON.parse(JSON.stringify(meta)),
        originQ: _objOriginQ,
        originR: _objOriginR,
        gridW: gridW,
        gridH: gridH,
        rotationVariants: JSON.parse(JSON.stringify(_objRotationVariants)),
        seasonVariants: JSON.parse(JSON.stringify(_objSeasonVariants)),
    });
    refreshColorVariantsList();
}

function removeColorVariant(index) {
    _objColorVariants.splice(index, 1);
    refreshColorVariantsList();
}

/** Re-capture an existing color variant from the current canvas state. */
function recaptureColorVariant(index) {
    const cv = _objColorVariants[index];
    if (!cv) return;
    const allEmpty = ['base','detail','top'].every(ln => Object.keys(objLayers[ln]).length === 0);
    if (allEmpty) {
        alert('Paint tiles on the canvas first, then re-capture.');
        return;
    }
    cv.objLayers = JSON.parse(JSON.stringify(objLayers));
    cv.meta = JSON.parse(JSON.stringify(meta));
    cv.originQ = _objOriginQ;
    cv.originR = _objOriginR;
    cv.gridW = gridW;
    cv.gridH = gridH;
    cv.rotationVariants = JSON.parse(JSON.stringify(_objRotationVariants));
    cv.seasonVariants = JSON.parse(JSON.stringify(_objSeasonVariants));
    refreshColorVariantsList();
}

function refreshColorVariantsList() {
    const list = document.getElementById('color-variants-list');
    if (!list) return;
    if (!_objColorVariants.length) {
        list.innerHTML = '<div style="color:var(--text-dim);font-size:11px;font-style:italic;margin-bottom:2px">No color variants â€” object has one fixed look.</div>';
        return;
    }
    list.innerHTML = '';
    for (let i = 0; i < _objColorVariants.length; i++) {
        const cv = _objColorVariants[i];
        const cnt = cv.objLayers ? ['base','detail','top'].reduce((s,l) => s + Object.keys(cv.objLayers[l]||{}).length, 0) : 0;
        const rotCnt = (cv.rotationVariants || []).length;
        const seaCnt = Object.keys(cv.seasonVariants || {}).length;
        const badges = [];
        if (rotCnt) badges.push(rotCnt + ' rot');
        if (seaCnt) badges.push(seaCnt + ' sea');
        const div = document.createElement('div');
        div.style.cssText = 'display:flex;align-items:center;gap:6px;margin:2px 0;font-size:11px;background:rgba(255,255,255,0.04);border-radius:4px;padding:2px 4px';
        div.innerHTML =
            `<span style="color:var(--gold);min-width:18px">#${i + 1}</span>` +
            `<span style="flex:1">${escHtml(cv.label)}</span>` +
            `<span style="color:var(--text-dim)">${cnt}\u00a0tile${cnt!==1?'s':''}</span>` +
            (badges.length ? `<span style="color:var(--text-dim);font-size:10px">${badges.join(', ')}</span>` : '') +
            `<button onclick="loadColorVariantToCanvas(${i})" style="font-size:10px;padding:1px 5px" title="Load onto canvas">\uD83D\uDC41</button>` +
            `<button onclick="recaptureColorVariant(${i})" style="font-size:10px;padding:1px 5px" title="Re-capture from current canvas">\uD83D\uDD04</button>` +
            `<button onclick="removeColorVariant(${i})" class="danger" style="padding:1px 6px;font-size:10px">\u2715</button>`;
        list.appendChild(div);
    }
}

/** Load a saved color variant back onto the canvas (for editing). */
function loadColorVariantToCanvas(index) {
    const cv = _objColorVariants[index];
    if (!cv) return;
    pushUndo();
    const prevGridW = gridW;
    const prevGridH = gridH;
    if (cv.objLayers) {
        objLayers = JSON.parse(JSON.stringify(cv.objLayers));
    }
    if (cv.meta) {
        meta = JSON.parse(JSON.stringify(cv.meta));
    }
    if (cv.originQ != null) _objOriginQ = cv.originQ;
    if (cv.originR != null) _objOriginR = cv.originR;
    // Eye-preview should never resize the canvas.
    gridW = prevGridW;
    gridH = prevGridH;
    document.getElementById('grid-w').value = gridW;
    document.getElementById('grid-h').value = gridH;
    _objRotationVariants = cv.rotationVariants ? JSON.parse(JSON.stringify(cv.rotationVariants)) : [];
    refreshRotationVariantsList();
    _objSeasonVariants = cv.seasonVariants ? JSON.parse(JSON.stringify(cv.seasonVariants)) : {};
    refreshSeasonVariantsList();
    const paths = new Set();
    for (const ln of ['base','detail','top']) for (const c of Object.values(objLayers[ln])) paths.add(c.sheetPath);
    for (const rv of _objRotationVariants) { for (const ln of ['base','detail','top']) for (const c of Object.values((rv.objLayers||{})[ln]||{})) paths.add(c.sheetPath); }
    for (const sv of Object.values(_objSeasonVariants)) { for (const ln of ['base','detail','top']) for (const c of Object.values((sv||{})[ln]||{})) paths.add(c.sheetPath); }
    Promise.all([...paths].filter(Boolean).map(loadImage)).then(() => { fitCanvas(); renderBuildCanvas(); });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  REQUIRED TECHS â€” picker & display helpers
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function renderObjTechTags() {
    const container = document.getElementById('obj-req-techs-tags');
    if (!container) return;
    if (!_objRequiredTechs.length) {
        container.innerHTML = '<span style="font-size:11px;color:var(--text-dim);font-style:italic">None â€” click to add required techs</span>';
        return;
    }
    container.innerHTML = '';
    for (const tid of _objRequiredTechs) {
        const info = _availableTechs.find(t => t.id === tid);
        const label = info ? `${info.icon||'ğŸ”¬'} ${info.name}` : tid;
        const tag = document.createElement('span');
        tag.style.cssText = 'display:inline-flex;align-items:center;gap:3px;font-size:10px;padding:2px 6px;border-radius:8px;background:#1a1828;color:#58a6ff;border:1px solid rgba(88,166,255,.25)';
        tag.innerHTML = `${label}<span style="cursor:pointer;font-size:12px;line-height:1;margin-left:2px;opacity:.6" onclick="event.stopPropagation();removeObjTech('${tid}')">&times;</span>`;
        container.appendChild(tag);
    }
}
function removeObjTech(tid) {
    _objRequiredTechs = _objRequiredTechs.filter(t => t !== tid);
    renderObjTechTags();
}
function openObjTechPicker() {
    const modal = document.getElementById('obj-tech-modal');
    const list = document.getElementById('obj-tech-list');
    list.innerHTML = '';
    if (!_availableTechs.length) {
        list.innerHTML = '<div style="padding:12px;color:var(--text-dim);font-style:italic">No technologies available. Add techs in the Tech Tree editor tab first.</div>';
    } else {
        const sorted = [..._availableTechs].sort((a,b) => (a.category||'').localeCompare(b.category||'') || a.name.localeCompare(b.name));
        let lastCat = '';
        for (const t of sorted) {
            if (t.category !== lastCat) {
                lastCat = t.category;
                const div = document.createElement('div');
                div.style.cssText = 'padding:6px 4px 2px;font-size:10px;font-weight:700;text-transform:uppercase;letter-spacing:.06em;color:var(--text-dim)';
                div.textContent = lastCat;
                list.appendChild(div);
            }
            const lbl = document.createElement('label');
            lbl.style.cssText = 'display:flex;align-items:center;gap:8px;padding:4px 6px;border-radius:4px;cursor:pointer;font-size:12px';
            const checked = _objRequiredTechs.includes(t.id) ? 'checked' : '';
            lbl.innerHTML = `<input type="checkbox" value="${t.id}" ${checked}><span>${t.icon||'ğŸ”¬'} ${t.name}</span>`;
            lbl.querySelector('input').addEventListener('change', function() {
                if (this.checked) { if (!_objRequiredTechs.includes(t.id)) _objRequiredTechs.push(t.id); }
                else { _objRequiredTechs = _objRequiredTechs.filter(x => x !== t.id); }
                renderObjTechTags();
            });
            list.appendChild(lbl);
        }
    }
    modal.style.display = 'flex';
}
function closeObjTechPicker() {
    document.getElementById('obj-tech-modal').style.display = 'none';
}

function newObject() {
    clearAll(true);
    objEditIdx = -1;
    document.getElementById('obj-name').value = '';
    document.getElementById('obj-type').value = 'tree';
    document.getElementById('obj-animation').value = 'none';
    document.getElementById('obj-resource').value = '';
    document.getElementById('obj-resource-amount').value = '1';
    document.getElementById('obj-weight').value = '1';
    document.getElementById('obj-resistance').value = '0';
    document.getElementById('obj-spawn-after').value = '';
    _objHealthStates = [];
    refreshHealthStatesList();
    _objOriginQ = null;
    _objOriginR = null;
    _objSeasonVariants = {};
    refreshSeasonVariantsList();
    _objGrowthStates = [];
    refreshGrowthStatesList();
    _objRotationVariants = [];
    refreshRotationVariantsList();
    _objColorVariants = [];
    _activeColorVariantIdx = -1;
    refreshColorVariantsList();
    setSelectedTerrains([]);
    _objRequiredTechs = [];
    renderObjTechTags();
}

function saveObject() {
    const name = document.getElementById('obj-name').value.trim();
    if (!name) { alert('Enter an object name.'); document.getElementById('obj-name').focus(); return; }
    // Collect all tile keys across all layers
    const allKeys = new Set();
    for (const ln of ['base','detail','top']) for (const k of Object.keys(objLayers[ln])) allKeys.add(k);
    if (!allKeys.size) { alert('Paint at least one tile.'); return; }
    let minQ=Infinity, minR=Infinity, maxQ=-Infinity, maxR=-Infinity;
    for (const key of allKeys) { const [q, r] = key.split(',').map(Number); if (q<minQ) minQ=q; if (q>maxQ) maxQ=q; if (r<minR) minR=r; if (r>maxR) maxR=r; }
    const animation = document.getElementById('obj-animation').value;
    const resourceType = document.getElementById('obj-resource').value;
    const resourceAmount = parseInt(document.getElementById('obj-resource-amount').value) || 1;
    const tightW = maxQ - minQ + 1;
    const tightH = maxR - minR + 1;
    const obj = {
        id: slugify(name), name,
        objectType: document.getElementById('obj-type').value,
        animation: animation !== 'none' ? animation : undefined,
        resource: resourceType ? { type: resourceType, amount: resourceAmount } : undefined,
        terrainBindings: getSelectedTerrains(),
        spawnWeight: parseFloat(document.getElementById('obj-weight').value) || 1,
        resistance: parseInt(document.getElementById('obj-resistance').value) || undefined,
        tileW: TILE, tileH: TILE, width: tightW, height: tightH,
        bounds: { minCol: minQ, minRow: minR, maxCol: maxQ, maxRow: maxR },
        spawnAfter: document.getElementById('obj-spawn-after').value.trim() || undefined,
        requiredTechs: _objRequiredTechs.length > 0 ? [..._objRequiredTechs] : undefined,
        healthStates: _objHealthStates.length > 0
            ? _objHealthStates.map(hs => ({ ...hs, objLayers: JSON.parse(JSON.stringify(hs.objLayers || {base:{},detail:{},top:{}})) }))
            : undefined,
        seasonVariants: Object.keys(_objSeasonVariants).length > 0
            ? Object.fromEntries(Object.entries(_objSeasonVariants).map(([s, t]) => [s, JSON.parse(JSON.stringify(t))]))
            : undefined,
        growthStates: _objGrowthStates.length > 0
            ? _objGrowthStates.map(gs => ({ ...gs, objLayers: JSON.parse(JSON.stringify(gs.objLayers || {base:{},detail:{},top:{}})) }))
            : undefined,
        rotationVariants: _objRotationVariants.length > 0
            ? _objRotationVariants.map(rv => ({
                label: rv.label,
                objLayers: JSON.parse(JSON.stringify(rv.objLayers || {base:{},detail:{},top:{}})),
                meta: rv.meta ? JSON.parse(JSON.stringify(rv.meta)) : {},
                originQ: rv.originQ != null ? rv.originQ : undefined,
                originR: rv.originR != null ? rv.originR : undefined,
                gridW: rv.gridW != null ? rv.gridW : undefined,
                gridH: rv.gridH != null ? rv.gridH : undefined,
            }))
            : undefined,
        colorVariants: _objColorVariants.length > 0
            ? _objColorVariants.map(cv => ({
                label: cv.label,
                objLayers: JSON.parse(JSON.stringify(cv.objLayers || {base:{},detail:{},top:{}})),
                meta: cv.meta ? JSON.parse(JSON.stringify(cv.meta)) : {},
                originQ: cv.originQ != null ? cv.originQ : undefined,
                originR: cv.originR != null ? cv.originR : undefined,
                gridW: cv.gridW != null ? cv.gridW : undefined,
                gridH: cv.gridH != null ? cv.gridH : undefined,
                rotationVariants: cv.rotationVariants ? JSON.parse(JSON.stringify(cv.rotationVariants)) : undefined,
                seasonVariants: cv.seasonVariants ? JSON.parse(JSON.stringify(cv.seasonVariants)) : undefined,
            }))
            : undefined,
        originQ: _objOriginQ != null ? _objOriginQ : undefined,
        originR: _objOriginR != null ? _objOriginR : undefined,
        objLayers: JSON.parse(JSON.stringify(objLayers)),
        // Keep flattened tiles for backward compat (merge base â†’ detail â†’ top)
        tiles: Object.assign({}, objLayers.base, objLayers.detail, objLayers.top),
        meta: { ...meta },
    };
    if (objEditIdx >= 0) objDefs[objEditIdx] = obj;
    else { objDefs.push(obj); objEditIdx = objDefs.length-1; }
    refreshObjectList();
}

function loadObject(index) {
    const obj = objDefs[index];
    objEditIdx = index;
    document.getElementById('obj-name').value = obj.name;
    document.getElementById('obj-type').value = obj.objectType || 'tree';
    document.getElementById('obj-animation').value = obj.animation || 'none';
    document.getElementById('obj-resource').value = obj.resource ? obj.resource.type : '';
    document.getElementById('obj-resource-amount').value = obj.resource ? obj.resource.amount : 1;
    setSelectedTerrains(obj.terrainBindings || []);
    document.getElementById('obj-weight').value = obj.spawnWeight || 1;
    document.getElementById('obj-resistance').value = obj.resistance || 0;
    document.getElementById('obj-spawn-after').value = obj.spawnAfter || '';
    _objRequiredTechs = obj.requiredTechs ? [...obj.requiredTechs] : [];
    renderObjTechTags();
    _objOriginQ = obj.originQ != null ? obj.originQ : null;
    _objOriginR = obj.originR != null ? obj.originR : null;

    // Helper to remap state layers for legacy compat
    const _loadStateLayers = (st) => {
        if (st.objLayers) return { ...st, objLayers: JSON.parse(JSON.stringify(st.objLayers)) };
        if (st.tiles) return { ...st, objLayers: { base: JSON.parse(JSON.stringify(st.tiles)), detail: {}, top: {} } };
        return { ...st, objLayers: { base: {}, detail: {}, top: {} } };
    };

    _objHealthStates = obj.healthStates ? obj.healthStates.map(_loadStateLayers) : [];
    refreshHealthStatesList();
    _objSeasonVariants = {};
    if (obj.seasonVariants) {
        for (const [s, t] of Object.entries(obj.seasonVariants)) {
            if (t && t.base !== undefined) _objSeasonVariants[s] = JSON.parse(JSON.stringify(t));
            else _objSeasonVariants[s] = { base: JSON.parse(JSON.stringify(t || {})), detail: {}, top: {} };
        }
    }
    refreshSeasonVariantsList();
    _objGrowthStates = obj.growthStates ? obj.growthStates.map(_loadStateLayers) : [];
    refreshGrowthStatesList();
    _objRotationVariants = obj.rotationVariants ? obj.rotationVariants.map(rv => {
        const loaded = _loadStateLayers(rv);
        if (rv.meta) loaded.meta = JSON.parse(JSON.stringify(rv.meta));
        if (rv.originQ != null) loaded.originQ = rv.originQ;
        if (rv.originR != null) loaded.originR = rv.originR;
        if (rv.gridW != null) loaded.gridW = rv.gridW;
        if (rv.gridH != null) loaded.gridH = rv.gridH;
        return loaded;
    }) : [];
    refreshRotationVariantsList();
    _objColorVariants = obj.colorVariants ? obj.colorVariants.map(cv => {
        const loaded = _loadStateLayers(cv);
        if (cv.meta) loaded.meta = JSON.parse(JSON.stringify(cv.meta));
        if (cv.originQ != null) loaded.originQ = cv.originQ;
        if (cv.originR != null) loaded.originR = cv.originR;
        if (cv.gridW != null) loaded.gridW = cv.gridW;
        if (cv.gridH != null) loaded.gridH = cv.gridH;
        loaded.rotationVariants = cv.rotationVariants ? cv.rotationVariants.map(rv => {
            const lr = _loadStateLayers(rv);
            if (rv.meta) lr.meta = JSON.parse(JSON.stringify(rv.meta));
            if (rv.originQ != null) lr.originQ = rv.originQ;
            if (rv.originR != null) lr.originR = rv.originR;
            if (rv.gridW != null) lr.gridW = rv.gridW;
            if (rv.gridH != null) lr.gridH = rv.gridH;
            return lr;
        }) : [];
        loaded.seasonVariants = {};
        if (cv.seasonVariants) {
            for (const [s, t] of Object.entries(cv.seasonVariants)) {
                if (t && t.base !== undefined) loaded.seasonVariants[s] = JSON.parse(JSON.stringify(t));
                else loaded.seasonVariants[s] = { base: JSON.parse(JSON.stringify(t || {})), detail: {}, top: {} };
            }
        }
        return loaded;
    }) : [];
    _activeColorVariantIdx = -1;
    refreshColorVariantsList();

    // Load layers â€” new multi-layer format or legacy single tiles
    if (obj.objLayers) {
        objLayers = JSON.parse(JSON.stringify(obj.objLayers));
        if (!objLayers.detail) objLayers.detail = {};
        if (!objLayers.top) objLayers.top = {};
    } else {
        objLayers = { base: { ...(obj.tiles || {}) }, detail: {}, top: {} };
    }
    meta = { ...obj.meta };

    // â”€â”€ Tight-fit: match autofitGrid() â€” zero padding, shift to 0,0 â”€â”€
    const allKeys = new Set();
    for (const ln of ['base','detail','top']) for (const k of Object.keys(objLayers[ln])) allKeys.add(k);
    if (allKeys.size) {
        let minQ=Infinity, minR=Infinity, maxQ=-Infinity, maxR=-Infinity;
        const _scan = (key) => {
            const [q, r] = key.split(',').map(Number);
            if (q < minQ) minQ = q; if (q > maxQ) maxQ = q;
            if (r < minR) minR = r; if (r > maxR) maxR = r;
        };
        for (const key of allKeys) _scan(key);
        for (const key of Object.keys(meta)) _scan(key);

        // Shift so minQ,minR becomes 0,0 (same as autofitGrid)
        if (minQ !== 0 || minR !== 0) {
            const remap = (tiles) => {
                const out = {};
                for (const [key, val] of Object.entries(tiles)) {
                    const [q, r] = key.split(',').map(Number);
                    out[`${q - minQ},${r - minR}`] = val;
                }
                return out;
            };
            const remapLayers = (lyrs) => {
                if (!lyrs) return { base: {}, detail: {}, top: {} };
                return { base: remap(lyrs.base || {}), detail: remap(lyrs.detail || {}), top: remap(lyrs.top || {}) };
            };
            objLayers = remapLayers(objLayers);
            meta = remap(meta);
            _objHealthStates = _objHealthStates.map(hs => ({ ...hs, objLayers: remapLayers(hs.objLayers) }));
            _objSeasonVariants = Object.fromEntries(
                Object.entries(_objSeasonVariants).map(([s, t]) => [s, remapLayers(t)])
            );
            _objGrowthStates = _objGrowthStates.map(gs => ({ ...gs, objLayers: remapLayers(gs.objLayers) }));
            _objRotationVariants = _objRotationVariants.map(rv => {
                const updated = { ...rv, objLayers: remapLayers(rv.objLayers) };
                if (rv.meta) updated.meta = remap(rv.meta);
                if (rv.originQ != null) { updated.originQ = rv.originQ - minQ; updated.originR = rv.originR - minR; }
                return updated;
            });
            _objColorVariants = _objColorVariants.map(cv => {
                const updated = { ...cv, objLayers: remapLayers(cv.objLayers) };
                if (cv.meta) updated.meta = remap(cv.meta);
                if (cv.originQ != null) { updated.originQ = cv.originQ - minQ; updated.originR = cv.originR - minR; }
                if (cv.rotationVariants) {
                    updated.rotationVariants = cv.rotationVariants.map(rv => {
                        const u2 = { ...rv, objLayers: remapLayers(rv.objLayers) };
                        if (rv.meta) u2.meta = remap(rv.meta);
                        if (rv.originQ != null) { u2.originQ = rv.originQ - minQ; u2.originR = rv.originR - minR; }
                        return u2;
                    });
                }
                if (cv.seasonVariants) {
                    updated.seasonVariants = Object.fromEntries(
                        Object.entries(cv.seasonVariants).map(([s, t]) => [s, remapLayers(t)])
                    );
                }
                return updated;
            });
            if (_objOriginQ != null) { _objOriginQ -= minQ; _objOriginR -= minR; }
        }

        gridW = maxQ - minQ + 1;
        gridH = maxR - minR + 1;
    } else {
        gridW = obj.width || 8;
        gridH = obj.height || 8;
    }
    document.getElementById('grid-w').value = gridW;
    document.getElementById('grid-h').value = gridH;
    // Immediately refit + render with the new grid size
    fitCanvas();

    const paths = new Set();
    const _collectPaths = (lyrs) => { for (const ln of ['base','detail','top']) for (const c of Object.values(lyrs[ln] || {})) paths.add(c.sheetPath); };
    _collectPaths(objLayers);
    for (const hs of _objHealthStates) _collectPaths(hs.objLayers || {});
    for (const sv of Object.values(_objSeasonVariants)) _collectPaths(sv || {});
    for (const gs of _objGrowthStates) _collectPaths(gs.objLayers || {});
    for (const rv of _objRotationVariants) _collectPaths(rv.objLayers || {});
    for (const cv of _objColorVariants) {
        _collectPaths(cv.objLayers || {});
        if (cv.rotationVariants) for (const rv of cv.rotationVariants) _collectPaths(rv.objLayers || {});
        if (cv.seasonVariants) for (const sv of Object.values(cv.seasonVariants)) _collectPaths(sv || {});
    }
    Promise.all([...paths].map(loadImage)).then(() => { renderBuildCanvas(); });
}

function deleteObject(index) {
    if (!confirm(`Delete "${objDefs[index].name}"?`)) return;
    objDefs.splice(index, 1);
    if (objEditIdx === index) { objEditIdx = -1; clearAll(true); }
    else if (objEditIdx > index) objEditIdx--;
    refreshObjectList();
}

function getObjectLayersForPreview(obj) {
    const src = obj?.objLayers || { base: obj?.tiles || {}, detail: {}, top: {} };
    return {
        base: src.base || {},
        detail: src.detail || {},
        top: src.top || {},
    };
}

function getLayersOccupiedBounds(layerStores) {
    let minCol = Infinity, minRow = Infinity, maxCol = -Infinity, maxRow = -Infinity;
    for (const store of layerStores) {
        for (const key of Object.keys(store || {})) {
            const [q, r] = key.split(',').map(Number);
            if (!Number.isFinite(q) || !Number.isFinite(r)) continue;
            if (q < minCol) minCol = q;
            if (r < minRow) minRow = r;
            if (q > maxCol) maxCol = q;
            if (r > maxRow) maxRow = r;
        }
    }
    if (!Number.isFinite(minCol) || !Number.isFinite(minRow) || !Number.isFinite(maxCol) || !Number.isFinite(maxRow)) {
        return null;
    }
    return { minCol, minRow, maxCol, maxRow };
}

function getObjectPreviewBounds(obj, layers) {
    const stores = [layers.base || {}, layers.detail || {}, layers.top || {}];
    const occupied = getLayersOccupiedBounds(stores);
    if (occupied) return occupied;
    if (obj && obj.bounds && Number.isFinite(obj.bounds.minCol) && Number.isFinite(obj.bounds.minRow) && Number.isFinite(obj.bounds.maxCol) && Number.isFinite(obj.bounds.maxRow)) {
        return { minCol: obj.bounds.minCol, minRow: obj.bounds.minRow, maxCol: obj.bounds.maxCol, maxRow: obj.bounds.maxRow };
    }
    return { minCol: 0, minRow: 0, maxCol: 0, maxRow: 0 };
}

function drawCatalogThumbnailFromLayers(canvas, layerStores, boundsOverride = null) {
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const size = canvas.width || 64;
    const bounds = boundsOverride || getLayersOccupiedBounds(layerStores) || { minCol: 0, minRow: 0, maxCol: 0, maxRow: 0 };
    const widthTiles = Math.max(1, (bounds.maxCol - bounds.minCol + 1) || 1);
    const heightTiles = Math.max(1, (bounds.maxRow - bounds.minRow + 1) || 1);
    const pad = 4;
    const maxDraw = Math.max(1, size - pad * 2);
    const tileDisp = Math.max(1, Math.floor(Math.min(maxDraw / widthTiles, maxDraw / heightTiles)));
    const drawW = widthTiles * tileDisp;
    const drawH = heightTiles * tileDisp;
    const ox = Math.floor((size - drawW) / 2);
    const oy = Math.floor((size - drawH) / 2);

    const paintBase = () => {
        ctx.clearRect(0, 0, size, size);
        ctx.fillStyle = '#0f141b';
        ctx.fillRect(0, 0, size, size);
        ctx.strokeStyle = 'rgba(255,255,255,0.05)';
        ctx.strokeRect(0.5, 0.5, size - 1, size - 1);
        ctx.imageSmoothingEnabled = false;
    };
    paintBase();

    const paths = new Set();
    for (const store of layerStores) for (const c of Object.values(store || {})) if (c?.sheetPath) paths.add(c.sheetPath);

    Promise.all([...paths].map(loadImage)).then(() => {
        paintBase();
        for (const store of layerStores) {
            for (const [key, cell] of Object.entries(store || {})) {
                const [q, r] = key.split(',').map(Number);
                if (!Number.isFinite(q) || !Number.isFinite(r) || !cell?.sheetPath) continue;
                const img = imgCache.get(cell.sheetPath);
                if (!img || !img.complete) continue;

                const x = ox + (q - bounds.minCol) * tileDisp;
                const y = oy + (r - bounds.minRow) * tileDisp;
                const sw = cell.sw || TILE;
                const sh = cell.sh || TILE;
                if (cell.rotation) {
                    ctx.save();
                    ctx.translate(x + tileDisp / 2, y + tileDisp / 2);
                    ctx.rotate(cell.rotation * Math.PI / 180);
                    ctx.drawImage(img, cell.sx, cell.sy, sw, sh, -tileDisp / 2, -tileDisp / 2, tileDisp, tileDisp);
                    ctx.restore();
                } else {
                    ctx.drawImage(img, cell.sx, cell.sy, sw, sh, x, y, tileDisp, tileDisp);
                }
            }
        }
    }).catch(() => {
        paintBase();
    });
}

function drawObjectCatalogThumbnail(canvas, obj) {
    if (!canvas) return;
    const layers = getObjectLayersForPreview(obj);
    const stores = [layers.base || {}, layers.detail || {}, layers.top || {}];
    const bounds = getObjectPreviewBounds(obj, layers);
    drawCatalogThumbnailFromLayers(canvas, stores, bounds);
}

function refreshObjectList() {
    const countEl = document.getElementById('cat-obj-count');
    const list = document.getElementById('cat-obj-cards');
    if (countEl) countEl.textContent = objDefs.length;
    if (!list) return;
    if (!objDefs.length) { list.innerHTML = '<div class="catalog-empty">No objects saved yet</div>'; return; }
    list.innerHTML = '';
    const range = getCatalogPageRange('object');
    for (let i = range.start; i < range.end; i++) {
        const o = objDefs[i];
        const pBounds = getObjectPreviewBounds(o, getObjectLayersForPreview(o));
        const bw = pBounds.maxCol - pBounds.minCol + 1, bh = pBounds.maxRow - pBounds.minRow + 1;
        let extras = [];
        if (o.terrainBindings && o.terrainBindings.length) extras.push(o.terrainBindings.join(', '));
        if (o.animation) extras.push('ğŸ¬ interact: ' + o.animation);
        if (o.resource) extras.push('ğŸ“¦ ' + o.resource.type + ' Ã—' + o.resource.amount);
        if (o.spawnAfter) extras.push('ğŸŒ± â†’ ' + o.spawnAfter);
        if (o.healthStates && o.healthStates.length) extras.push('â¤ï¸ ' + o.healthStates.length + ' dmg stages');
        const svSeasons = o.seasonVariants ? Object.keys(o.seasonVariants) : [];
        if (svSeasons.length) extras.push('ğŸ—“ ' + svSeasons.join('/'));
        if (o.growthStates && o.growthStates.length) extras.push('ğŸŒ± ' + o.growthStates.length + ' growth stage' + (o.growthStates.length > 1 ? 's' : ''));
        if (o.rotationVariants && o.rotationVariants.length) extras.push('ğŸ”„ ' + o.rotationVariants.length + ' rotation' + (o.rotationVariants.length > 1 ? 's' : ''));
        const div = document.createElement('div');
        const thumbId = `cat-obj-thumb-${i}`;
        div.className = 'item-card object-card'; div.style.borderColor = i===objEditIdx ? 'var(--gold)' : '';
        div.innerHTML = `<div class="obj-thumb-wrap"><canvas id="${thumbId}" class="obj-thumb" width="64" height="64"></canvas></div>
            <div class="item-main"><div class="item-title">${escHtml(o.name)}</div>
            <div class="item-meta">${o.objectType} Â· ${bw}Ã—${bh} tiles${extras.length ? ' Â· '+extras.join(' Â· ') : ''}</div>
            <div class="item-acts"><button onclick="loadObject(${i});closeCatalog()">âœï¸ Edit</button><button class="danger" onclick="deleteObject(${i})">ğŸ—‘</button></div></div>`;
        list.appendChild(div);
        drawObjectCatalogThumbnail(document.getElementById(thumbId), o);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UNIFIED NEW / SAVE / LIBRARY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function newItem() {
    if (!confirm('Start new? Unsaved changes will be lost.')) return;
    if (editorMode === 'building') newBuilding(); else newObject();
}

function saveItem() {
    if (editorMode === 'building') saveBuilding(); else saveObject();
    notifyParent();
}

function notifyParent() {
  try {
    const d = getExportData();
    window.parent.postMessage({ type: 'spriteDataChanged', ...d }, '*');
  } catch(e) { /* standalone mode */ }
}

/** Ask parent editor to switch to interior tab and open/create interior for a building */
function openInteriorForBuilding(index) {
  const b = buildings[index];
  if (!b) return;
  // Save first so parent has latest data
  notifyParent();
  try {
    window.parent.postMessage({
      type: 'openBuildingInterior',
      buildingId:   b.id,
      buildingName: b.name,
      buildingType: b.buildingType,
      buildingWidth:  b.width,
      buildingHeight: b.height,
    }, '*');
  } catch(e) {
    alert('Interior editing requires the parent Editor hub (editor.html).');
  }
}

function refreshLibrary() {
    refreshBuildingList();
    refreshObjectList();
    refreshCatalogPaginationUI();
}

const CATALOG_PAGE_SIZE = 24;
let _catalogTab = 'building';
let _catalogPages = { building: 1, object: 1 };

function getCatalogTotal(mode) {
    return mode === 'building' ? buildings.length : objDefs.length;
}

function getCatalogPageCount(mode) {
    return Math.max(1, Math.ceil(getCatalogTotal(mode) / CATALOG_PAGE_SIZE));
}

function clampCatalogPage(mode) {
    const pageCount = getCatalogPageCount(mode);
    const raw = _catalogPages[mode] || 1;
    _catalogPages[mode] = Math.max(1, Math.min(pageCount, raw));
    return _catalogPages[mode];
}

function getCatalogPageRange(mode) {
    const total = getCatalogTotal(mode);
    const page = clampCatalogPage(mode);
    const start = (page - 1) * CATALOG_PAGE_SIZE;
    const end = Math.min(start + CATALOG_PAGE_SIZE, total);
    return { total, page, start, end, pageCount: getCatalogPageCount(mode) };
}

function refreshCatalogPaginationUI() {
    const mode = _catalogTab;
    const infoEl = document.getElementById('cat-page-info');
    const prevBtn = document.getElementById('cat-page-prev');
    const nextBtn = document.getElementById('cat-page-next');
    if (!infoEl || !prevBtn || !nextBtn) return;

    const { total, page, start, end, pageCount } = getCatalogPageRange(mode);
    if (!total) {
        infoEl.textContent = '0 items';
        prevBtn.disabled = true;
        nextBtn.disabled = true;
        return;
    }

    infoEl.textContent = `Showing ${start + 1}-${end} of ${total} Â· Page ${page}/${pageCount}`;
    prevBtn.disabled = page <= 1;
    nextBtn.disabled = page >= pageCount;
}

function changeCatalogPage(delta) {
    const mode = _catalogTab;
    _catalogPages[mode] = (_catalogPages[mode] || 1) + delta;
    clampCatalogPage(mode);
    if (mode === 'building') refreshBuildingList();
    else refreshObjectList();
    refreshCatalogPaginationUI();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CATALOG MODAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function openCatalog() {
    refreshLibrary();
    // Auto-select the tab matching current editor mode
    setCatalogTab(editorMode);
    document.getElementById('catalog-overlay').style.display = '';
}
function closeCatalog() {
    document.getElementById('catalog-overlay').style.display = 'none';
}
function setCatalogTab(mode) {
    _catalogTab = mode === 'building' ? 'building' : 'object';
    const isBld = mode === 'building';
    document.getElementById('cat-tab-bld').classList.toggle('active', isBld);
    document.getElementById('cat-tab-obj').classList.toggle('active', !isBld);
    document.getElementById('cat-bld-cards').style.display = isBld ? 'grid' : 'none';
    document.getElementById('cat-obj-cards').style.display = isBld ? 'none' : 'grid';
    refreshCatalogPaginationUI();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CLEAR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function clearLayer(ask = true) {
    const layerName = editorMode === 'building' ? activeLayer : activeObjLayer;
    if (ask && !confirm(`Clear the ${layerName} layer?`)) return;
    pushUndo();
    if (editorMode === 'building') layers[activeLayer] = {};
    else objLayers[activeObjLayer] = {};
    renderBuildCanvas();
}

function clearAll(skip = false) {
    if (!skip && !confirm('Clear all tiles and meta?')) return;
    pushUndo();
    if (editorMode === 'building') layers = { floor:{}, walls:{}, roof:{}, overlay:{} };
    else objLayers = { base:{}, detail:{}, top:{} };
    meta = {};
    renderBuildCanvas();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  EXPORT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function exportAllJSON() {
    if (editorMode === 'building') exportBuildings();
    else exportObjects();
}

function exportBuildings() {
    if (!buildings.length) { alert('Save at least one building first.'); return; }
    let fname = prompt('Export filename:', 'buildings.json');
    if (!fname) return;
    fname = fname.trim().replace(/[/\\]/g,'_');
    if (!fname.endsWith('.json')) fname += '.json';
    const exported = buildings.map(b => _exportBuilding(b));
    downloadJSON(exported, fname);
    setTimeout(() => alert(
        `âœ…  Exported "${fname}"\n\nPlace it in data/ as buildings.json and run build:data,\nor import it via the editor.`
    ), 200);
}

function exportObjects() {
    if (!objDefs.length) { alert('Save at least one object first.'); return; }
    let fname = prompt('Export filename:', 'objects.json');
    if (!fname) return;
    fname = fname.trim().replace(/[/\\]/g,'_');
    if (!fname.endsWith('.json')) fname += '.json';
    const exported = objDefs.map(obj => {
        // Use objLayers (new) or tiles (legacy)
        const srcLayers = obj.objLayers || { base: obj.tiles || {}, detail: {}, top: {} };
        const allKeys = new Set();
        for (const ln of ['base','detail','top']) for (const k of Object.keys(srcLayers[ln] || {})) allKeys.add(k);
        let minQ=Infinity, minR=Infinity, maxQ=-Infinity, maxR=-Infinity;
        for (const key of allKeys) { const [q, r] = key.split(',').map(Number); if (q<minQ) minQ=q; if (q>maxQ) maxQ=q; if (r<minR) minR=r; if (r>maxR) maxR=r; }
        const originQ = obj.originQ != null ? obj.originQ : minQ;
        const originR = obj.originR != null ? obj.originR : minR;

        const _exportTileDict = (dict) => Object.entries(dict || {}).map(([key,c]) => {
            const [q,r]=key.split(',').map(Number);
            return { localCol:q-originQ, localRow:r-originR, sheetPath:c.sheetPath, sx:c.sx, sy:c.sy, sw:c.sw, sh:c.sh };
        });
        const _exportObjLayers = (lyrs) => {
            const out = {};
            for (const ln of ['base','detail','top']) { const arr = _exportTileDict(lyrs[ln]||{}); if (arr.length) out[ln] = arr; }
            return out;
        };
        const merged = Object.assign({}, srcLayers.base, srcLayers.detail, srcLayers.top);
        const outTiles = _exportTileDict(merged);
        const outObjLayers = _exportObjLayers(srcLayers);

        const outMeta = Object.entries(obj.meta || {}).map(([key, m]) => {
            const [q, r] = key.split(',').map(Number);
            return { localCol: q-originQ, localRow: r-originR, ...m };
        }).filter(m => m.impassable || m.interactionPoint);

        const _exportStateLayers = (st) => {
            if (st.objLayers) return _exportObjLayers(st.objLayers);
            if (st.tiles) return { base: _exportTileDict(st.tiles) };
            return {};
        };

        const outHealthStates = (obj.healthStates || []).map(hs => ({
            label: hs.label, minHealthPct: hs.minHealthPct,
            tiles: _exportTileDict(Object.assign({}, ...(hs.objLayers ? ['base','detail','top'].map(l=>hs.objLayers[l]||{}) : [hs.tiles||{}]))),
            objLayers: _exportStateLayers(hs),
        }));
        const outSeasonVariants = {};
        for (const [season, sv] of Object.entries(obj.seasonVariants || {})) {
            const svLayers = (sv && sv.base !== undefined) ? sv : { base: sv || {}, detail: {}, top: {} };
            outSeasonVariants[season] = _exportTileDict(Object.assign({}, svLayers.base, svLayers.detail, svLayers.top));
        }
        const outGrowthStates = (obj.growthStates || []).map(gs => ({
            label: gs.label, daysToReach: gs.daysToReach,
            tiles: _exportTileDict(Object.assign({}, ...(gs.objLayers ? ['base','detail','top'].map(l=>gs.objLayers[l]||{}) : [gs.tiles||{}]))),
            objLayers: _exportStateLayers(gs),
        }));
        const outRotationVariants = (obj.rotationVariants || []).map(rv => {
            // Each rotation variant can have its own origin, meta, and canvas size
            const rvLayers = rv.objLayers || { base: rv.tiles || {}, detail: {}, top: {} };
            const rvAllKeys = new Set();
            for (const ln of ['base','detail','top']) for (const k of Object.keys(rvLayers[ln] || {})) rvAllKeys.add(k);
            let rvMinQ=Infinity, rvMinR=Infinity, rvMaxQ=-Infinity, rvMaxR=-Infinity;
            for (const key of rvAllKeys) { const [q,r]=key.split(',').map(Number); if(q<rvMinQ)rvMinQ=q; if(q>rvMaxQ)rvMaxQ=q; if(r<rvMinR)rvMinR=r; if(r>rvMaxR)rvMaxR=r; }
            const rvOriginQ = rv.originQ != null ? rv.originQ : originQ;
            const rvOriginR = rv.originR != null ? rv.originR : originR;
            const _rvExportTileDict = (dict) => Object.entries(dict || {}).map(([key,c]) => {
                const [q,r]=key.split(',').map(Number);
                return { localCol:q-rvOriginQ, localRow:r-rvOriginR, sheetPath:c.sheetPath, sx:c.sx, sy:c.sy, sw:c.sw, sh:c.sh };
            });
            const _rvExportObjLayers = (lyrs) => {
                const out = {};
                for (const ln of ['base','detail','top']) { const arr = _rvExportTileDict(lyrs[ln]||{}); if (arr.length) out[ln] = arr; }
                return out;
            };
            const rvMerged = Object.assign({}, rvLayers.base, rvLayers.detail, rvLayers.top);
            const rvOutMeta = Object.entries(rv.meta || {}).map(([key, m]) => {
                const [q, r] = key.split(',').map(Number);
                return { localCol: q-rvOriginQ, localRow: r-rvOriginR, ...m };
            }).filter(m => m.impassable || m.interactionPoint);
            const rvW = rvAllKeys.size ? rvMaxQ - rvMinQ + 1 : (rv.gridW || 1);
            const rvH = rvAllKeys.size ? rvMaxR - rvMinR + 1 : (rv.gridH || 1);
            return {
                label: rv.label,
                tiles: _rvExportTileDict(rvMerged),
                objLayers: _rvExportObjLayers(rvLayers),
                meta: rvOutMeta.length > 0 ? rvOutMeta : undefined,
                bounds: rvAllKeys.size ? { minCol: rvMinQ-rvOriginQ, minRow: rvMinR-rvOriginR, maxCol: rvMaxQ-rvOriginQ, maxRow: rvMaxR-rvOriginR } : undefined,
                width: rvW, height: rvH,
            };
        });
        // â”€â”€ Color Variants â”€â”€
        const _exportColorVariant = (cv) => {
            const cvLayers = cv.objLayers || { base: {}, detail: {}, top: {} };
            const cvAllKeys = new Set();
            for (const ln of ['base','detail','top']) for (const k of Object.keys(cvLayers[ln] || {})) cvAllKeys.add(k);
            let cvMinQ=Infinity,cvMinR=Infinity,cvMaxQ=-Infinity,cvMaxR=-Infinity;
            for (const key of cvAllKeys){ const [q,r]=key.split(',').map(Number); if(q<cvMinQ)cvMinQ=q; if(q>cvMaxQ)cvMaxQ=q; if(r<cvMinR)cvMinR=r; if(r>cvMaxR)cvMaxR=r; }
            const cvOriginQ = cv.originQ != null ? cv.originQ : originQ;
            const cvOriginR = cv.originR != null ? cv.originR : originR;
            const _cvExportTileDict = (dict) => Object.entries(dict||{}).map(([key,c])=>{
                const [q,r]=key.split(',').map(Number);
                return { localCol:q-cvOriginQ, localRow:r-cvOriginR, sheetPath:c.sheetPath, sx:c.sx, sy:c.sy, sw:c.sw, sh:c.sh };
            });
            const _cvExportObjLayers = (lyrs) => {
                const out = {};
                for (const ln of ['base','detail','top']){ const arr=_cvExportTileDict(lyrs[ln]||{}); if(arr.length) out[ln]=arr; }
                return out;
            };
            const cvMerged = Object.assign({}, cvLayers.base, cvLayers.detail, cvLayers.top);
            const cvOutMeta = Object.entries(cv.meta||{}).map(([key,m])=>{
                const [q,r]=key.split(',').map(Number);
                return { localCol:q-cvOriginQ, localRow:r-cvOriginR, ...m };
            }).filter(m=>m.impassable||m.interactionPoint);
            const cvW = cvAllKeys.size ? cvMaxQ-cvMinQ+1 : (cv.gridW||1);
            const cvH = cvAllKeys.size ? cvMaxR-cvMinR+1 : (cv.gridH||1);
            // Export this variant's rotation variants
            const cvRotVars = (cv.rotationVariants||[]).map(rv => {
                const rvL = rv.objLayers||{base:{},detail:{},top:{}};
                const rvKeys = new Set();
                for (const ln of ['base','detail','top']) for (const k of Object.keys(rvL[ln]||{})) rvKeys.add(k);
                let rMinQ=Infinity,rMinR=Infinity,rMaxQ=-Infinity,rMaxR=-Infinity;
                for (const k of rvKeys){ const [q,r]=k.split(',').map(Number); if(q<rMinQ)rMinQ=q; if(q>rMaxQ)rMaxQ=q; if(r<rMinR)rMinR=r; if(r>rMaxR)rMaxR=r; }
                const rOQ = rv.originQ!=null?rv.originQ:cvOriginQ;
                const rOR = rv.originR!=null?rv.originR:cvOriginR;
                const _rExp = (dict)=>Object.entries(dict||{}).map(([key,c])=>{const [q,r]=key.split(',').map(Number);return{localCol:q-rOQ,localRow:r-rOR,sheetPath:c.sheetPath,sx:c.sx,sy:c.sy,sw:c.sw,sh:c.sh};});
                const _rExpL = (lyrs)=>{const o={};for(const ln of ['base','detail','top']){const a=_rExp(lyrs[ln]||{});if(a.length)o[ln]=a;}return o;};
                const rMerged = Object.assign({},rvL.base,rvL.detail,rvL.top);
                const rMeta = Object.entries(rv.meta||{}).map(([key,m])=>{const [q,r]=key.split(',').map(Number);return{localCol:q-rOQ,localRow:r-rOR,...m};}).filter(m=>m.impassable||m.interactionPoint);
                const rW=rvKeys.size?rMaxQ-rMinQ+1:(rv.gridW||1);
                const rH=rvKeys.size?rMaxR-rMinR+1:(rv.gridH||1);
                return { label:rv.label, tiles:_rExp(rMerged), objLayers:_rExpL(rvL), meta:rMeta.length?rMeta:undefined, bounds:rvKeys.size?{minCol:rMinQ-rOQ,minRow:rMinR-rOR,maxCol:rMaxQ-rOQ,maxRow:rMaxR-rOR}:undefined, width:rW, height:rH };
            });
            // Export this variant's season variants
            const cvSeasonVars = {};
            for (const [s,sv] of Object.entries(cv.seasonVariants||{})){
                const svL = (sv&&sv.base!==undefined)?sv:{base:sv||{},detail:{},top:{}};
                cvSeasonVars[s] = _cvExportTileDict(Object.assign({},svL.base,svL.detail,svL.top));
            }
            return {
                label: cv.label,
                tiles: _cvExportTileDict(cvMerged),
                objLayers: _cvExportObjLayers(cvLayers),
                meta: cvOutMeta.length?cvOutMeta:undefined,
                bounds: cvAllKeys.size?{minCol:cvMinQ-cvOriginQ,minRow:cvMinR-cvOriginR,maxCol:cvMaxQ-cvOriginQ,maxRow:cvMaxR-cvOriginR}:undefined,
                width:cvW, height:cvH,
                rotationVariants: cvRotVars.length?cvRotVars:undefined,
                seasonVariants: Object.keys(cvSeasonVars).length?cvSeasonVars:undefined,
            };
        };
        const outColorVariants = (obj.colorVariants||[]).map(_exportColorVariant);

        return {
            id: obj.id, name: obj.name, objectType: obj.objectType,
            animation: obj.animation || undefined,
            resource: obj.resource || undefined,
            spawnAfter: obj.spawnAfter || undefined,
            healthStates: outHealthStates.length > 0 ? outHealthStates : undefined,
            seasonVariants: Object.keys(outSeasonVariants).length > 0 ? outSeasonVariants : undefined,
            growthStates: outGrowthStates.length > 0 ? outGrowthStates : undefined,
            rotationVariants: outRotationVariants.length > 0 ? outRotationVariants : undefined,
            colorVariants: outColorVariants.length > 0 ? outColorVariants : undefined,
            terrainBindings: obj.terrainBindings, spawnWeight: obj.spawnWeight,
            resistance: obj.resistance || undefined,
            bounds: { minCol: minQ-originQ, minRow: minR-originR, maxCol: maxQ-originQ, maxRow: maxR-originR },
            hasBlockedTiles: outMeta.some(m => m.impassable),
            hasInteraction: outMeta.some(m => m.interactionPoint),
            tiles: outTiles, objLayers: outObjLayers, meta: outMeta,
        };
    });
    downloadJSON(exported, fname);
    setTimeout(() => alert(
        `âœ…  Exported "${fname}"\n\nPlace it in data/ as objects.json and run build:data,\nor import it via the editor.`
    ), 200);
}

function downloadJSON(data, fname) {
    const json = JSON.stringify(data, null, 2);
    const blob = new Blob([json], { type:'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = fname; a.click();
    URL.revokeObjectURL(url);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  IMPORT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function onImport(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = ev => {
        try {
            let data = JSON.parse(ev.target.result);

            // â”€â”€ gamedata.json â€” unwrap the relevant section based on current mode â”€â”€
            // New flat format: data.buildings / data.objects are arrays
            // Legacy format:   data.custom_buildings / data.custom_objects are nested manifest/files
            if (data.terrain || data.custom_buildings || data.custom_objects) {
                const wantBuildings = editorMode === 'building';
                if (wantBuildings) {
                    let bArr = [];
                    if (Array.isArray(data.buildings)) bArr = data.buildings;
                    else if (data.custom_buildings) {
                        for (const fileData of Object.values(data.custom_buildings.files || {})) {
                            if (Array.isArray(fileData.buildings)) bArr.push(...fileData.buildings);
                        }
                    }
                    if (!bArr.length) { alert('No building data found.'); e.target.value = ''; return; }
                    data = { buildings: bArr };
                } else {
                    let oArr = [];
                    if (Array.isArray(data.objects)) oArr = data.objects;
                    else if (data.custom_objects) {
                        for (const fileData of Object.values(data.custom_objects.files || {})) {
                            if (fileData.composed && Array.isArray(fileData.objects)) oArr.push(...fileData.objects);
                        }
                    }
                    if (!oArr.length) { alert('No object data found.'); e.target.value = ''; return; }
                    data = { objects: oArr };
                }
            }

            // Building format â€” flat array
            if (Array.isArray(data.buildings) || data.buildings) {
                const src = Array.isArray(data.buildings) ? data.buildings : data.buildings;
                const imported = src.map(b => {
                    const newLayers = {};
                    for (const [ln, arr] of Object.entries(b.layers || {})) {
                        newLayers[ln] = {};
                        for (const c of (Array.isArray(arr) ? arr : Object.entries(arr).map(([k,v])=>({q:+k.split(',')[0],r:+k.split(',')[1],...v})))) {
                            newLayers[ln][`${c.q},${c.r}`] = { sheetPath:c.sheetPath, sx:c.sx, sy:c.sy, sw:c.sw, sh:c.sh };
                        }
                    }
                    const newMeta = {};
                    for (const m of (Array.isArray(b.meta) ? b.meta : Object.entries(b.meta||{}).map(([k,v])=>({q:+k.split(',')[0],r:+k.split(',')[1],...v})))) {
                        newMeta[`${m.q},${m.r}`] = { impassable:!!m.impassable, door:!!m.door };
                    }
                    return { ...b, layers: newLayers, meta: newMeta };
                });
                if (editorMode !== 'building') setEditorMode('building');
                buildings = imported; buildingEditIdx = -1;
                refreshBuildingList();
                if (buildings.length) loadBuilding(0);
                alert(`Imported ${buildings.length} building(s).`);
                e.target.value = ''; return;
            }

            // Composed object format â€” flat array or legacy {composed, objects}
            if (Array.isArray(data.objects) || (data.composed && data.objects)) {
                const objArr = Array.isArray(data.objects) ? data.objects : data.objects;
                const imported = objArr.map(obj => {
                    let minLQ = Infinity, minLR = Infinity, maxLQ = -Infinity, maxLR = -Infinity;
                    const _scanTile = t => {
                        if (t.localCol < minLQ) minLQ = t.localCol;
                        if (t.localCol > maxLQ) maxLQ = t.localCol;
                        if (t.localRow < minLR) minLR = t.localRow;
                        if (t.localRow > maxLR) maxLR = t.localRow;
                    };
                    for (const t of (obj.tiles || [])) _scanTile(t);
                    if (obj.objLayers) { for (const ln of ['base','detail','top']) for (const t of (obj.objLayers[ln]||[])) _scanTile(t); }
                    for (const hs of (obj.healthStates || [])) { for (const t of (hs.tiles || [])) _scanTile(t); if (hs.objLayers) for (const ln of ['base','detail','top']) for (const t of (hs.objLayers[ln]||[])) _scanTile(t); }
                    for (const sarr of Object.values(obj.seasonVariants || {})) for (const t of (sarr || [])) _scanTile(t);
                    for (const gs of (obj.growthStates || [])) { for (const t of (gs.tiles || [])) _scanTile(t); if (gs.objLayers) for (const ln of ['base','detail','top']) for (const t of (gs.objLayers[ln]||[])) _scanTile(t); }
                    for (const rv of (obj.rotationVariants || [])) { for (const t of (rv.tiles || [])) _scanTile(t); if (rv.objLayers) for (const ln of ['base','detail','top']) for (const t of (rv.objLayers[ln]||[])) _scanTile(t); }
                    if (!isFinite(minLQ)) { minLQ=0; minLR=0; maxLQ=0; maxLR=0; }

                    const MARGIN = 1;
                    const offQ = MARGIN - minLQ;
                    const offR = MARGIN - minLR;
                    const _shiftKey = (lc, lr) => `${lc + offQ},${lr + offR}`;
                    const _arrToDict = (arr) => Object.fromEntries((arr||[]).map(t=>[_shiftKey(t.localCol,t.localRow),{sheetPath:t.sheetPath,sx:t.sx,sy:t.sy,sw:t.sw,sh:t.sh}]));

                    // Import objLayers (3-layer) if available, else fall back to tiles â†’ base
                    let newObjLayers;
                    if (obj.objLayers && (obj.objLayers.base || obj.objLayers.detail || obj.objLayers.top)) {
                        newObjLayers = { base: _arrToDict(obj.objLayers.base), detail: _arrToDict(obj.objLayers.detail), top: _arrToDict(obj.objLayers.top) };
                    } else {
                        newObjLayers = { base: _arrToDict(obj.tiles), detail: {}, top: {} };
                    }
                    const newTiles = Object.assign({}, newObjLayers.base, newObjLayers.detail, newObjLayers.top);

                    const newMeta = {};
                    for (const m of (obj.meta||[])) {
                        const mm = {};
                        if (m.impassable) mm.impassable = true;
                        if (m.interactionPoint) mm.interactionPoint = true;
                        if (Object.keys(mm).length) newMeta[_shiftKey(m.localCol, m.localRow)] = mm;
                    }

                    const _importStateLayers = (st) => {
                        if (st.objLayers && (st.objLayers.base || st.objLayers.detail || st.objLayers.top)) {
                            return { base: _arrToDict(st.objLayers.base), detail: _arrToDict(st.objLayers.detail), top: _arrToDict(st.objLayers.top) };
                        }
                        if (st.tiles) return { base: _arrToDict(st.tiles), detail: {}, top: {} };
                        return { base: {}, detail: {}, top: {} };
                    };

                    const newHealthStates = (obj.healthStates || []).map(hs => ({
                        label: hs.label, minHealthPct: hs.minHealthPct, objLayers: _importStateLayers(hs)
                    }));
                    const newSeasonVariants = {};
                    if (obj.seasonVariantLayers) {
                        for (const [season,svl] of Object.entries(obj.seasonVariantLayers)) newSeasonVariants[season] = { base: _arrToDict(svl.base), detail: _arrToDict(svl.detail), top: _arrToDict(svl.top) };
                    } else {
                        for (const [season, sarr] of Object.entries(obj.seasonVariants || {})) newSeasonVariants[season] = { base: _arrToDict(sarr), detail: {}, top: {} };
                    }
                    const newGrowthStates = (obj.growthStates || []).map(gs => ({
                        label: gs.label, daysToReach: gs.daysToReach, objLayers: _importStateLayers(gs)
                    }));
                    const newRotationVariants = (obj.rotationVariants || []).map(rv => ({
                        label: rv.label, objLayers: _importStateLayers(rv)
                    }));

                    const newWidth  = (maxLQ - minLQ) + MARGIN * 2 + 1;
                    const newHeight = (maxLR - minLR) + MARGIN * 2 + 1;
                    return { ...obj,
                             width: newWidth, height: newHeight,
                             originQ: offQ, originR: offR,
                             tiles: newTiles, objLayers: newObjLayers, meta: newMeta,
                             healthStates: newHealthStates.length > 0 ? newHealthStates : undefined,
                             seasonVariants: Object.keys(newSeasonVariants).length > 0 ? newSeasonVariants : undefined,
                             growthStates: newGrowthStates.length > 0 ? newGrowthStates : undefined,
                             rotationVariants: newRotationVariants.length > 0 ? newRotationVariants : undefined };
                });
                if (editorMode !== 'object') setEditorMode('object');
                objDefs = imported; objEditIdx = -1;
                refreshObjectList();
                if (objDefs.length) loadObject(0);
                alert(`Imported ${objDefs.length} object(s).`);
                e.target.value = ''; return;
            }

            // Legacy sheet format (from spritesheet_editor)
            if (data.sheets) {
                const imported = [];
                for (const [, sheetData] of Object.entries(data.sheets)) {
                    for (const obj of (sheetData.objects || [])) {
                        const newTiles = {}; let maxQ=0, maxR=0;
                        for (const t of obj.tiles) {
                            newTiles[`${t.localCol},${t.localRow}`] = {
                                sheetPath: sheetData.path, sx:t.sx, sy:t.sy, sw:t.sw||TILE, sh:t.sh||TILE };
                            if (t.localCol>maxQ) maxQ=t.localCol; if (t.localRow>maxR) maxR=t.localRow;
                        }
                        const newMeta = {};
                        for (const t of obj.tiles) {
                            const mm = {};
                            if (t.impassable) mm.impassable = true;
                            if (t.interactionPoint) mm.interactionPoint = true;
                            if (Object.keys(mm).length) newMeta[`${t.localCol},${t.localRow}`] = mm;
                        }
                        // Legacy sheet imports go to base layer only
                        imported.push({ ...obj, width: maxQ+2, height: maxR+2, tiles: newTiles, objLayers: { base: { ...newTiles }, detail: {}, top: {} }, meta: newMeta });
                    }
                }
                if (editorMode !== 'object') setEditorMode('object');
                objDefs = imported; objEditIdx = -1;
                refreshObjectList();
                if (objDefs.length) loadObject(0);
                alert(`Imported ${objDefs.length} object(s) from sheet format.`);
                e.target.value = ''; return;
            }

            alert('Unrecognized format.');
        } catch(err) { alert('Import failed: ' + err.message); }
    };
    reader.readAsText(file);
    e.target.value = '';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  9-TILE BRUSH SYSTEM
//  A simple 3Ã—3 tile brush: TL, TC, TR, ML, MC, MR, BL, BC, BR
//  Used for filling rectangles (walls, roofs) in the building procgen.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let _nineTileBrushes = [];
// Each: { name, tiles: { TL, TC, TR, ML, MC, MR, BL, BC, BR } }
// Each slot: { sheetPath, sx, sy } or null

let _n9b_selIdx = -1;       // selected brush index
let _n9b_selSlot = null;    // selected slot name (e.g. 'TL') for manual assignment

const _N9B_SLOTS = ['TL','TC','TR','ML','MC','MR','BL','BC','BR'];
const _N9B_LABELS = {TL:'â†–',TC:'â¬†',TR:'â†—',ML:'â¬…',MC:'â– ',MR:'â¡',BL:'â†™',BC:'â¬‡',BR:'â†˜'};

/* â”€â”€ Collapsible section toggles â”€â”€ */
function togglePalette() {
    const panel = document.getElementById('palette-panel');
    const collapsed = panel.classList.toggle('pal-collapsed');
    const chev = panel.querySelector('#pal-header .collapse-chevron');
    if (chev) chev.textContent = collapsed ? 'â–¸' : 'â–¾';
}
function toggleSection(id) {
    const el = document.getElementById(id);
    if (!el) return;
    const collapsed = el.classList.toggle('section-collapsed');
    const chev = el.querySelector('.collapse-chevron');
    if (chev) chev.textContent = collapsed ? 'â–¸' : 'â–¾';
}

function n9b_add() {
    _nineTileBrushes.push({
        name: `Brush ${_nineTileBrushes.length + 1}`,
        tiles: { TL:null,TC:null,TR:null,ML:null,MC:null,MR:null,BL:null,BC:null,BR:null },
        cost: { gold: 0, resources: {} }
    });
    _n9b_selIdx = _nineTileBrushes.length - 1;
    _n9b_selSlot = null;
    n9b_refreshUI();
    notifyParent();
}

function n9b_remove() {
    if (_n9b_selIdx < 0) return;
    _nineTileBrushes.splice(_n9b_selIdx, 1);
    _n9b_selIdx = Math.min(_n9b_selIdx, _nineTileBrushes.length - 1);
    _n9b_selSlot = null;
    n9b_refreshUI();
    notifyParent();
}

function n9b_onNameChange() {
    if (_n9b_selIdx < 0) return;
    _nineTileBrushes[_n9b_selIdx].name = document.getElementById('n9b-name').value;
    n9b_refreshUI();
    notifyParent();
}

function n9b_onCostChange() {
    if (_n9b_selIdx < 0) return;
    const brush = _nineTileBrushes[_n9b_selIdx];
    const gold = parseInt(document.getElementById('n9b-cost-gold').value) || 0;
    const resources = {};
    document.querySelectorAll('#n9b-cost-resource-rows input[data-res-id]').forEach(inp => {
        const rid = inp.dataset.resId;
        const val = parseInt(inp.value) || 0;
        if (rid && val > 0) resources[rid] = val;
    });
    brush.cost = { gold, resources };
    notifyParent();
}

function n9b_select(idx) {
    _n9b_selIdx = idx;
    _n9b_selSlot = null;
    n9b_refreshUI();
}

function n9b_selectSlot(slot) {
    _n9b_selSlot = (_n9b_selSlot === slot) ? null : slot;
    n9b_refreshUI();
}

/** Assign a palette tile click to the selected 9-tile brush slot */
function n9b_assignPaletteTile(sheetPath, col, row) {
    if (_n9b_selIdx < 0 || !_n9b_selSlot) return false;
    const brush = _nineTileBrushes[_n9b_selIdx];
    brush.tiles[_n9b_selSlot] = { sheetPath, sx: col * TILE, sy: row * TILE };
    // Auto-advance to next unassigned slot
    const curI = _N9B_SLOTS.indexOf(_n9b_selSlot);
    _n9b_selSlot = null;
    for (let i = 1; i <= 9; i++) {
        const next = _N9B_SLOTS[(curI + i) % 9];
        if (!brush.tiles[next]) { _n9b_selSlot = next; break; }
    }
    n9b_refreshUI();
    notifyParent();
    return true;
}

/** Auto-assign from a 3Ã—3 palette selection */
function n9b_autoFromSelection() {
    if (_n9b_selIdx < 0) return;
    if (!palDragStart || !palDragLive || !palDragMeta) {
        toast('Select a 3Ã—3 region in the palette first.', 'warn');
        return;
    }
    const c1 = Math.min(palDragStart.col, palDragLive.col);
    const r1 = Math.min(palDragStart.row, palDragLive.row);
    const c2 = Math.max(palDragStart.col, palDragLive.col);
    const r2 = Math.max(palDragStart.row, palDragLive.row);
    const w = c2 - c1 + 1, h = r2 - r1 + 1;
    if (w < 3 || h < 3) {
        toast(`Need at least 3Ã—3 tiles. You selected ${w}Ã—${h}.`, 'warn');
        return;
    }
    const brush = _nineTileBrushes[_n9b_selIdx];
    const path = palDragMeta.path;
    const mapping = [
        ['TL',0,0],['TC',1,0],['TR',2,0],
        ['ML',0,1],['MC',1,1],['MR',2,1],
        ['BL',0,2],['BC',1,2],['BR',2,2],
    ];
    for (const [slot, dc, dr] of mapping) {
        brush.tiles[slot] = { sheetPath: path, sx: (c1 + dc) * TILE, sy: (r1 + dr) * TILE };
    }
    _n9b_selSlot = null;
    n9b_refreshUI();
    notifyParent();
}

function n9b_refreshUI() {
    const panel = document.getElementById('n9b-panel');
    // Show in building mode always
    panel.style.display = (editorMode === 'building') ? '' : 'none';
    if (editorMode !== 'building') return;

    const list = document.getElementById('n9b-list');
    list.innerHTML = '';
    _nineTileBrushes.forEach((b, i) => {
        const card = document.createElement('div');
        card.className = 'n9b-card' + (i === _n9b_selIdx ? ' selected' : '');
        card.onclick = () => n9b_select(i);
        // Mini preview canvas
        const cvs = document.createElement('canvas');
        cvs.className = 'n9b-preview';
        cvs.width = 96; cvs.height = 96;
        card.appendChild(cvs);
        _n9b_renderMiniPreview(cvs, b);
        const nameSpan = document.createElement('span');
        nameSpan.className = 'n9b-name';
        nameSpan.textContent = b.name;
        card.appendChild(nameSpan);
        const countSpan = document.createElement('span');
        countSpan.style.cssText = 'font-size:9px;color:var(--text-dim)';
        const assigned = _N9B_SLOTS.filter(s => b.tiles[s]).length;
        countSpan.textContent = `${assigned}/9`;
        card.appendChild(countSpan);
        list.appendChild(card);
    });

    // Props
    const props = document.getElementById('n9b-props');
    props.style.display = _n9b_selIdx >= 0 ? '' : 'none';
    if (_n9b_selIdx >= 0) {
        document.getElementById('n9b-name').value = _nineTileBrushes[_n9b_selIdx].name;
        const c = _nineTileBrushes[_n9b_selIdx].cost || {};
        const cr = c.resources || {};
        document.getElementById('n9b-cost-gold').value = c.gold || 0;
        _renderN9bCostRows(cr);
        _n9b_renderSlotGrid();
    }
}

function _n9b_renderSlotGrid() {
    const gridDiv = document.getElementById('n9b-grid');
    gridDiv.innerHTML = '';
    if (_n9b_selIdx < 0) return;
    const brush = _nineTileBrushes[_n9b_selIdx];

    for (const slot of _N9B_SLOTS) {
        const cell = document.createElement('div');
        cell.className = 'n9b-cell';
        if (brush.tiles[slot]) cell.classList.add('assigned');
        if (_n9b_selSlot === slot) cell.classList.add('selected-slot');
        cell.title = `${slot} â€” click to select, then click a palette tile`;
        cell.onclick = () => n9b_selectSlot(slot);

        const cvs = document.createElement('canvas');
        cvs.width = TILE; cvs.height = TILE;
        cell.appendChild(cvs);

        if (brush.tiles[slot]) {
            const t = brush.tiles[slot];
            loadImage(t.sheetPath).then(img => {
                if (!img) return;
                const ctx = cvs.getContext('2d');
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(img, t.sx, t.sy, TILE, TILE, 0, 0, TILE, TILE);
            });
        } else {
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, TILE, TILE);
            ctx.fillStyle = '#555';
            ctx.font = '16px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(_N9B_LABELS[slot], TILE/2, TILE/2);
        }

        const lbl = document.createElement('span');
        lbl.className = 'n9b-lbl';
        lbl.textContent = slot;
        cell.appendChild(lbl);

        gridDiv.appendChild(cell);
    }
}

function _n9b_renderMiniPreview(cvs, brush) {
    const ctx = cvs.getContext('2d');
    ctx.imageSmoothingEnabled = false;
    ctx.fillStyle = '#0d1117';
    ctx.fillRect(0, 0, 96, 96);
    const ps = 32; // each slot = 32px in 96px canvas
    const positions = [
        ['TL',0,0],['TC',1,0],['TR',2,0],
        ['ML',0,1],['MC',1,1],['MR',2,1],
        ['BL',0,2],['BC',1,2],['BR',2,2],
    ];
    for (const [slot, gx, gy] of positions) {
        const t = brush.tiles[slot];
        if (t) {
            loadImage(t.sheetPath).then(img => {
                if (!img) return;
                ctx.drawImage(img, t.sx, t.sy, TILE, TILE, gx*ps, gy*ps, ps, ps);
            });
        } else {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(gx*ps, gy*ps, ps, ps);
        }
    }
}

/**
 * Fill a rectangular region on a tile layer using a 9-tile brush pattern.
 * @param {Object} layer - tile store object (key "q,r" â†’ {sheetPath,sx,sy,sw,sh})
 * @param {Object} brush - 9-tile brush { tiles: {TL,TC,TR,...} }
 * @param {number} x - left column (inclusive)
 * @param {number} y - top row (inclusive)
 * @param {number} w - width in tiles
 * @param {number} h - height in tiles
 * @param {Object} [metaObj] - optional meta store to set impassable flags
 * @param {boolean} [impassable=false] - mark tiles as impassable
 */
function n9b_fillRect(layer, brush, x, y, w, h, metaObj, impassable) {
    if (!brush || !brush.tiles) return;
    const T = 32;
    function cell(t) {
        return t ? { sheetPath: t.sheetPath, sx: t.sx, sy: t.sy, sw: T, sh: T } : null;
    }
    for (let r = 0; r < h; r++) {
        for (let c = 0; c < w; c++) {
            const isTop = (r === 0);
            const isBot = (r === h - 1);
            const isLeft = (c === 0);
            const isRight = (c === w - 1);
            let slot;
            if (isTop && isLeft) slot = 'TL';
            else if (isTop && isRight) slot = 'TR';
            else if (isTop) slot = 'TC';
            else if (isBot && isLeft) slot = 'BL';
            else if (isBot && isRight) slot = 'BR';
            else if (isBot) slot = 'BC';
            else if (isLeft) slot = 'ML';
            else if (isRight) slot = 'MR';
            else slot = 'MC';
            const t = brush.tiles[slot];
            const tile = cell(t);
            if (tile) {
                layer[`${x + c},${y + r}`] = tile;
                if (metaObj && impassable) {
                    metaObj[`${x + c},${y + r}`] = { impassable: true };
                }
            }
        }
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TERRAIN BRUSH â€” Auto-tiling engine (Tiled-compatible)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/*
 * Square-grid terrain sets. For Corner sets, each tile has 4 corners
 * (TL, TR, BR, BL). A 2-terrain set needs 2^4 = 16 patterns.
 * For Edge sets: 4 edges (T, R, B, L), also 16 patterns.
 * For Mixed: 4 corners + 4 edges = 8 slots.
 *
 * The brush paints a terrain index at a tile, propagates to neighbors,
 * then looks up best-match tiles from tileAssignments.
 */

// Corner neighbors: for each corner (TL=0, TR=1, BR=2, BL=3),
// which other tiles share that corner?
const _TB_CORNER_NB = [
    [{ dq:-1, dr:-1, ci:2 }, { dq: 0, dr:-1, ci:3 }, { dq:-1, dr: 0, ci:1 }], // TL
    [{ dq: 1, dr:-1, ci:3 }, { dq: 0, dr:-1, ci:2 }, { dq: 1, dr: 0, ci:0 }], // TR
    [{ dq: 1, dr: 1, ci:0 }, { dq: 0, dr: 1, ci:1 }, { dq: 1, dr: 0, ci:3 }], // BR
    [{ dq:-1, dr: 1, ci:1 }, { dq: 0, dr: 1, ci:0 }, { dq:-1, dr: 0, ci:2 }], // BL
];
const _TB_DIR4 = [{dq:0,dr:-1},{dq:1,dr:0},{dq:0,dr:1},{dq:-1,dr:0}]; // T,R,B,L
const _TB_EDGE_OPP = [2, 3, 0, 1];

/** Look up what pattern a tile at (q,r) has in a given set */
function _tb_lookupPattern(q, r, tset) {
    const store = getTileStore();
    const key = `${q},${r}`;
    const cell = store[key];
    if (!cell) return null;
    for (const [patKey, a] of Object.entries(tset.tileAssignments)) {
        if (a.sheetPath === cell.sheetPath && a.sx === cell.sx && a.sy === cell.sy) {
            return patKey.split(',').map(Number);
        }
    }
    return null;
}

/** Get the current corner pattern implied by neighbors */
function _tb_getCornerPattern(q, r, tset) {
    const pat = [null, null, null, null];
    for (let ci = 0; ci < 4; ci++) {
        for (const nb of _TB_CORNER_NB[ci]) {
            const nq = q + nb.dq, nr = r + nb.dr;
            if (nq < 0 || nq >= gridW || nr < 0 || nr >= gridH) continue;
            const nbPat = _tb_lookupPattern(nq, nr, tset);
            if (nbPat) pat[ci] = nbPat[nb.ci];
        }
    }
    return pat;
}

/** Get the current edge pattern implied by neighbors */
function _tb_getEdgePattern(q, r, tset) {
    const pat = [null, null, null, null];
    for (let ei = 0; ei < 4; ei++) {
        const d = _TB_DIR4[ei];
        const nq = q + d.dq, nr = r + d.dr;
        if (nq < 0 || nq >= gridW || nr < 0 || nr >= gridH) continue;
        const nbPat = _tb_lookupPattern(nq, nr, tset);
        if (nbPat) pat[ei] = nbPat[_TB_EDGE_OPP[ei]];
    }
    return pat;
}

/** Compute desired corner pattern for (aq,ar) when painting terrain ti at (pq,pr) */
function _tb_desiredCorner(aq, ar, pq, pr, ti, tset) {
    const pat = _tb_getCornerPattern(aq, ar, tset);
    if (aq === pq && ar === pr) {
        for (let i = 0; i < 4; i++) pat[i] = ti;
    } else {
        for (let ci = 0; ci < 4; ci++) {
            for (const nb of _TB_CORNER_NB[ci]) {
                if (aq + nb.dq === pq && ar + nb.dr === pr) pat[ci] = ti;
            }
        }
    }
    for (let i = 0; i < 4; i++) if (pat[i] === null) pat[i] = 0;
    return pat;
}

function _tb_desiredEdge(aq, ar, pq, pr, ti, tset) {
    const pat = _tb_getEdgePattern(aq, ar, tset);
    if (aq === pq && ar === pr) {
        for (let i = 0; i < 4; i++) pat[i] = ti;
    } else {
        for (let ei = 0; ei < 4; ei++) {
            const d = _TB_DIR4[ei];
            if (aq + d.dq === pq && ar + d.dr === pr) pat[ei] = ti;
        }
    }
    for (let i = 0; i < 4; i++) if (pat[i] === null) pat[i] = 0;
    return pat;
}

/**
 * Main terrain brush paint: place terrain index `ti` from set `tset` at (q,r).
 * Updates the target and all affected neighbors.
 */
function _tb_paint(q, r, ti, tset) {
    const affected = new Set();
    const add = (aq, ar) => { if (aq >= 0 && aq < gridW && ar >= 0 && ar < gridH) affected.add(`${aq},${ar}`); };

    if (tset.type === 'corner' || tset.type === 'mixed') {
        add(q, r);
        for (let ci = 0; ci < 4; ci++)
            for (const nb of _TB_CORNER_NB[ci])
                add(q + nb.dq, r + nb.dr);
    }
    if (tset.type === 'edge' || tset.type === 'mixed') {
        add(q, r);
        for (const d of _TB_DIR4) add(q + d.dq, r + d.dr);
    }

    const store = getTileStore();
    for (const key of affected) {
        const [aq, ar] = key.split(',').map(Number);
        let desired;
        if (tset.type === 'corner') {
            desired = _tb_desiredCorner(aq, ar, q, r, ti, tset);
        } else if (tset.type === 'edge') {
            desired = _tb_desiredEdge(aq, ar, q, r, ti, tset);
        } else {
            const cp = _tb_desiredCorner(aq, ar, q, r, ti, tset);
            const ep = _tb_desiredEdge(aq, ar, q, r, ti, tset);
            desired = [...cp, ...ep];
        }
        const patKey = desired.join(',');
        const assignment = tset.tileAssignments[patKey];
        if (assignment) {
            store[`${aq},${ar}`] = {
                sheetPath: assignment.sheetPath,
                sx: assignment.sx,
                sy: assignment.sy,
                sw: TILE, sh: TILE
            };
        }
    }
}

/**
 * Auto-detect LPC terrain spritesheet corner-set patterns.
 * Maps specific tile positions in terrain_*.png to the 16 corner patterns.
 */
function _tb_autoDetectLPC(sheetPath) {
    const m = [];
    // Pattern: [TL, TR, BR, BL] where 0=terrain A (grass), 1=terrain B (dirt/etc)
    // These positions are based on the standard LPC terrain autotile layout
    m.push({ col:3, row:3, pat:[0,0,0,0] }); // All A
    m.push({ col:3, row:6, pat:[1,1,1,1] }); // All B

    // Edges (one side is B)
    m.push({ col:3, row:0, pat:[1,1,0,0] }); // Top=B
    m.push({ col:5, row:1, pat:[0,1,1,0] }); // Right=B
    m.push({ col:3, row:2, pat:[0,0,1,1] }); // Bottom=B
    m.push({ col:0, row:1, pat:[1,0,0,1] }); // Left=B

    // Outer corners (one corner is B)
    m.push({ col:0, row:0, pat:[1,0,0,0] }); // TL=B
    m.push({ col:5, row:0, pat:[0,1,0,0] }); // TR=B
    m.push({ col:5, row:2, pat:[0,0,1,0] }); // BR=B
    m.push({ col:0, row:2, pat:[0,0,0,1] }); // BL=B

    // Inner corners (three corners are B)
    m.push({ col:0, row:3, pat:[0,1,1,1] }); // only TL=A
    m.push({ col:1, row:3, pat:[1,0,1,1] }); // only TR=A
    m.push({ col:1, row:4, pat:[1,1,0,1] }); // only BR=A
    m.push({ col:0, row:4, pat:[1,1,1,0] }); // only BL=A

    // Diagonals
    m.push({ col:3, row:1, pat:[1,0,1,0] }); // TL+BR=B
    m.push({ col:4, row:1, pat:[0,1,0,1] }); // TR+BL=B

    return m.map(t => ({
        sheetPath, sx: t.col * TILE, sy: t.row * TILE,
        patternKey: t.pat.join(',')
    }));
}

function tbrush_autoAssign() {
    if (_tbrush_selSet < 0) { alert('Select a terrain set first.'); return; }
    const tset = _tbrush_sets[_tbrush_selSet];
    if (tset.type !== 'corner') { alert('Auto-detect only works for Corner sets (the standard LPC layout).'); return; }

    const terrainSheets = PALETTE_DATA['Terrain'] || [];
    if (!terrainSheets.length) { alert('No terrain sheets found.'); return; }

    const sheet = terrainSheets[0]; // terrain_spring.png
    const mappings = _tb_autoDetectLPC(sheet);
    for (const m of mappings) {
        tset.tileAssignments[m.patternKey] = { sheetPath: m.sheetPath, sx: m.sx, sy: m.sy };
    }
    tbrush_refreshUI();
    _tbrush_updatePaletteOverlays();
    alert(`Auto-assigned ${mappings.length} patterns from ${sheet.split('/').pop()}`);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TERRAIN BRUSH â€” Popup & Smart Assignment
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Show the "Define Terrain Set" popup when tiles are selected in the palette.
 */
function _tbrush_showCreatePopup(sheetPath, c1, r1, c2, r2, mouseX, mouseY) {
    const popup = document.getElementById('tbrush-popup');
    _tbrush_popup = { visible: true, sheetPath, c1, r1, c2, r2 };

    const w = c2 - c1 + 1, h = r2 - r1 + 1;
    document.getElementById('tp-name').value = `Terrain (${w}Ã—${h})`;
    document.getElementById('tp-info').textContent =
        `${w}Ã—${h} = ${w*h} tiles from ${sheetPath.split('/').pop()}` +
        (w >= 6 && h >= 5 ? ' â€” LPC layout detected!' : '');

    // Show "Add to existing set" button if a set is selected
    const existDiv = document.getElementById('tp-existing');
    if (_tbrush_selSet >= 0) {
        existDiv.style.display = '';
        document.getElementById('tp-existing-name').textContent = _tbrush_sets[_tbrush_selSet].name;
    } else {
        existDiv.style.display = 'none';
    }

    // Position popup near cursor
    popup.style.display = '';
    const px = Math.min(mouseX + 8, window.innerWidth - 310);
    const py = Math.min(mouseY - 20, window.innerHeight - 280);
    popup.style.left = Math.max(0, px) + 'px';
    popup.style.top = Math.max(0, py) + 'px';

    // Close popup when clicking outside
    setTimeout(() => {
        const closeOnOutside = (ev) => {
            if (!popup.contains(ev.target)) {
                _tbrush_cancelPopup();
                document.removeEventListener('mousedown', closeOnOutside, true);
            }
        };
        document.addEventListener('mousedown', closeOnOutside, true);
    }, 100);
}

function _tbrush_cancelPopup() {
    document.getElementById('tbrush-popup').style.display = 'none';
    _tbrush_popup.visible = false;
}

/**
 * Commit the popup selection: create a new terrain set or add to existing.
 * @param {string} type - 'corner', 'edge', 'mixed', or 'existing'
 */
function _tbrush_commitPopup(type) {
    const { sheetPath, c1, r1, c2, r2 } = _tbrush_popup;
    const name = document.getElementById('tp-name').value.trim() || 'Terrain Set';

    if (type === 'existing') {
        // Add tiles to existing selected set
        if (_tbrush_selSet >= 0) {
            _tbrush_smartAssign(_tbrush_sets[_tbrush_selSet], sheetPath, c1, r1, c2, r2);
        }
    } else {
        // Create new terrain set
        const tset = {
            name,
            type,
            terrains: [
                { name: 'Terrain A', color: '#5c9a2e' },
                { name: 'Terrain B', color: '#8b6914' },
            ],
            tileAssignments: {}
        };
        _tbrush_smartAssign(tset, sheetPath, c1, r1, c2, r2);
        _tbrush_sets.push(tset);
        _tbrush_selSet = _tbrush_sets.length - 1;
        _tbrush_selTerrain = 0;
    }

    _tbrush_cancelPopup();
    tbrush_refreshUI();
    _tbrush_updatePaletteOverlays();
}

/**
 * Smart-assign tiles from a palette selection to terrain patterns.
 * Detects LPC standard layout for â‰¥6Ã—5 corner selections.
 */
function _tbrush_smartAssign(tset, sheetPath, c1, r1, c2, r2) {
    const w = c2 - c1 + 1, h = r2 - r1 + 1;

    if (tset.type === 'corner') {
        if (w >= 6 && h >= 5) {
            _tbrush_assignLPCCorner(tset, sheetPath, c1, r1);
        } else if (w * h >= 16) {
            _tbrush_assign16Sequential(tset, sheetPath, c1, r1, w, h);
        } else {
            _tbrush_assignRowMajor(tset, sheetPath, c1, r1, c2, r2);
        }
    } else if (tset.type === 'edge') {
        if (w * h >= 16) {
            _tbrush_assign16Sequential(tset, sheetPath, c1, r1, w, h);
        } else {
            _tbrush_assignRowMajor(tset, sheetPath, c1, r1, c2, r2);
        }
    } else {
        // Mixed
        _tbrush_assignRowMajor(tset, sheetPath, c1, r1, c2, r2);
    }
}

/** Assign using the standard LPC terrain corner-set layout (6+ cols, 5+ rows) */
function _tbrush_assignLPCCorner(tset, sheetPath, startCol, startRow) {
    const map = [
        { dc:3, dr:3, pat:[0,0,0,0] }, // All A
        { dc:3, dr:6, pat:[1,1,1,1] }, // All B
        { dc:3, dr:0, pat:[1,1,0,0] }, // Top=B
        { dc:5, dr:1, pat:[0,1,1,0] }, // Right=B
        { dc:3, dr:2, pat:[0,0,1,1] }, // Bottom=B
        { dc:0, dr:1, pat:[1,0,0,1] }, // Left=B
        { dc:0, dr:0, pat:[1,0,0,0] }, // TL only B
        { dc:5, dr:0, pat:[0,1,0,0] }, // TR only B
        { dc:5, dr:2, pat:[0,0,1,0] }, // BR only B
        { dc:0, dr:2, pat:[0,0,0,1] }, // BL only B
        { dc:0, dr:3, pat:[0,1,1,1] }, // only TL=A (inner TL)
        { dc:1, dr:3, pat:[1,0,1,1] }, // only TR=A (inner TR)
        { dc:1, dr:4, pat:[1,1,0,1] }, // only BR=A (inner BR)
        { dc:0, dr:4, pat:[1,1,1,0] }, // only BL=A (inner BL)
        { dc:3, dr:1, pat:[1,0,1,0] }, // TL+BR diagonal
        { dc:4, dr:1, pat:[0,1,0,1] }, // TR+BL diagonal
    ];
    for (const m of map) {
        tset.tileAssignments[m.pat.join(',')] = {
            sheetPath,
            sx: (startCol + m.dc) * TILE,
            sy: (startRow + m.dr) * TILE
        };
    }
}

/** Assign first 16 tiles row-major to binary corner/edge patterns 0000..1111 */
function _tbrush_assign16Sequential(tset, sheetPath, c1, r1, w, h) {
    const nSlots = (tset.type === 'corner' || tset.type === 'edge') ? 4 : 8;
    let idx = 0;
    for (let dr = 0; dr < h && idx < 16; dr++) {
        for (let dc = 0; dc < w && idx < 16; dc++) {
            const bits = idx.toString(2).padStart(nSlots, '0').split('').map(Number);
            tset.tileAssignments[bits.join(',')] = {
                sheetPath,
                sx: (c1 + dc) * TILE,
                sy: (r1 + dr) * TILE
            };
            idx++;
        }
    }
}

/** Generic row-major assignment for arbitrary selections */
function _tbrush_assignRowMajor(tset, sheetPath, c1, r1, c2, r2) {
    const nSlots = (tset.type === 'corner' || tset.type === 'edge') ? 4 : 8;
    const maxPat = Math.pow(tset.terrains.length, nSlots);
    let idx = 0;
    for (let dr = r1; dr <= r2 && idx < maxPat; dr++) {
        for (let dc = c1; dc <= c2 && idx < maxPat; dc++) {
            const pat = _tbrush_idxToPattern(idx, tset.terrains.length, nSlots);
            tset.tileAssignments[pat.join(',')] = {
                sheetPath, sx: dc * TILE, sy: dr * TILE
            };
            idx++;
        }
    }
}

/** Convert a linear index to a multi-base pattern array */
function _tbrush_idxToPattern(idx, base, slots) {
    const pat = [];
    for (let i = slots - 1; i >= 0; i--) {
        pat.unshift(idx % base);
        idx = Math.floor(idx / base);
    }
    return pat;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TERRAIN BRUSH â€” Palette Overlays
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Draw colored borders/indicators on palette tiles that are assigned
 * to terrain sets. Shows which tiles are in use for auto-tiling.
 */
function _tbrush_updatePaletteOverlays() {
    if (activeTool !== 'tbrush') {
        for (const [, cvs] of _palOverlayCanvases) cvs.style.display = 'none';
        return;
    }

    // Build map: sheetPath â†’ [{col, row, color}]
    const overlayData = new Map();
    for (const tset of _tbrush_sets) {
        const color = tset.terrains[0]?.color || '#58a6ff';
        for (const [, assign] of Object.entries(tset.tileAssignments)) {
            const col = assign.sx / TILE;
            const row = assign.sy / TILE;
            const path = assign.sheetPath;
            if (!overlayData.has(path)) overlayData.set(path, []);
            overlayData.get(path).push({ col, row, color });
        }
    }

    // Draw overlays
    for (const [path, cvs] of _palOverlayCanvases) {
        const entries = overlayData.get(path);
        if (!entries || entries.length === 0) {
            cvs.style.display = 'none';
            continue;
        }
        cvs.style.display = 'block';
        const ctx = cvs.getContext('2d');
        ctx.clearRect(0, 0, cvs.width, cvs.height);

        for (const e of entries) {
            const x = e.col * TILE * PAL_ZOOM;
            const y = e.row * TILE * PAL_ZOOM;
            const sz = TILE * PAL_ZOOM;

            // Semi-transparent fill
            ctx.fillStyle = e.color + '25';
            ctx.fillRect(x, y, sz, sz);

            // Colored border
            ctx.strokeStyle = e.color;
            ctx.lineWidth = 2;
            ctx.strokeRect(x + 1, y + 1, sz - 2, sz - 2);

            // Small dot in top-right corner
            ctx.fillStyle = e.color;
            ctx.beginPath();
            ctx.arc(x + sz - 5, y + 5, 3, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TERRAIN BRUSH â€” UI management
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function tbrush_refreshUI() {
    const panel = document.getElementById('tbrush-panel');
    panel.style.display = (activeTool === 'tbrush') ? '' : 'none';
    if (activeTool !== 'tbrush') return;

    const list = document.getElementById('tbrush-sets');
    list.innerHTML = '';

    _tbrush_sets.forEach((tset, i) => {
        const card = document.createElement('div');
        card.className = 'tset-card' + (i === _tbrush_selSet ? ' selected' : '');

        const hdr = document.createElement('div');
        hdr.className = 'tset-hdr';
        hdr.onclick = () => tbrush_selectSet(i);
        hdr.innerHTML = `<span class="tset-badge ${tset.type}">${tset.type}</span>` +
            `<span class="tset-name">${tset.name}</span>` +
            `<span style="font-size:10px;color:var(--text-dim)">${Object.keys(tset.tileAssignments).length}p</span>`;
        card.appendChild(hdr);

        if (i === _tbrush_selSet) {
            tset.terrains.forEach((t, ti) => {
                const row = document.createElement('div');
                row.className = 'tr-row' + (ti === _tbrush_selTerrain ? ' selected' : '');
                row.onclick = ev => { ev.stopPropagation(); tbrush_selectTerrain(ti); };
                row.innerHTML = `<span class="tr-swatch" style="background:${t.color}"></span>` +
                    `<span class="tr-label">${t.name}</span>` +
                    `<span style="font-size:9px;color:var(--text-dim)">[${ti}]</span>`;
                card.appendChild(row);
            });
        }

        list.appendChild(card);
    });

    // Props
    const props = document.getElementById('tbrush-props');
    props.style.display = _tbrush_selSet >= 0 ? '' : 'none';
    if (_tbrush_selSet >= 0) {
        const tset = _tbrush_sets[_tbrush_selSet];
        document.getElementById('tbs-name').value = tset.name;
        document.getElementById('tbs-type').value = tset.type;
        document.getElementById('tbs-rm-terrain').disabled = _tbrush_selTerrain < 0 || tset.terrains.length <= 1;

        const terrainProps = document.getElementById('tbrush-terrain-props');
        if (_tbrush_selTerrain >= 0 && tset.terrains[_tbrush_selTerrain]) {
            terrainProps.style.display = '';
            document.getElementById('tbt-name').value = tset.terrains[_tbrush_selTerrain].name;
            document.getElementById('tbt-color').value = tset.terrains[_tbrush_selTerrain].color;
        } else {
            terrainProps.style.display = 'none';
        }

        const n = tset.terrains.length;
        const nSlots = (tset.type === 'corner' || tset.type === 'edge') ? 4 : 8;
        const total = Math.pow(n, nSlots);
        const assigned = Object.keys(tset.tileAssignments).length;
        const statusParts = [`${assigned} / ${total} patterns assigned`];
        if (_tbrush_selectedPattern) statusParts.push(`ğŸ¯ Click palette tile to assign [${_tbrush_selectedPattern}]`);
        document.getElementById('tbrush-pat-info').textContent = statusParts.join('. ');

        // Pattern grid
        _tbrush_renderPatternGrid(tset);
    } else {
        document.getElementById('tbrush-pat-grid').innerHTML = '';
    }
}

/**
 * Render the visual pattern assignment grid for a terrain set.
 * Shows tile thumbnails for assigned patterns, colored diagrams for unassigned.
 * Click a cell to select it for manual palette assignment.
 */
function _tbrush_renderPatternGrid(tset) {
    const gridDiv = document.getElementById('tbrush-pat-grid');
    gridDiv.innerHTML = '';

    const n = tset.terrains.length;
    const nSlots = (tset.type === 'corner' || tset.type === 'edge') ? 4 : 8;

    // Build list of patterns to display
    let patterns;
    if (n === 2 && nSlots === 4) {
        // Show all 16 binary patterns for 2-terrain corner/edge sets
        patterns = [];
        for (let i = 0; i < 16; i++) {
            patterns.push(i.toString(2).padStart(4, '0').split('').map(Number));
        }
    } else if (n <= 3 && nSlots === 4) {
        // Show only assigned patterns (up to 81 for 3 terrains)
        patterns = Object.keys(tset.tileAssignments).map(k => k.split(',').map(Number));
        if (patterns.length === 0) return;
    } else {
        // Mixed or many terrains: show only assigned
        patterns = Object.keys(tset.tileAssignments).map(k => k.split(',').map(Number));
        if (patterns.length === 0) return;
    }

    const cols = patterns.length <= 16 ? 4 : Math.min(8, Math.ceil(Math.sqrt(patterns.length)));
    gridDiv.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;

    for (const pat of patterns) {
        const key = pat.join(',');
        const assign = tset.tileAssignments[key];

        const cell = document.createElement('div');
        cell.className = 'pat-cell';
        if (assign) cell.classList.add('assigned');
        if (_tbrush_selectedPattern === key) cell.classList.add('sel-pat');
        cell.title = `[${key}]${assign ? ' âœ“ assigned' : ' â€” click to select, then click a palette tile'}`;

        const cvs = document.createElement('canvas');
        cvs.width = TILE; cvs.height = TILE;
        cell.appendChild(cvs);

        if (assign) {
            // Draw tile thumbnail
            loadImage(assign.sheetPath).then(img => {
                if (!img) return;
                const ctx = cvs.getContext('2d');
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(img, assign.sx, assign.sy, TILE, TILE, 0, 0, TILE, TILE);
            });
        } else {
            // Draw pattern diagram
            const ctx = cvs.getContext('2d');
            if (tset.type === 'corner') {
                const half = TILE / 2;
                const pos = [[0,0],[half,0],[half,half],[0,half]]; // TL, TR, BR, BL
                for (let i = 0; i < 4; i++) {
                    ctx.fillStyle = tset.terrains[pat[i]]?.color || '#333';
                    ctx.fillRect(pos[i][0], pos[i][1], half, half);
                }
                ctx.strokeStyle = 'rgba(255,255,255,.15)';
                ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(half, 0); ctx.lineTo(half, TILE); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, half); ctx.lineTo(TILE, half); ctx.stroke();
            } else if (tset.type === 'edge') {
                ctx.fillStyle = '#222';
                ctx.fillRect(0, 0, TILE, TILE);
                const edgeRects = [
                    [4, 0, TILE-8, 6],     // T
                    [TILE-6, 4, 6, TILE-8], // R
                    [4, TILE-6, TILE-8, 6], // B
                    [0, 4, 6, TILE-8],      // L
                ];
                for (let i = 0; i < 4; i++) {
                    ctx.fillStyle = tset.terrains[pat[i]]?.color || '#666';
                    ctx.fillRect(...edgeRects[i]);
                }
            }
        }

        // Index label
        const idxLabel = document.createElement('span');
        idxLabel.className = 'pat-idx';
        idxLabel.textContent = key.replace(/,/g,'');
        cell.appendChild(idxLabel);

        // Click to select/deselect pattern for manual assignment
        cell.onclick = () => {
            _tbrush_selectedPattern = (_tbrush_selectedPattern === key) ? null : key;
            tbrush_refreshUI();
        };

        gridDiv.appendChild(cell);
    }
}

function tbrush_selectSet(idx) {
    _tbrush_selSet = idx;
    _tbrush_selTerrain = _tbrush_sets[idx]?.terrains.length > 0 ? 0 : -1;
    _tbrush_selectedPattern = null;
    tbrush_refreshUI();
    _tbrush_updatePaletteOverlays();
}

function tbrush_selectTerrain(idx) {
    _tbrush_selTerrain = idx;
    _tbrush_selectedPattern = null;
    tbrush_refreshUI();
}

function tbrush_addSet() {
    _tbrush_sets.push({
        name: `Set ${_tbrush_sets.length + 1}`,
        type: 'corner',
        terrains: [
            { name: 'Terrain A', color: '#5c9a2e' },
            { name: 'Terrain B', color: '#8b6914' },
        ],
        tileAssignments: {}
    });
    tbrush_selectSet(_tbrush_sets.length - 1);
}

function tbrush_removeSet() {
    if (_tbrush_selSet < 0) return;
    if (!confirm(`Delete terrain set "${_tbrush_sets[_tbrush_selSet].name}"?`)) return;
    _tbrush_sets.splice(_tbrush_selSet, 1);
    _tbrush_selSet = Math.min(_tbrush_selSet, _tbrush_sets.length - 1);
    _tbrush_selTerrain = -1;
    _tbrush_selectedPattern = null;
    tbrush_refreshUI();
    _tbrush_updatePaletteOverlays();
}

function tbrush_addTerrain() {
    if (_tbrush_selSet < 0) return;
    const tset = _tbrush_sets[_tbrush_selSet];
    const n = tset.terrains.length;
    const hue = (n * 60 + 120) % 360;
    tset.terrains.push({ name: `Terrain ${n + 1}`, color: `hsl(${hue},60%,40%)` });
    tbrush_selectTerrain(n);
}

function tbrush_removeTerrain() {
    if (_tbrush_selSet < 0 || _tbrush_selTerrain < 0) return;
    const tset = _tbrush_sets[_tbrush_selSet];
    if (tset.terrains.length <= 1) return;
    tset.terrains.splice(_tbrush_selTerrain, 1);
    _tbrush_selTerrain = Math.min(_tbrush_selTerrain, tset.terrains.length - 1);
    tbrush_refreshUI();
}

function tbrush_onSetPropChange() {
    if (_tbrush_selSet < 0) return;
    _tbrush_sets[_tbrush_selSet].name = document.getElementById('tbs-name').value;
    _tbrush_sets[_tbrush_selSet].type = document.getElementById('tbs-type').value;
    tbrush_refreshUI();
}

function tbrush_onTerrainPropChange() {
    if (_tbrush_selSet < 0 || _tbrush_selTerrain < 0) return;
    const t = _tbrush_sets[_tbrush_selSet].terrains[_tbrush_selTerrain];
    t.name = document.getElementById('tbt-name').value;
    t.color = document.getElementById('tbt-color').value;
    tbrush_refreshUI();
    _tbrush_updatePaletteOverlays();
}

/**
 * When terrain brush is active and a single palette tile is clicked,
 * assign it to the selected terrain's full-fill pattern (all slots = selTerrain).
 */
function _tbrush_assignFromPalette(sheetPath, c1, r1, c2, r2) {
    if (_tbrush_selSet < 0 || _tbrush_selTerrain < 0) return false;
    const tset = _tbrush_sets[_tbrush_selSet];
    const ti = _tbrush_selTerrain;

    if (c1 === c2 && r1 === r2) {
        // Single tile: assign as full-fill for this terrain
        const nSlots = (tset.type === 'corner' || tset.type === 'edge') ? 4 : 8;
        const pat = new Array(nSlots).fill(ti);
        tset.tileAssignments[pat.join(',')] = { sheetPath, sx: c1 * TILE, sy: r1 * TILE };
    } else {
        // Multiple tiles: use smart assignment instead
        _tbrush_smartAssign(tset, sheetPath, c1, r1, c2, r2);
    }
    tbrush_refreshUI();
    _tbrush_updatePaletteOverlays();
    return true;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  KEYBOARD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function onKey(e) {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    if ((e.ctrlKey||e.metaKey) && e.key === 'z') { e.preventDefault(); e.shiftKey ? redo() : undo(); return; }
    if ((e.ctrlKey||e.metaKey) && e.key === 'y') { e.preventDefault(); redo(); return; }
    if (e.key === 's' && (e.ctrlKey||e.metaKey)) { e.preventDefault(); saveItem(); return; }
    if (e.key === 'F' && e.shiftKey) { e.preventDefault(); autofitGrid(); return; }
    const toolMap = { p:'paint', e:'erase', f:'fill', i:'eyedrop', x:'impass', s:'select', t:'tbrush' };
    // Marker shortcut: D for building (door), N for object (interact)
    if (e.key === 'd' && editorMode === 'building') { setTool('marker'); return; }
    if (e.key === 'n' && editorMode === 'object')   { setTool('marker'); return; }
    if (e.key === 'o' && (editorMode === 'object' || editorMode === 'building'))   { setTool('origin'); return; }
    if (toolMap[e.key]) { setTool(toolMap[e.key]); return; }
    if (e.key === 'Escape') { if (document.getElementById('catalog-overlay').style.display !== 'none') { closeCatalog(); return; } if (_tbrush_popup.visible) { _tbrush_cancelPopup(); return; } if (selFloat) commitSelection(); else setTool('paint'); return; }
    if ((e.key==='Delete'||e.key==='Backspace') && activeTool==='select') { e.preventDefault(); cancelSelection(); return; }
    if (e.key === 'r' || e.key === 'R') { e.preventDefault(); rotateStampOrSelection(e.shiftKey ? -1 : 1); return; }
    // T (Shift+T) â€” cycle color variants in object mode
    if (e.key === 'T' && editorMode === 'object') {
        e.preventDefault();
        if (_objColorVariants.length === 0) { showToast('No color variants defined'); return; }
        const nextIdx = (_activeColorVariantIdx + 2) % (_objColorVariants.length + 1) - 1;
        _activeColorVariantIdx = nextIdx;
        if (nextIdx === -1) {
            showToast('Color variant: Base');
            renderBuildCanvas();
        } else {
            loadColorVariantToCanvas(nextIdx);
            showToast(`Color variant: ${_objColorVariants[nextIdx].label}`);
        }
        return;
    }
    // Layer shortcuts 1â€“4 (building mode only)
    if (editorMode === 'building') {
        const layerKeys = ['floor','walls','roof','overlay'];
        const n = parseInt(e.key) - 1;
        if (n >= 0 && n < 4) setLayer(layerKeys[n]);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PARENT EDITOR COMMUNICATION (postMessage bridge)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Convert an internal building object to the export format.
 * Applies origin offset so that all q,r coordinates are origin-relative,
 * and adds a `bounds` field for the runtime footprint.
 */
function _exportBuilding(b) {
    // Determine origin: explicit or default to top-left (0,0)
    let oq = 0, or_ = 0;
    if (b.originQ != null) { oq = b.originQ; or_ = b.originR; }
    else {
        // Implicit: top-left painted tile across all layers
        let minQ = Infinity, minR = Infinity;
        for (const lyr of Object.values(b.layers)) {
            for (const k of Object.keys(lyr)) {
                const [cq, cr] = k.split(',').map(Number);
                if (cq < minQ) minQ = cq;
                if (cr < minR) minR = cr;
            }
        }
        if (minQ !== Infinity) { oq = minQ; or_ = minR; }
    }

    const out = { ...b };
    delete out.originQ; delete out.originR; // baked into coords
    out.layers = {};
    let bMinQ = Infinity, bMinR = Infinity, bMaxQ = -Infinity, bMaxR = -Infinity;
    for (const [ln, lyr] of Object.entries(b.layers)) {
        out.layers[ln] = Object.entries(lyr).map(([key, c]) => {
            const [q, r] = key.split(',').map(Number);
            const rq = q - oq, rr = r - or_;
            if (rq < bMinQ) bMinQ = rq; if (rq > bMaxQ) bMaxQ = rq;
            if (rr < bMinR) bMinR = rr; if (rr > bMaxR) bMaxR = rr;
            return { q: rq, r: rr, sheetPath: c.sheetPath, sx: c.sx, sy: c.sy, sw: c.sw, sh: c.sh };
        });
    }
    out.meta = Object.entries(b.meta).map(([key, m]) => {
        const [q, r] = key.split(',').map(Number);
        const rq = q - oq, rr = r - or_;
        if (rq < bMinQ) bMinQ = rq; if (rq > bMaxQ) bMaxQ = rq;
        if (rr < bMinR) bMinR = rr; if (rr > bMaxR) bMaxR = rr;
        return { q: rq, r: rr, ...m };
    }).filter(m => m.impassable || m.door);
    if (bMinQ !== Infinity) {
        out.bounds = { minCol: bMinQ, minRow: bMinR, maxCol: bMaxQ, maxRow: bMaxR };
    }
    return out;
}

/**
 * Called by the parent editor to pull the current buildings/objects
 * data in gamedata.json structure.  Synchronous â€” returns an object.
 */
function getExportData() {
  const result = {};
  // Terrain sets (terrain brush data)
  if (_tbrush_sets.length) {
    result.terrainSets = _tbrush_sets;
  }
  // 9-tile brushes
  if (_nineTileBrushes.length) {
    result.nineTileBrushes = _nineTileBrushes;
  }
  // Door catalog
  if (_doorCatalog.length) {
    result.doorCatalog = _doorCatalog;
  }
  // Window catalog
  if (_windowCatalog.length) {
    result.windowCatalog = _windowCatalog;
  }
  // Buildings â€” flat array
  if (buildings.length) {
    result.buildings = buildings.map(b => _exportBuilding(b));
  }
  // Objects â€” flat array
  if (objDefs.length) {
    const exported = objDefs.map(obj => {
      // Get tiles from objLayers (new) or tiles (legacy)
      const srcLayers = obj.objLayers || { base: obj.tiles || {}, detail: {}, top: {} };
      // Scan bounds across all layers
      const allKeys = new Set();
      for (const ln of ['base','detail','top']) for (const k of Object.keys(srcLayers[ln] || {})) allKeys.add(k);
      let minQ=Infinity, minR=Infinity, maxQ=-Infinity, maxR=-Infinity;
      for (const key of allKeys) { const [q,r]=key.split(',').map(Number); if(q<minQ)minQ=q; if(q>maxQ)maxQ=q; if(r<minR)minR=r; if(r>maxR)maxR=r; }
      const originQ = obj.originQ != null ? obj.originQ : minQ;
      const originR = obj.originR != null ? obj.originR : minR;

      // Helper to export a tile dict to array format
      const _exportTileDict = (dict) => Object.entries(dict || {}).map(([key,c]) => {
        const [q,r]=key.split(',').map(Number);
        return { localCol:q-originQ, localRow:r-originR, sheetPath:c.sheetPath, sx:c.sx, sy:c.sy, sw:c.sw, sh:c.sh };
      });
      // Helper to export multi-layer objLayers to layered array format
      const _exportObjLayers = (lyrs) => {
        const out = {};
        for (const ln of ['base','detail','top']) {
          const arr = _exportTileDict(lyrs[ln] || {});
          if (arr.length) out[ln] = arr;
        }
        return out;
      };

      // Export tiles (flattened merge for backward compat)
      const merged = Object.assign({}, srcLayers.base, srcLayers.detail, srcLayers.top);
      const outTiles = _exportTileDict(merged);

      // Export objLayers (new multi-layer format)
      const outObjLayers = _exportObjLayers(srcLayers);

      const outMeta = Object.entries(obj.meta || {}).map(([key,m]) => {
        const [q,r]=key.split(',').map(Number);
        return { localCol:q-originQ, localRow:r-originR, ...m };
      }).filter(m => m.impassable || m.interactionPoint);

      // Helper to export state objLayers (with legacy tiles fallback)
      const _exportStateLayers = (st) => {
        if (st.objLayers) return _exportObjLayers(st.objLayers);
        if (st.tiles) return { base: _exportTileDict(st.tiles) };
        return {};
      };

      const outHealthStates = (obj.healthStates||[]).map(hs=>({
        label:hs.label, minHealthPct:hs.minHealthPct,
        tiles: _exportTileDict(Object.assign({}, ...(hs.objLayers ? ['base','detail','top'].map(l=>hs.objLayers[l]||{}) : [hs.tiles||{}]))),
        objLayers: _exportStateLayers(hs),
      }));
      const outSeasonVariants = {};
      for (const [season, sv] of Object.entries(obj.seasonVariants||{})) {
        const svLayers = (sv && sv.base !== undefined) ? sv : { base: sv || {}, detail: {}, top: {} };
        outSeasonVariants[season] = _exportTileDict(Object.assign({}, svLayers.base, svLayers.detail, svLayers.top));
        // Also include layered format under a sibling key (handled below)
      }
      const outSeasonVariantLayers = {};
      for (const [season, sv] of Object.entries(obj.seasonVariants||{})) {
        const svLayers = (sv && sv.base !== undefined) ? sv : { base: sv || {}, detail: {}, top: {} };
        outSeasonVariantLayers[season] = _exportObjLayers(svLayers);
      }
      const outGrowthStates = (obj.growthStates||[]).map(gs=>({
        label:gs.label, daysToReach:gs.daysToReach,
        tiles: _exportTileDict(Object.assign({}, ...(gs.objLayers ? ['base','detail','top'].map(l=>gs.objLayers[l]||{}) : [gs.tiles||{}]))),
        objLayers: _exportStateLayers(gs),
      }));
      const outRotationVariants = (obj.rotationVariants||[]).map(rv=>{
        // Each rotation variant can have its own origin, meta, and canvas size
        const rvLayers = rv.objLayers || { base: rv.tiles || {}, detail: {}, top: {} };
        const rvAllKeys = new Set();
        for (const ln of ['base','detail','top']) for (const k of Object.keys(rvLayers[ln] || {})) rvAllKeys.add(k);
        let rvMinQ=Infinity, rvMinR=Infinity, rvMaxQ=-Infinity, rvMaxR=-Infinity;
        for (const key of rvAllKeys) { const [q,r]=key.split(',').map(Number); if(q<rvMinQ)rvMinQ=q; if(q>rvMaxQ)rvMaxQ=q; if(r<rvMinR)rvMinR=r; if(r>rvMaxR)rvMaxR=r; }
        const rvOriginQ = rv.originQ != null ? rv.originQ : originQ;
        const rvOriginR = rv.originR != null ? rv.originR : originR;
        const _rvExportTileDict = (dict) => Object.entries(dict || {}).map(([key,c]) => {
          const [q,r]=key.split(',').map(Number);
          return { localCol:q-rvOriginQ, localRow:r-rvOriginR, sheetPath:c.sheetPath, sx:c.sx, sy:c.sy, sw:c.sw, sh:c.sh };
        });
        const _rvExportObjLayers = (lyrs) => {
          const out = {};
          for (const ln of ['base','detail','top']) { const arr = _rvExportTileDict(lyrs[ln]||{}); if (arr.length) out[ln] = arr; }
          return out;
        };
        const rvMerged = Object.assign({}, rvLayers.base, rvLayers.detail, rvLayers.top);
        const rvOutMeta = Object.entries(rv.meta || {}).map(([key, m]) => {
          const [q, r] = key.split(',').map(Number);
          return { localCol: q-rvOriginQ, localRow: r-rvOriginR, ...m };
        }).filter(m => m.impassable || m.interactionPoint);
        const rvW = rvAllKeys.size ? rvMaxQ - rvMinQ + 1 : (rv.gridW || 1);
        const rvH = rvAllKeys.size ? rvMaxR - rvMinR + 1 : (rv.gridH || 1);
        return {
          label: rv.label,
          tiles: _rvExportTileDict(rvMerged),
          objLayers: _rvExportObjLayers(rvLayers),
          meta: rvOutMeta.length > 0 ? rvOutMeta : undefined,
          bounds: rvAllKeys.size ? { minCol: rvMinQ-rvOriginQ, minRow: rvMinR-rvOriginR, maxCol: rvMaxQ-rvOriginQ, maxRow: rvMaxR-rvOriginR } : undefined,
          width: rvW, height: rvH,
        };
      });
      // â”€â”€ Color Variants â”€â”€
      const _getExpColorVariant = (cv) => {
        const cvL = cv.objLayers||{base:{},detail:{},top:{}};
        const cvK = new Set();
        for (const ln of ['base','detail','top']) for (const k of Object.keys(cvL[ln]||{})) cvK.add(k);
        let cMnQ=Infinity,cMnR=Infinity,cMxQ=-Infinity,cMxR=-Infinity;
        for (const k of cvK){const [q,r]=k.split(',').map(Number);if(q<cMnQ)cMnQ=q;if(q>cMxQ)cMxQ=q;if(r<cMnR)cMnR=r;if(r>cMxR)cMxR=r;}
        const cOQ=cv.originQ!=null?cv.originQ:originQ;
        const cOR=cv.originR!=null?cv.originR:originR;
        const _cExp=(dict)=>Object.entries(dict||{}).map(([key,c])=>{const[q,r]=key.split(',').map(Number);return{localCol:q-cOQ,localRow:r-cOR,sheetPath:c.sheetPath,sx:c.sx,sy:c.sy,sw:c.sw,sh:c.sh};});
        const _cExpL=(lyrs)=>{const o={};for(const ln of ['base','detail','top']){const a=_cExp(lyrs[ln]||{});if(a.length)o[ln]=a;}return o;};
        const cMerged=Object.assign({},cvL.base,cvL.detail,cvL.top);
        const cMeta=Object.entries(cv.meta||{}).map(([key,m])=>{const[q,r]=key.split(',').map(Number);return{localCol:q-cOQ,localRow:r-cOR,...m};}).filter(m=>m.impassable||m.interactionPoint);
        const cW=cvK.size?cMxQ-cMnQ+1:(cv.gridW||1);
        const cH=cvK.size?cMxR-cMnR+1:(cv.gridH||1);
        // Rotation variants within this color variant
        const cRotVars=(cv.rotationVariants||[]).map(rv=>{
          const rL=rv.objLayers||{base:{},detail:{},top:{}};
          const rK=new Set();for(const ln of ['base','detail','top'])for(const k of Object.keys(rL[ln]||{}))rK.add(k);
          let rMnQ=Infinity,rMnR=Infinity,rMxQ=-Infinity,rMxR=-Infinity;
          for(const k of rK){const[q,r]=k.split(',').map(Number);if(q<rMnQ)rMnQ=q;if(q>rMxQ)rMxQ=q;if(r<rMnR)rMnR=r;if(r>rMxR)rMxR=r;}
          const rOQ=rv.originQ!=null?rv.originQ:cOQ;const rOR=rv.originR!=null?rv.originR:cOR;
          const _rExp2=(dict)=>Object.entries(dict||{}).map(([key,c])=>{const[q,r]=key.split(',').map(Number);return{localCol:q-rOQ,localRow:r-rOR,sheetPath:c.sheetPath,sx:c.sx,sy:c.sy,sw:c.sw,sh:c.sh};});
          const _rExpL2=(lyrs)=>{const o={};for(const ln of ['base','detail','top']){const a=_rExp2(lyrs[ln]||{});if(a.length)o[ln]=a;}return o;};
          const rMerged2=Object.assign({},rL.base,rL.detail,rL.top);
          const rMeta2=Object.entries(rv.meta||{}).map(([key,m])=>{const[q,r]=key.split(',').map(Number);return{localCol:q-rOQ,localRow:r-rOR,...m};}).filter(m=>m.impassable||m.interactionPoint);
          const rW2=rK.size?rMxQ-rMnQ+1:(rv.gridW||1);const rH2=rK.size?rMxR-rMnR+1:(rv.gridH||1);
          return{label:rv.label,tiles:_rExp2(rMerged2),objLayers:_rExpL2(rL),meta:rMeta2.length?rMeta2:undefined,bounds:rK.size?{minCol:rMnQ-rOQ,minRow:rMnR-rOR,maxCol:rMxQ-rOQ,maxRow:rMxR-rOR}:undefined,width:rW2,height:rH2};
        });
        const cSeasonVars={};
        for(const[s,sv] of Object.entries(cv.seasonVariants||{})){
          const svL=(sv&&sv.base!==undefined)?sv:{base:sv||{},detail:{},top:{}};
          cSeasonVars[s]=_cExp(Object.assign({},svL.base,svL.detail,svL.top));
        }
        return{label:cv.label,tiles:_cExp(cMerged),objLayers:_cExpL(cvL),meta:cMeta.length?cMeta:undefined,bounds:cvK.size?{minCol:cMnQ-cOQ,minRow:cMnR-cOR,maxCol:cMxQ-cOQ,maxRow:cMxR-cOR}:undefined,width:cW,height:cH,rotationVariants:cRotVars.length?cRotVars:undefined,seasonVariants:Object.keys(cSeasonVars).length?cSeasonVars:undefined};
      };
      const outColorVariants=(obj.colorVariants||[]).map(_getExpColorVariant);

      return {
        id:obj.id, name:obj.name, objectType:obj.objectType,
        animation:obj.animation||undefined, resource:obj.resource||undefined,
        spawnAfter:obj.spawnAfter||undefined,
        healthStates:outHealthStates.length>0?outHealthStates:undefined,
        seasonVariants:Object.keys(outSeasonVariants).length>0?outSeasonVariants:undefined,
        seasonVariantLayers:Object.keys(outSeasonVariantLayers).length>0?outSeasonVariantLayers:undefined,
        growthStates:outGrowthStates.length>0?outGrowthStates:undefined,
        rotationVariants:outRotationVariants.length>0?outRotationVariants:undefined,
        colorVariants:outColorVariants.length>0?outColorVariants:undefined,
        terrainBindings:obj.terrainBindings, spawnWeight:obj.spawnWeight,
        resistance:obj.resistance||undefined,
        bounds:{minCol:minQ-originQ,minRow:minR-originR,maxCol:maxQ-originQ,maxRow:maxR-originR},
        hasBlockedTiles:outMeta.some(m=>m.impassable), hasInteraction:outMeta.some(m=>m.interactionPoint),
        tiles:outTiles, objLayers:outObjLayers, meta:outMeta,
      };
    });
    result.objects = exported;
  }
  return result;
}

/**
 * Listen for the parent editor sending gamedata sections.
 */
window.addEventListener('message', ev => {
  if (!ev.data) return;
  if (ev.data.type === 'techListUpdate') {
    _availableTechs = ev.data.techs || [];
    renderObjTechTags();
    return;
  }
    if (ev.data.type === 'resourceTypesUpdate') {
        _setResourceTypes(ev.data.resourceTypes || []);
        return;
    }
  if (ev.data.type !== 'loadGamedata') return;
  const d = ev.data;
    if (Array.isArray(d.resourceTypes)) {
        _setResourceTypes(d.resourceTypes);
    }
  // Load terrain sets
  if (d.terrainSets && Array.isArray(d.terrainSets)) {
    _tbrush_sets = d.terrainSets;
    _tbrush_selSet = -1; _tbrush_selTerrain = -1;
    tbrush_refreshUI();
  }
  // Load 9-tile brushes
  if (d.nineTileBrushes && Array.isArray(d.nineTileBrushes)) {
    _nineTileBrushes = d.nineTileBrushes;
    _n9b_selIdx = -1; _n9b_selSlot = null;
    n9b_refreshUI();
  }
  // Load door catalog
  if (d.doorCatalog && Array.isArray(d.doorCatalog)) {
    _doorCatalog = d.doorCatalog;
    _dcat_selIdx = -1; _dcat_picking = false;
    dcat_refreshUI();
  }
  // Load window catalog
  if (d.windowCatalog && Array.isArray(d.windowCatalog)) {
    _windowCatalog = d.windowCatalog;
    _wcat_selIdx = -1; _wcat_picking = false;
    wcat_refreshUI();
  }
  // Load buildings â€” flat array or legacy nested format
  let allBuildings = [];
  if (Array.isArray(d.buildings) && d.buildings.length) {
    allBuildings = d.buildings;
  } else if (d.custom_buildings && d.custom_buildings.files) {
    for (const fileData of Object.values(d.custom_buildings.files)) {
      if (Array.isArray(fileData.buildings)) allBuildings.push(...fileData.buildings);
    }
  }
  if (allBuildings.length) {
      // Re-use the import parsing logic
      const imported = allBuildings.map(b => {
        const hasBounds = !!b.bounds;
        const newLayers = {};
        if (hasBounds) {
          // New format: origin-relative coords â€” shift onto grid with margin
          let minQ = Infinity, minR = Infinity, maxQ = -Infinity, maxR = -Infinity;
          const scan = c => { if(c.q<minQ) minQ=c.q; if(c.q>maxQ) maxQ=c.q; if(c.r<minR) minR=c.r; if(c.r>maxR) maxR=c.r; };
          for (const arr of Object.values(b.layers||{})) for (const c of (Array.isArray(arr)?arr:[])) scan(c);
          for (const m of (Array.isArray(b.meta)?b.meta:[])) scan(m);
          if (!isFinite(minQ)) { minQ=0; minR=0; maxQ=0; maxR=0; }
          const MARGIN = 1, offQ = MARGIN - minQ, offR = MARGIN - minR;
          const sk = (q,r) => `${q+offQ},${r+offR}`;
          for (const [ln, arr] of Object.entries(b.layers||{})) {
            newLayers[ln] = {};
            for (const c of (Array.isArray(arr)?arr:[])) {
              newLayers[ln][sk(c.q,c.r)] = { sheetPath:c.sheetPath, sx:c.sx, sy:c.sy, sw:c.sw, sh:c.sh };
            }
          }
          const newMeta = {};
          for (const m of (Array.isArray(b.meta)?b.meta:[])) {
            newMeta[sk(m.q,m.r)] = { impassable:!!m.impassable, door:!!m.door };
          }
          const w = (maxQ-minQ)+MARGIN*2+1, h = (maxR-minR)+MARGIN*2+1;
          return { ...b, width:w, height:h, originQ:offQ, originR:offR, layers:newLayers, meta:newMeta };
        } else {
          // Old format: absolute coords â€” import as-is, no origin
          for (const [ln, arr] of Object.entries(b.layers || {})) {
            newLayers[ln] = {};
            for (const c of (Array.isArray(arr) ? arr : Object.entries(arr).map(([k,v])=>({q:+k.split(',')[0],r:+k.split(',')[1],...v})))) {
              newLayers[ln][`${c.q},${c.r}`] = { sheetPath:c.sheetPath, sx:c.sx, sy:c.sy, sw:c.sw, sh:c.sh };
            }
          }
          const newMeta = {};
          for (const m of (Array.isArray(b.meta) ? b.meta : Object.entries(b.meta||{}).map(([k,v])=>({q:+k.split(',')[0],r:+k.split(',')[1],...v})))) {
            newMeta[`${m.q},${m.r}`] = { impassable:!!m.impassable, door:!!m.door };
          }
          return { ...b, layers: newLayers, meta: newMeta };
        }
      });
      buildings = imported;
      buildingEditIdx = -1;
      refreshBuildingList();
      if (buildings.length) loadBuilding(0);
  }
  // Load objects â€” flat array or legacy nested format
  let allObjects = [];
  if (Array.isArray(d.objects) && d.objects.length) {
    allObjects = d.objects;
  } else if (d.custom_objects && d.custom_objects.files) {
    for (const fileData of Object.values(d.custom_objects.files)) {
      if (fileData.composed && Array.isArray(fileData.objects)) allObjects.push(...fileData.objects);
    }
  }
  if (allObjects.length) {
      const imported = allObjects.map(obj => {
        let minLQ=Infinity, minLR=Infinity, maxLQ=-Infinity, maxLR=-Infinity;
        const _scanTile = t => { if(t.localCol<minLQ)minLQ=t.localCol; if(t.localCol>maxLQ)maxLQ=t.localCol; if(t.localRow<minLR)minLR=t.localRow; if(t.localRow>maxLR)maxLR=t.localRow; };
        for (const t of (obj.tiles||[])) _scanTile(t);
        // Also scan objLayers if present
        if (obj.objLayers) { for (const ln of ['base','detail','top']) for (const t of (obj.objLayers[ln]||[])) _scanTile(t); }
        for (const hs of (obj.healthStates||[])) { for (const t of (hs.tiles||[])) _scanTile(t); if (hs.objLayers) for (const ln of ['base','detail','top']) for (const t of (hs.objLayers[ln]||[])) _scanTile(t); }
        for (const sarr of Object.values(obj.seasonVariants||{})) for (const t of (sarr||[])) _scanTile(t);
        if (obj.seasonVariantLayers) for (const svl of Object.values(obj.seasonVariantLayers)) for (const ln of ['base','detail','top']) for (const t of (svl[ln]||[])) _scanTile(t);
        for (const gs of (obj.growthStates||[])) { for (const t of (gs.tiles||[])) _scanTile(t); if (gs.objLayers) for (const ln of ['base','detail','top']) for (const t of (gs.objLayers[ln]||[])) _scanTile(t); }
        for (const rv of (obj.rotationVariants||[])) { for (const t of (rv.tiles||[])) _scanTile(t); if (rv.objLayers) for (const ln of ['base','detail','top']) for (const t of (rv.objLayers[ln]||[])) _scanTile(t); }
        if (!isFinite(minLQ)){minLQ=0;minLR=0;maxLQ=0;maxLR=0;}
        const MARGIN=1, offQ=MARGIN-minLQ, offR=MARGIN-minLR;
        const _shiftKey=(lc,lr)=>`${lc+offQ},${lr+offR}`;
        const _arrToDict = (arr) => Object.fromEntries((arr||[]).map(t=>[_shiftKey(t.localCol,t.localRow),{sheetPath:t.sheetPath,sx:t.sx,sy:t.sy,sw:t.sw,sh:t.sh}]));

        // Import objLayers (3-layer) if available, else fall back to tiles â†’ base layer
        let newObjLayers;
        if (obj.objLayers && (obj.objLayers.base || obj.objLayers.detail || obj.objLayers.top)) {
            newObjLayers = { base: _arrToDict(obj.objLayers.base), detail: _arrToDict(obj.objLayers.detail), top: _arrToDict(obj.objLayers.top) };
        } else {
            newObjLayers = { base: _arrToDict(obj.tiles), detail: {}, top: {} };
        }
        // Keep flattened tiles for backward compat
        const newTiles = Object.assign({}, newObjLayers.base, newObjLayers.detail, newObjLayers.top);

        const newMeta={};
        for (const m of (obj.meta||[])) { const mm={}; if(m.impassable)mm.impassable=true; if(m.interactionPoint)mm.interactionPoint=true; if(Object.keys(mm).length)newMeta[_shiftKey(m.localCol,m.localRow)]=mm; }

        // Helper to import state objLayers with legacy fallback
        const _importStateLayers = (st) => {
            if (st.objLayers && (st.objLayers.base || st.objLayers.detail || st.objLayers.top)) {
                return { base: _arrToDict(st.objLayers.base), detail: _arrToDict(st.objLayers.detail), top: _arrToDict(st.objLayers.top) };
            }
            if (st.tiles) return { base: _arrToDict(st.tiles), detail: {}, top: {} };
            return { base: {}, detail: {}, top: {} };
        };

        const newHealthStates=(obj.healthStates||[]).map(hs=>({label:hs.label,minHealthPct:hs.minHealthPct,objLayers:_importStateLayers(hs)}));
        const newSeasonVariants={};
        if (obj.seasonVariantLayers) {
            for (const [season,svl] of Object.entries(obj.seasonVariantLayers)) newSeasonVariants[season]={ base: _arrToDict(svl.base), detail: _arrToDict(svl.detail), top: _arrToDict(svl.top) };
        } else {
            for (const [season,sarr] of Object.entries(obj.seasonVariants||{})) newSeasonVariants[season]={ base: _arrToDict(sarr), detail: {}, top: {} };
        }
        const newGrowthStates=(obj.growthStates||[]).map(gs=>({label:gs.label,daysToReach:gs.daysToReach,objLayers:_importStateLayers(gs)}));
        const newRotationVariants=(obj.rotationVariants||[]).map(rv=>{
            const rvObj = {label:rv.label,objLayers:_importStateLayers(rv)};
            // Import per-variant meta (interaction points, impassable markers)
            if (rv.meta && rv.meta.length) {
                const rvMeta = {};
                for (const m of rv.meta) { const mm={}; if(m.impassable)mm.impassable=true; if(m.interactionPoint)mm.interactionPoint=true; if(Object.keys(mm).length)rvMeta[_shiftKey(m.localCol,m.localRow)]=mm; }
                rvObj.meta = rvMeta;
            }
            // Import per-variant origin (same offset as main object)
            rvObj.originQ = offQ;
            rvObj.originR = offR;
            // Import per-variant canvas size from bounds or width/height
            if (rv.width != null && rv.height != null) {
                rvObj.gridW = rv.width + MARGIN * 2;
                rvObj.gridH = rv.height + MARGIN * 2;
            }
            return rvObj;
        });
        // â”€â”€ Color Variants â”€â”€
        const _importColorVariant = (cv) => {
            const cvObj = { label: cv.label, objLayers: _importStateLayers(cv) };
            if (cv.meta && cv.meta.length) {
                const cvMeta = {};
                for (const m of cv.meta) { const mm={}; if(m.impassable)mm.impassable=true; if(m.interactionPoint)mm.interactionPoint=true; if(Object.keys(mm).length)cvMeta[_shiftKey(m.localCol,m.localRow)]=mm; }
                cvObj.meta = cvMeta;
            }
            cvObj.originQ = offQ;
            cvObj.originR = offR;
            if (cv.width != null && cv.height != null) { cvObj.gridW = cv.width + MARGIN * 2; cvObj.gridH = cv.height + MARGIN * 2; }
            // Import nested rotation variants
            cvObj.rotationVariants = (cv.rotationVariants||[]).map(rv => {
                const rObj = { label: rv.label, objLayers: _importStateLayers(rv) };
                if (rv.meta && rv.meta.length) {
                    const rMeta = {};
                    for (const m of rv.meta) { const mm={}; if(m.impassable)mm.impassable=true; if(m.interactionPoint)mm.interactionPoint=true; if(Object.keys(mm).length)rMeta[_shiftKey(m.localCol,m.localRow)]=mm; }
                    rObj.meta = rMeta;
                }
                rObj.originQ = offQ; rObj.originR = offR;
                if (rv.width != null && rv.height != null) { rObj.gridW = rv.width + MARGIN * 2; rObj.gridH = rv.height + MARGIN * 2; }
                return rObj;
            });
            // Import nested season variants
            cvObj.seasonVariants = {};
            for (const [season, sarr] of Object.entries(cv.seasonVariants||{})) {
                cvObj.seasonVariants[season] = { base: _arrToDict(sarr), detail: {}, top: {} };
            }
            return cvObj;
        };
        const newColorVariants = (obj.colorVariants||[]).map(_importColorVariant);

        return { ...obj, width:(maxLQ-minLQ)+MARGIN*2+1, height:(maxLR-minLR)+MARGIN*2+1, originQ:offQ, originR:offR, tiles:newTiles, objLayers:newObjLayers, meta:newMeta,
          healthStates:newHealthStates.length>0?newHealthStates:undefined, seasonVariants:Object.keys(newSeasonVariants).length>0?newSeasonVariants:undefined, growthStates:newGrowthStates.length>0?newGrowthStates:undefined, rotationVariants:newRotationVariants.length>0?newRotationVariants:undefined, colorVariants:newColorVariants.length>0?newColorVariants:undefined };
      });
      objDefs = imported;
      objEditIdx = -1;
      refreshObjectList();
      // Only auto-load the first object if already in object mode;
      // otherwise just populate the list (user will click Edit later).
      if (editorMode === 'object' && objDefs.length) loadObject(0);
  }
  // Load tech list if included
  if (d.techs && Array.isArray(d.techs)) {
    _availableTechs = d.techs;
    renderObjTechTags();
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  DOOR CATALOG
//  User-curated list of doors for the building generator.
//  Each entry: { name, sheetPath, sx, sy,          (door panel 1Ã—2)
//               frameSheetPath, frameSx, frameSy } (door frame 1Ã—2)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let _doorCatalog = [];
let _dcat_selIdx = -1;
let _dcat_picking = false;  // false | 'door' | 'frame'

function dcat_add() {
    _doorCatalog.push({ name: `Door ${_doorCatalog.length + 1}`,
        sheetPath: null, sx: 0, sy: 0,
        frameSheetPath: null, frameSx: 0, frameSy: 0 });
    _dcat_selIdx = _doorCatalog.length - 1;
    _dcat_picking = 'door';  // auto-enter door picking
    dcat_refreshUI();
    notifyParent();
}

function dcat_remove() {
    if (_dcat_selIdx < 0) return;
    _doorCatalog.splice(_dcat_selIdx, 1);
    _dcat_selIdx = Math.min(_dcat_selIdx, _doorCatalog.length - 1);
    _dcat_picking = false;
    dcat_refreshUI();
    notifyParent();
}

function dcat_onNameChange() {
    if (_dcat_selIdx < 0) return;
    _doorCatalog[_dcat_selIdx].name = document.getElementById('dcat-name').value;
    dcat_refreshUI();
    notifyParent();
}

function dcat_select(idx) {
    _dcat_selIdx = idx;
    _dcat_picking = false;
    dcat_refreshUI();
}

function dcat_pickDoor() {
    _dcat_picking = _dcat_picking === 'door' ? false : 'door';
    dcat_refreshUI();
}

function dcat_pickFrame() {
    _dcat_picking = _dcat_picking === 'frame' ? false : 'frame';
    dcat_refreshUI();
}

function dcat_assignPaletteTile(sheetPath, col, row) {
    if (_dcat_selIdx < 0 || !_dcat_picking) return false;
    const entry = _doorCatalog[_dcat_selIdx];
    if (_dcat_picking === 'door') {
        entry.sheetPath = sheetPath;
        entry.sx = col * TILE;
        entry.sy = row * TILE;
        _dcat_picking = false;
        toast(`Assigned door panel to "${entry.name}"`);
    } else if (_dcat_picking === 'frame') {
        entry.frameSheetPath = sheetPath;
        entry.frameSx = col * TILE;
        entry.frameSy = row * TILE;
        _dcat_picking = false;
        toast(`Assigned door frame to "${entry.name}"`);
    }
    dcat_refreshUI();
    notifyParent();
    return true;
}

function _dcat_drawTile2(cvs, sheetPath, sx, sy, srcW, srcH) {
    // srcW/srcH in tiles (default 1Ã—2 for door, 3Ã—2 for frame)
    srcW = srcW || 1; srcH = srcH || 2;
    const ctx = cvs.getContext('2d');
    const cw = cvs.width, ch = cvs.height;
    ctx.clearRect(0, 0, cw, ch);
    ctx.imageSmoothingEnabled = false;
    if (sheetPath) {
        loadImage(sheetPath).then(img => {
            if (!img) return;
            ctx.drawImage(img, sx, sy, TILE * srcW, TILE * srcH, 0, 0, cw, ch);
        });
    } else {
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, cw, ch);
        ctx.fillStyle = '#555';
        ctx.font = (cw < 40 ? '10' : '14') + 'px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('?', cw/2, ch/2);
    }
}

function dcat_refreshUI() {
    const panel = document.getElementById('dcat-panel');
    panel.style.display = (editorMode === 'building') ? '' : 'none';
    if (editorMode !== 'building') return;

    const list = document.getElementById('dcat-list');
    list.innerHTML = '';
    _doorCatalog.forEach((d, i) => {
        const card = document.createElement('div');
        card.className = 'dcat-card' + (i === _dcat_selIdx ? ' selected' : '');
        if (i === _dcat_selIdx && _dcat_picking) card.classList.add('picking');
        card.onclick = () => dcat_select(i);
        const cvs = document.createElement('canvas');
        cvs.width = TILE * 3; cvs.height = TILE * 2;
        card.appendChild(cvs);
        // Draw combined preview: frame first (3Ã—2), then door on top (center 1Ã—2)
        const ctx = cvs.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        if (!d.frameSheetPath && !d.sheetPath) {
            ctx.fillStyle = '#1a1a2e'; ctx.fillRect(0,0,TILE*3,TILE*2);
            ctx.fillStyle = '#555'; ctx.font = '16px sans-serif';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText('?', TILE*1.5, TILE);
        } else {
            (async () => {
                if (d.frameSheetPath) { const img = await loadImage(d.frameSheetPath); if(img) ctx.drawImage(img, d.frameSx, d.frameSy, TILE*3, TILE*2, 0, 0, TILE*3, TILE*2); }
                if (d.sheetPath)      { const img = await loadImage(d.sheetPath);      if(img) ctx.drawImage(img, d.sx, d.sy, TILE, TILE*2, TILE, 0, TILE, TILE*2); }
            })();
        }
        const nameSpan = document.createElement('span');
        nameSpan.className = 'dcat-name';
        nameSpan.textContent = d.name;
        card.appendChild(nameSpan);
        list.appendChild(card);
    });

    const props = document.getElementById('dcat-props');
    props.style.display = _dcat_selIdx >= 0 ? '' : 'none';
    if (_dcat_selIdx >= 0) {
        const entry = _doorCatalog[_dcat_selIdx];
        document.getElementById('dcat-name').value = entry.name;
        const hint = document.getElementById('dcat-pick-hint');
        hint.style.display = _dcat_picking ? '' : 'none';
        if (_dcat_picking === 'door')  hint.textContent = 'â¬… Click a tile in the palette â€” it and the tile below become the door panel (1Ã—2).';
        if (_dcat_picking === 'frame') hint.textContent = 'â¬… Click a tile in the palette â€” it becomes the top-left of the door frame (3Ã—2).';
        // Pick Door button
        const doorBtn = document.getElementById('dcat-pick-door-btn');
        doorBtn.textContent = _dcat_picking === 'door' ? 'âœ‹ Cancel' : 'ğŸšª Pick Door';
        doorBtn.className = _dcat_picking === 'door' ? 'danger' : 'gold';
        doorBtn.style.fontSize = '10px'; doorBtn.style.padding = '1px 6px';
        // Pick Frame button
        const frameBtn = document.getElementById('dcat-pick-frame-btn');
        frameBtn.textContent = _dcat_picking === 'frame' ? 'âœ‹ Cancel' : 'ğŸ–¼ Pick Frame';
        frameBtn.className = _dcat_picking === 'frame' ? 'danger' : 'blue';
        frameBtn.style.fontSize = '10px'; frameBtn.style.padding = '1px 6px';
        // Previews: frame, door, combined
        _dcat_drawTile2(document.getElementById('dcat-preview-frame'), entry.frameSheetPath, entry.frameSx, entry.frameSy, 3, 2);
        _dcat_drawTile2(document.getElementById('dcat-preview-door'), entry.sheetPath, entry.sx, entry.sy, 1, 2);
        // Combined preview (3Ã—2 frame + 1Ã—2 door centered)
        const pvCvs = document.getElementById('dcat-preview');
        const pvCtx = pvCvs.getContext('2d');
        pvCtx.clearRect(0, 0, 96, 64);
        pvCtx.imageSmoothingEnabled = false;
        if (entry.frameSheetPath || entry.sheetPath) {
            (async () => {
                if (entry.frameSheetPath) { const img = await loadImage(entry.frameSheetPath); if(img) pvCtx.drawImage(img, entry.frameSx, entry.frameSy, TILE*3, TILE*2, 0, 0, 96, 64); }
                if (entry.sheetPath)      { const img = await loadImage(entry.sheetPath);      if(img) pvCtx.drawImage(img, entry.sx, entry.sy, TILE, TILE*2, 32, 0, 32, 64); }
            })();
        } else {
            pvCtx.fillStyle = '#1a1a2e'; pvCtx.fillRect(0,0,96,64);
            pvCtx.fillStyle = '#555'; pvCtx.font = '14px sans-serif';
            pvCtx.textAlign = 'center'; pvCtx.textBaseline = 'middle';
            pvCtx.fillText('No tile', 48, 32);
        }
    }
}

/** Get door options for generator: catalog entries if available, else null (fallback to _PBG_DOORS) */
function _dcat_getDoorOptions() {
    const catalogEntries = _doorCatalog.filter(d => d.sheetPath || d.frameSheetPath);
    if (catalogEntries.length) return catalogEntries;
    return null;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  WINDOW CATALOG
//  User-curated list of window tiles for the building generator.
//  Each entry: { name, sheetPath, sx, sy }
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let _windowCatalog = [];
let _wcat_selIdx = -1;
let _wcat_picking = false;

function wcat_add() {
    _windowCatalog.push({ name: `Window ${_windowCatalog.length + 1}`, sheetPath: null, sx: 0, sy: 0 });
    _wcat_selIdx = _windowCatalog.length - 1;
    _wcat_picking = true;  // auto-enter picking mode for convenience
    wcat_refreshUI();
    notifyParent();
}

function wcat_remove() {
    if (_wcat_selIdx < 0) return;
    _windowCatalog.splice(_wcat_selIdx, 1);
    _wcat_selIdx = Math.min(_wcat_selIdx, _windowCatalog.length - 1);
    _wcat_picking = false;
    wcat_refreshUI();
    notifyParent();
}

function wcat_onNameChange() {
    if (_wcat_selIdx < 0) return;
    _windowCatalog[_wcat_selIdx].name = document.getElementById('wcat-name').value;
    wcat_refreshUI();
    notifyParent();
}

function wcat_select(idx) {
    _wcat_selIdx = idx;
    _wcat_picking = false;
    wcat_refreshUI();
}

function wcat_pick() {
    _wcat_picking = !_wcat_picking;
    wcat_refreshUI();
}

function wcat_assignPaletteTile(sheetPath, col, row) {
    if (_wcat_selIdx < 0 || !_wcat_picking) return false;
    const entry = _windowCatalog[_wcat_selIdx];
    entry.sheetPath = sheetPath;
    entry.sx = col * TILE;
    entry.sy = row * TILE;
    _wcat_picking = false;
    wcat_refreshUI();
    notifyParent();
    toast(`Assigned tile to "${entry.name}"`);
    return true;
}

function wcat_refreshUI() {
    const panel = document.getElementById('wcat-panel');
    panel.style.display = (editorMode === 'building') ? '' : 'none';
    if (editorMode !== 'building') return;

    const list = document.getElementById('wcat-list');
    list.innerHTML = '';
    _windowCatalog.forEach((w, i) => {
        const card = document.createElement('div');
        card.className = 'wcat-card' + (i === _wcat_selIdx ? ' selected' : '');
        if (i === _wcat_selIdx && _wcat_picking) card.classList.add('picking');
        card.onclick = () => wcat_select(i);
        const cvs = document.createElement('canvas');
        cvs.width = TILE; cvs.height = TILE;
        card.appendChild(cvs);
        if (w.sheetPath) {
            loadImage(w.sheetPath).then(img => {
                if (!img) return;
                const ctx = cvs.getContext('2d');
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(img, w.sx, w.sy, TILE, TILE, 0, 0, TILE, TILE);
            });
        } else {
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, TILE, TILE);
            ctx.fillStyle = '#555';
            ctx.font = '16px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('?', TILE/2, TILE/2);
        }
        const nameSpan = document.createElement('span');
        nameSpan.className = 'wcat-name';
        nameSpan.textContent = w.name;
        card.appendChild(nameSpan);
        list.appendChild(card);
    });

    // Props
    const props = document.getElementById('wcat-props');
    props.style.display = _wcat_selIdx >= 0 ? '' : 'none';
    if (_wcat_selIdx >= 0) {
        document.getElementById('wcat-name').value = _windowCatalog[_wcat_selIdx].name;
        const hint = document.getElementById('wcat-pick-hint');
        hint.style.display = _wcat_picking ? '' : 'none';
        const pickBtn = document.getElementById('wcat-pick-btn');
        pickBtn.textContent = _wcat_picking ? 'âœ‹ Cancel Pick' : 'ğŸ¯ Pick from Palette';
        pickBtn.className = _wcat_picking ? 'danger' : 'gold';
        pickBtn.style.fontSize = '10px';
        pickBtn.style.padding = '1px 6px';
        // Preview
        const pvCvs = document.getElementById('wcat-preview');
        const pvCtx = pvCvs.getContext('2d');
        pvCtx.clearRect(0, 0, 64, 64);
        pvCtx.imageSmoothingEnabled = false;
        const entry = _windowCatalog[_wcat_selIdx];
        if (entry.sheetPath) {
            loadImage(entry.sheetPath).then(img => {
                if (!img) return;
                pvCtx.drawImage(img, entry.sx, entry.sy, TILE, TILE, 0, 0, 64, 64);
            });
        } else {
            pvCtx.fillStyle = '#1a1a2e';
            pvCtx.fillRect(0, 0, 64, 64);
            pvCtx.fillStyle = '#555';
            pvCtx.font = '20px sans-serif';
            pvCtx.textAlign = 'center';
            pvCtx.textBaseline = 'middle';
            pvCtx.fillText('No tile', 32, 32);
        }
    }
}

/** Get window options for generator: catalog entries if available, else built-in defaults */
function _wcat_getWindowOptions() {
    const catalogEntries = _windowCatalog.filter(w => w.sheetPath);
    if (catalogEntries.length) return catalogEntries.map(w => ({ name: w.name, path: w.sheetPath, tiles:[{sx:w.sx, sy:w.sy}] }));
    return _PBG_WINDOWS;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PROCEDURAL BUILDING GENERATOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const _PBG_WALLS = [
  { name:'Brick Wall A',      path:'assets/lpc/Structure/Walls/Brick Wall A.png' },
  { name:'Brick Wall B',      path:'assets/lpc/Structure/Walls/Brick Wall B.png' },
  { name:'Adobe Brick Wall',  path:'assets/lpc/Structure/Walls/Adobe Brick Wall.png' },
  { name:'Adobe Stucco Wall', path:'assets/lpc/Structure/Walls/Adobe Stucco Wall.png' },
  { name:'Grainy Plain Wall', path:'assets/lpc/Structure/Walls/Grainy Plain Wall.png' },
  { name:'Jagged Stone Walls',path:'assets/lpc/Structure/Walls/Jagged Stone Walls.png' },
  { name:'Painted Walls',     path:'assets/lpc/Structure/Walls/Painted Walls.png' },
  { name:'Drywall',           path:'assets/lpc/Structure/Walls/Drywall.png' },
  { name:'Panels A',          path:'assets/lpc/Structure/Walls/Panels A.png' },
];
const _PBG_FLOORS = [
  { name:'Wood Floor A',   path:'assets/lpc/Structure/Floor/Wood Floor A.png',  sx:0,sy:0 },
  { name:'Wood Floor B',   path:'assets/lpc/Structure/Floor/Wood Floor B.png',  sx:0,sy:0 },
  { name:'Tile A',         path:'assets/lpc/Structure/Floor/Tile A.png',        sx:0,sy:0 },
  { name:'Tile B',         path:'assets/lpc/Structure/Floor/Tile B.png',        sx:0,sy:0 },
  { name:'Tile C',         path:'assets/lpc/Structure/Floor/Tile C.png',        sx:0,sy:0 },
  { name:'Diamond Tile A', path:'assets/lpc/Structure/Floor/Diamond Tile A.png',sx:0,sy:0 },
  { name:'Herringbone A',  path:'assets/lpc/Structure/Floor/Herringbone A.png', sx:0,sy:0 },
  { name:'Gritty Dirt',    path:'assets/lpc/Structure/Floor/Gritty Dirt.png',   sx:0,sy:0 },
  { name:'Subfloor',       path:'assets/lpc/Structure/Floor/Subfloor.png',      sx:0,sy:0 },
];
const _PBG_ROOFS = [
  { name:'Flat Shingle A',  path:'assets/lpc/Structure/Roofing/Flat Shingle Roof A.png',
    tl:{sx:0,sy:0},  tc:{sx:32,sy:0},  tr:{sx:64,sy:0},
    ml:{sx:0,sy:32},  mc:{sx:32,sy:32},  mr:{sx:64,sy:32},
    bl:{sx:0,sy:64}, bc:{sx:32,sy:64}, br:{sx:64,sy:64}, rows:3 },
  { name:'Gable Shingle A', path:'assets/lpc/Structure/Roofing/Gable Shingle Roof A.png',
    tl:{sx:0,sy:0},  tc:{sx:32,sy:0},  tr:{sx:64,sy:0},
    ml:{sx:0,sy:32},  mc:{sx:32,sy:32},  mr:{sx:64,sy:32},
    bl:{sx:0,sy:64}, bc:{sx:32,sy:64}, br:{sx:64,sy:64}, rows:3 },
  { name:'Adobe Stucco',    path:'assets/lpc/Structure/Roofing/Adobe Stucco Roof.png',
    tl:{sx:0,sy:32}, tc:{sx:32,sy:32}, tr:{sx:64,sy:32},
    ml:null, mc:null, mr:null,
    bl:{sx:0,sy:96}, bc:{sx:32,sy:96}, br:{sx:64,sy:96}, rows:2 },
  { name:'Adobe Brick',     path:'assets/lpc/Structure/Roofing/Adobe Brick Roof.png',
    tl:{sx:0,sy:32}, tc:{sx:32,sy:32}, tr:{sx:64,sy:32},
    ml:null, mc:null, mr:null,
    bl:{sx:0,sy:96}, bc:{sx:32,sy:96}, br:{sx:64,sy:96}, rows:2 },
  { name:'Hipped Shingle A',path:'assets/lpc/Structure/Roofing/Hipped Shingle Roof A.png',
    tl:{sx:0,sy:0},  tc:{sx:32,sy:0},  tr:{sx:64,sy:0},
    ml:{sx:0,sy:32},  mc:{sx:32,sy:32},  mr:{sx:64,sy:32},
    bl:{sx:0,sy:64}, bc:{sx:32,sy:64}, br:{sx:64,sy:64}, rows:3 },
];
const _PBG_DOORS = [
  { name:'Orange Wood',  framePath:'assets/lpc/Structure/Doors/32x64px Doors/Doorframe A.png',
    doorPath:'assets/lpc/Structure/Doors/32x64px Doors/15 Panel Door A.png',
    frame:[{sx:0,sy:0,dr:-1},{sx:0,sy:32,dr:0}],
    panel:[{sx:160,sy:0,dr:-1},{sx:160,sy:32,dr:0}], h:2 },
  { name:'Brown',        framePath:'assets/lpc/Structure/Doors/32x64px Doors/Doorframe A.png',
    doorPath:'assets/lpc/Structure/Doors/32x64px Doors/15 Panel Door A.png',
    frame:[{sx:0,sy:0,dr:-1},{sx:0,sy:32,dr:0}],
    panel:[{sx:160,sy:128,dr:-1},{sx:160,sy:160,dr:0}], h:2 },
  { name:'Dark Brown',   framePath:'assets/lpc/Structure/Doors/32x64px Doors/Doorframe A.png',
    doorPath:'assets/lpc/Structure/Doors/32x64px Doors/15 Panel Door A.png',
    frame:[{sx:0,sy:0,dr:-1},{sx:0,sy:32,dr:0}],
    panel:[{sx:160,sy:256,dr:-1},{sx:160,sy:288,dr:0}], h:2 },
  { name:'Mahogany',     framePath:'assets/lpc/Structure/Doors/32x64px Doors/Doorframe A.png',
    doorPath:'assets/lpc/Structure/Doors/32x64px Doors/15 Panel Door A.png',
    frame:[{sx:0,sy:0,dr:-1},{sx:0,sy:32,dr:0}],
    panel:[{sx:160,sy:384,dr:-1},{sx:160,sy:416,dr:0}], h:2 },
  { name:'Tan',          framePath:'assets/lpc/Structure/Doors/32x64px Doors/Doorframe A.png',
    doorPath:'assets/lpc/Structure/Doors/32x64px Doors/15 Panel Door A.png',
    frame:[{sx:0,sy:0,dr:-1},{sx:0,sy:32,dr:0}],
    panel:[{sx:160,sy:512,dr:-1},{sx:160,sy:544,dr:0}], h:2 },
  { name:'Medium Wood',  framePath:'assets/lpc/Structure/Doors/32x64px Doors/Doorframe A.png',
    doorPath:'assets/lpc/Structure/Doors/32x64px Doors/15 Panel Door A.png',
    frame:[{sx:0,sy:0,dr:-1},{sx:0,sy:32,dr:0}],
    panel:[{sx:160,sy:640,dr:-1},{sx:160,sy:672,dr:0}], h:2 },
  { name:'Olive',        framePath:'assets/lpc/Structure/Doors/32x64px Doors/Doorframe A.png',
    doorPath:'assets/lpc/Structure/Doors/32x64px Doors/15 Panel Door A.png',
    frame:[{sx:0,sy:0,dr:-1},{sx:0,sy:32,dr:0}],
    panel:[{sx:160,sy:768,dr:-1},{sx:160,sy:800,dr:0}], h:2 },
  { name:'Dark Olive',   framePath:'assets/lpc/Structure/Doors/32x64px Doors/Doorframe A.png',
    doorPath:'assets/lpc/Structure/Doors/32x64px Doors/15 Panel Door A.png',
    frame:[{sx:0,sy:0,dr:-1},{sx:0,sy:32,dr:0}],
    panel:[{sx:160,sy:896,dr:-1},{sx:160,sy:928,dr:0}], h:2 },
  { name:'Red',          framePath:'assets/lpc/Structure/Doors/32x64px Doors/Doorframe A.png',
    doorPath:'assets/lpc/Structure/Doors/32x64px Doors/15 Panel Door A.png',
    frame:[{sx:0,sy:0,dr:-1},{sx:0,sy:32,dr:0}],
    panel:[{sx:608,sy:0,dr:-1},{sx:608,sy:32,dr:0}], h:2 },
  { name:'Blue',         framePath:'assets/lpc/Structure/Doors/32x64px Doors/Doorframe A.png',
    doorPath:'assets/lpc/Structure/Doors/32x64px Doors/15 Panel Door A.png',
    frame:[{sx:0,sy:0,dr:-1},{sx:0,sy:32,dr:0}],
    panel:[{sx:608,sy:128,dr:-1},{sx:608,sy:160,dr:0}], h:2 },
  { name:'Green',        framePath:'assets/lpc/Structure/Doors/32x64px Doors/Doorframe A.png',
    doorPath:'assets/lpc/Structure/Doors/32x64px Doors/15 Panel Door A.png',
    frame:[{sx:0,sy:0,dr:-1},{sx:0,sy:32,dr:0}],
    panel:[{sx:608,sy:256,dr:-1},{sx:608,sy:288,dr:0}], h:2 },
  { name:'Gold',         framePath:'assets/lpc/Structure/Doors/32x64px Doors/Doorframe A.png',
    doorPath:'assets/lpc/Structure/Doors/32x64px Doors/15 Panel Door A.png',
    frame:[{sx:0,sy:0,dr:-1},{sx:0,sy:32,dr:0}],
    panel:[{sx:608,sy:384,dr:-1},{sx:608,sy:416,dr:0}], h:2 },
  { name:'White',        framePath:'assets/lpc/Structure/Doors/32x64px Doors/Doorframe A.png',
    doorPath:'assets/lpc/Structure/Doors/32x64px Doors/15 Panel Door A.png',
    frame:[{sx:0,sy:0,dr:-1},{sx:0,sy:32,dr:0}],
    panel:[{sx:608,sy:512,dr:-1},{sx:608,sy:544,dr:0}], h:2 },
  { name:'Cream',        framePath:'assets/lpc/Structure/Doors/32x64px Doors/Doorframe A.png',
    doorPath:'assets/lpc/Structure/Doors/32x64px Doors/15 Panel Door A.png',
    frame:[{sx:0,sy:0,dr:-1},{sx:0,sy:32,dr:0}],
    panel:[{sx:608,sy:640,dr:-1},{sx:608,sy:672,dr:0}], h:2 },
  { name:'Gray',         framePath:'assets/lpc/Structure/Doors/32x64px Doors/Doorframe A.png',
    doorPath:'assets/lpc/Structure/Doors/32x64px Doors/15 Panel Door A.png',
    frame:[{sx:0,sy:0,dr:-1},{sx:0,sy:32,dr:0}],
    panel:[{sx:608,sy:768,dr:-1},{sx:608,sy:800,dr:0}], h:2 },
  { name:'Dark Navy',    framePath:'assets/lpc/Structure/Doors/32x64px Doors/Doorframe A.png',
    doorPath:'assets/lpc/Structure/Doors/32x64px Doors/15 Panel Door A.png',
    frame:[{sx:0,sy:0,dr:-1},{sx:0,sy:32,dr:0}],
    panel:[{sx:608,sy:896,dr:-1},{sx:608,sy:928,dr:0}], h:2 },
];
const _PBG_WINDOWS = [
  { name:'Stone Windows A', path:'assets/lpc/Structure/Windows/Stone Windows A.png',
    tiles:[{sx:0,sy:0}] },
  { name:'Ornamental A',    path:'assets/lpc/Structure/Windows/Ornamental Windows A.png',
    tiles:[{sx:0,sy:0}] },
  { name:'Ornamental B',    path:'assets/lpc/Structure/Windows/Ornamental Windows B.png',
    tiles:[{sx:0,sy:0}] },
];

/* Wall tile offsets: standard LPC 3Ã—3 wall face block */
const _PBG_W = {
  TL:{sx:0,sy:0},   TC:{sx:32,sy:0},   TR:{sx:64,sy:0},
  ML:{sx:0,sy:32},  MC:{sx:32,sy:32},  MR:{sx:64,sy:32},
  BL:{sx:0,sy:64},  BC:{sx:32,sy:64},  BR:{sx:64,sy:64},
};

let _pbgSeed = Date.now();
function _pbgRand() { _pbgSeed = (_pbgSeed * 16807 + 0) % 2147483647; return (_pbgSeed & 0x7fffffff) / 0x7fffffff; }
function _pbgRandInt(a,b) { return a + Math.floor(_pbgRand() * (b - a + 1)); }
function _pbgShuffle(arr) { for (let i=arr.length-1;i>0;i--){const j=_pbgRandInt(0,i);[arr[i],arr[j]]=[arr[j],arr[i]];} return arr; }

/**
 * Generate a floor plan as a set of rectangular sections.
 * Returns array of {x, y, w, d} sections and the merged footprint grid.
 */
function _pbgFloorPlan(numRooms, minW, maxW, minD, maxD) {
  const sections = [];
  // First room: centered
  const w1 = _pbgRandInt(minW, maxW);
  const d1 = _pbgRandInt(minD, maxD);
  sections.push({ x:0, y:0, w:w1, d:d1 });

  for (let i = 1; i < numRooms; i++) {
    const rw = _pbgRandInt(minW, maxW);
    const rd = _pbgRandInt(minD, maxD);
    // Try attaching to existing sections â€” favour horizontal placement
    const candidates = [];
    for (const s of sections) {
      // Attach to the right, bottom-aligned
      candidates.push({ x: s.x + s.w, y: s.y + s.d - rd, w: rw, d: rd, score:0 });
      // Attach to the right, top-aligned
      candidates.push({ x: s.x + s.w, y: s.y, w: rw, d: rd, score:0 });
      // Attach to the left, bottom-aligned
      candidates.push({ x: s.x - rw, y: s.y + s.d - rd, w: rw, d: rd, score:0 });
      // Attach to the left, top-aligned
      candidates.push({ x: s.x - rw, y: s.y, w: rw, d: rd, score:0 });
      // Attach to the back (north), centered horizontally
      const ox = s.x + Math.floor((s.w - rw) / 2);
      candidates.push({ x: ox, y: s.y - rd, w: rw, d: rd, score:0 });
    }
    // Score candidates: favour wide, compact footprints
    for (const c of candidates) {
      const testSections = [...sections, c];
      const { grid, minX, minY, maxX, maxY } = _pbgMerge(testSections);
      const totalW = maxX - minX + 1;
      const totalD = maxY - minY + 1;
      const filled = grid.reduce((s2,row) => s2 + row.filter(Boolean).length, 0);
      const area = totalW * totalD;
      const fillRatio = filled / area;
      c.score = fillRatio * 10;
      // Reward wider-than-tall layouts, penalize taller-than-wide
      if (totalW >= totalD) c.score += 4;
      else c.score -= (totalD - totalW) * 2;
      // Moderate bounds penalty
      if (totalW > 14) c.score -= 3;
      if (totalD > 8)  c.score -= 5;
      // Compactness bonus
      if (fillRatio > 0.7) c.score += 3;
    }
    candidates.sort((a,b) => b.score - a.score);
    // Pick from top candidates with some randomness
    const top = candidates.slice(0, Math.min(3, candidates.length));
    sections.push(top[_pbgRandInt(0, top.length - 1)]);
  }
  return sections;
}

/** Merge sections into a boolean footprint grid */
function _pbgMerge(sections) {
  let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
  for (const s of sections) {
    minX = Math.min(minX, s.x);
    minY = Math.min(minY, s.y);
    maxX = Math.max(maxX, s.x + s.w - 1);
    maxY = Math.max(maxY, s.y + s.d - 1);
  }
  const gw = maxX - minX + 1;
  const gd = maxY - minY + 1;
  const grid = Array.from({length:gd}, () => new Array(gw).fill(false));
  for (const s of sections) {
    for (let dy = 0; dy < s.d; dy++) {
      for (let dx = 0; dx < s.w; dx++) {
        grid[s.y - minY + dy][s.x - minX + dx] = true;
      }
    }
  }
  return { grid, minX, minY, maxX, maxY, gw, gd };
}

/**
 * Build a building from floor-plan sections using 9-tile brushes.
 *
 * Algorithm:
 *  1. Merge sections into a footprint grid.
 *  2. For each section, create a WALL rectangle (WALL_H tiles high)
 *     along the front edge, filled with the wall 9-tile brush.
 *  3. Create a ROOF rectangle above each wall, filled with the roof
 *     9-tile brush.
 *  4. Flood-fill interiors with floor tiles.
 *  5. Place door + windows on the front wall.
 */
function _pbgBuild(sections, wallBrushIdx, floorIdx, roofBrushIdx, doorIdx, windowIdx, addDoor, addWindows) {
  const wallBrush = _nineTileBrushes[wallBrushIdx] || null;
  const roofBrush = _nineTileBrushes[roofBrushIdx] || null;
  const floor = _PBG_FLOORS[floorIdx] || _PBG_FLOORS[0];
  // Door: prefer catalog, fall back to _PBG_DOORS
  const doorCatOpts = _dcat_getDoorOptions();
  const door = doorCatOpts ? doorCatOpts[doorIdx] : null;
  const doorLegacy = !doorCatOpts ? (_PBG_DOORS[doorIdx] || _PBG_DOORS[0]) : null;
  const winOpts = _wcat_getWindowOptions();
  const win   = winOpts[windowIdx] || winOpts[0] || _PBG_WINDOWS[0];
  const wallFallback = _PBG_WALLS[0];
  const roofFallback = _PBG_ROOFS[0];

  const { grid, minX, minY, gw, gd } = _pbgMerge(sections);

  const WALL_H = 3;
  const ROOF_H = 3;

  // Normalize sections relative to footprint origin
  const normSections = sections.map(s => ({
    x: s.x - minX, y: s.y - minY, w: s.w, d: s.d
  }));

  // Global front row (southernmost)
  let globalFront = -1;
  for (const s of normSections) {
    const front = s.y + s.d - 1;
    if (front > globalFront) globalFront = front;
  }

  // Editor grid: ROOF_H rows on top, then gd rows for footprint
  const eW = gw;
  const eH = ROOF_H + gd;

  const floorLayer = {};
  const wallsLayer = {};
  const roofLayer = {};
  const overlayLayer = {};
  const metaOut = {};

  const T = 32;
  function cell(path, sx, sy) { return {sheetPath:path, sx, sy, sw:T, sh:T}; }

  // â”€â”€ Step 1: Fill wall rectangles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  for (const s of normSections) {
    const frontEditorR = ROOF_H + s.y + s.d - 1;
    const wallTopR = frontEditorR - WALL_H + 1;
    if (wallBrush) {
      n9b_fillRect(floorLayer, wallBrush, s.x, wallTopR, s.w, WALL_H, metaOut, true);
    } else {
      for (let wr = 0; wr < WALL_H; wr++) {
        for (let wc = 0; wc < s.w; wc++) {
          const isTop = (wr === 0), isBot = (wr === WALL_H - 1);
          const isLeft = (wc === 0), isRight = (wc === s.w - 1);
          let slot;
          if (isTop && isLeft) slot = 'TL';
          else if (isTop && isRight) slot = 'TR';
          else if (isTop) slot = 'TC';
          else if (isBot && isLeft) slot = 'BL';
          else if (isBot && isRight) slot = 'BR';
          else if (isBot) slot = 'BC';
          else if (isLeft) slot = 'ML';
          else if (isRight) slot = 'MR';
          else slot = 'MC';
          const wt = _PBG_W[slot];
          floorLayer[`${s.x + wc},${wallTopR + wr}`] = cell(wallFallback.path, wt.sx, wt.sy);
          metaOut[`${s.x + wc},${wallTopR + wr}`] = { impassable: true };
        }
      }
    }
  }

  // â”€â”€ Step 2: Fill roof rectangles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  for (const s of normSections) {
    const frontEditorR = ROOF_H + s.y + s.d - 1;
    const wallTopR = frontEditorR - WALL_H + 1;
    const roofBotR = wallTopR - 1;
    const roofTopR = roofBotR - ROOF_H + 1;
    if (roofBrush) {
      n9b_fillRect(floorLayer, roofBrush, s.x, roofTopR, s.w, ROOF_H, metaOut, true);
    } else {
      const rf = roofFallback;
      for (let rr = 0; rr < ROOF_H; rr++) {
        for (let rc = 0; rc < s.w; rc++) {
          const isTop2 = (rr === 0), isBot2 = (rr === ROOF_H - 1);
          const isLeft2 = (rc === 0), isRight2 = (rc === s.w - 1);
          let rt;
          if (isTop2) rt = isLeft2 ? rf.tl : (isRight2 ? rf.tr : rf.tc);
          else if (isBot2) rt = isLeft2 ? rf.bl : (isRight2 ? rf.br : rf.bc);
          else rt = isLeft2 ? (rf.ml||rf.bl) : (isRight2 ? (rf.mr||rf.br) : (rf.mc||rf.bc));
          if (rt) {
            floorLayer[`${s.x + rc},${roofTopR + rr}`] = cell(rf.path, rt.sx, rt.sy);
            metaOut[`${s.x + rc},${roofTopR + rr}`] = { impassable: true };
          }
        }
      }
    }
  }

  // â”€â”€ Step 3: Fill floor interior â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  for (let r = 0; r < gd; r++) {
    for (let c = 0; c < gw; c++) {
      if (!grid[r][c]) continue;
      const key = `${c},${ROOF_H + r}`;
      if (!floorLayer[key]) {
        floorLayer[key] = cell(floor.path, floor.sx, floor.sy);
      }
    }
  }

  // â”€â”€ Step 4: Place door â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (addDoor) {
    let bestSec = null, bestW = 0;
    for (const s of normSections) {
      if (s.y + s.d - 1 === globalFront && s.w > bestW) {
        bestW = s.w; bestSec = s;
      }
    }
    if (bestSec && bestW >= 3) {
      const doorC = bestSec.x + Math.floor(bestSec.w / 2);
      const doorBaseR = ROOF_H + globalFront;
      if (door && (door.sheetPath || door.frameSheetPath)) {
        // Door catalog: punch hole only in center column (1Ã—2), frame overlays on walls layer
        // 1) Remove wall tiles only from center column to leave the door opening
        for (let fr = -1; fr <= 0; fr++) {
          delete floorLayer[`${doorC},${doorBaseR + fr}`];
          delete metaOut[`${doorC},${doorBaseR + fr}`];
        }
        // 2) Draw door panel (1Ã—2) on walls layer (behind frame)
        if (door.sheetPath) {
          wallsLayer[`${doorC},${doorBaseR - 1}`] = cell(door.sheetPath, door.sx, door.sy);
          wallsLayer[`${doorC},${doorBaseR}`]     = cell(door.sheetPath, door.sx, door.sy + TILE);
        }
        // 3) Draw frame (3Ã—2) on overlay layer â€” overlays on top of wall + door
        if (door.frameSheetPath) {
          for (let fc = -1; fc <= 1; fc++) {
            for (let fr = -1; fr <= 0; fr++) {
              const fsx = door.frameSx + (fc + 1) * TILE;
              const fsy = door.frameSy + (fr + 1) * TILE;
              overlayLayer[`${doorC + fc},${doorBaseR + fr}`] = cell(door.frameSheetPath, fsx, fsy);
            }
          }
        }
        // Mark door tiles and frame area so windows skip them; frame sides are impassable
        for (let fr = -1; fr <= 0; fr++) {
          metaOut[`${doorC},${doorBaseR + fr}`] = { door: true };
          metaOut[`${doorC - 1},${doorBaseR + fr}`] = { noWindow: true, impassable: true };
          metaOut[`${doorC + 1},${doorBaseR + fr}`] = { noWindow: true, impassable: true };
        }
      } else if (doorLegacy) {
        // Legacy _PBG_DOORS entry: punch hole in wall first
        for (const f of doorLegacy.frame) {
          const dk = `${doorC},${doorBaseR + f.dr}`;
          delete floorLayer[dk];
          delete metaOut[dk];
        }
        // Draw frame on walls layer
        for (const f of doorLegacy.frame) {
          wallsLayer[`${doorC},${doorBaseR + f.dr}`] = cell(doorLegacy.framePath, f.sx, f.sy);
        }
        // Draw door panel on roof layer
        for (const p of doorLegacy.panel) {
          roofLayer[`${doorC},${doorBaseR + p.dr}`] = cell(doorLegacy.doorPath, p.sx, p.sy);
        }
        metaOut[`${doorC},${doorBaseR}`] = { door: true };
      }
    }
  }

  // â”€â”€ Step 5: Place windows â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (addWindows) {
    for (const s of normSections) {
      // Only place windows on sections whose front is the global front
      const sFront = s.y + s.d - 1;
      if (sFront !== globalFront) continue;
      const frontEditorR = ROOF_H + sFront;
      const wallTopR = frontEditorR - WALL_H + 1;
      // Place windows in the middle row of the wall (row 1 of WALL_H=3)
      const winR = wallTopR + 1;
      for (let wc = 1; wc < s.w - 1; wc++) {
        if (wc % 2 === 1) {
          const wk = `${s.x + wc},${winR}`;
          if (!metaOut[wk] || (!metaOut[wk].door && !metaOut[wk].noWindow)) {
            wallsLayer[wk] = cell(win.path, win.tiles[0].sx, win.tiles[0].sy);
          }
        }
      }
    }
  }

  // â”€â”€ Compute tight bounds & rekey to (0,0) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let usedMinQ = Infinity, usedMaxQ = -Infinity, usedMinR = Infinity, usedMaxR = -Infinity;
  for (const ly of [floorLayer, wallsLayer, roofLayer]) {
    for (const key of Object.keys(ly)) {
      const [q, r] = key.split(',').map(Number);
      if (q < usedMinQ) usedMinQ = q;
      if (q > usedMaxQ) usedMaxQ = q;
      if (r < usedMinR) usedMinR = r;
      if (r > usedMaxR) usedMaxR = r;
    }
  }
  const finalW = usedMaxQ - usedMinQ + 1;
  const finalH = usedMaxR - usedMinR + 1;
  function rekey(ly) {
    const out = {};
    for (const [key, val] of Object.entries(ly)) {
      const [q, r] = key.split(',').map(Number);
      out[`${q - usedMinQ},${r - usedMinR}`] = val;
    }
    return out;
  }

  return {
    floorLayer: rekey(floorLayer), wallsLayer: rekey(wallsLayer),
    roofLayer: rekey(roofLayer), overlayLayer: rekey(overlayLayer), metaOut: rekey(metaOut),
    width: finalW, height: finalH, eMinR: usedMinR,
    originQ: Math.floor(finalW / 2), originR: finalH - 1,
    sections
  };
}

/** Render a small preview of the generated building onto a canvas */
function _pbgRenderPreview(cvs, result) {
  const ctx = cvs.getContext('2d');
  const { width, height, floorLayer, wallsLayer, roofLayer } = result;
  const ps = Math.min(Math.floor(300 / Math.max(width, height)), 24);
  cvs.width = width * ps;
  cvs.height = height * ps;
  ctx.clearRect(0, 0, cvs.width, cvs.height);
  ctx.fillStyle = '#0a0e14';
  ctx.fillRect(0, 0, cvs.width, cvs.height);
  for (const [key] of Object.entries(floorLayer)) {
    const [q, r] = key.split(',').map(Number);
    ctx.fillStyle = '#7a6852';
    ctx.fillRect(q * ps, r * ps, ps - 1, ps - 1);
  }
  for (const [key] of Object.entries(wallsLayer)) {
    const [q, r] = key.split(',').map(Number);
    ctx.fillStyle = 'rgba(200,122,51,0.7)';
    ctx.fillRect(q * ps + 1, r * ps + 1, ps - 3, ps - 3);
  }
  for (const [key] of Object.entries(roofLayer)) {
    const [q, r] = key.split(',').map(Number);
    ctx.fillStyle = '#d4a05a';
    ctx.fillRect(q * ps + 3, r * ps + 3, ps - 7, ps - 7);
  }
  ctx.fillStyle = '#8b949e';
  ctx.font = '9px sans-serif';
  ctx.fillText(width + 'x' + height, 2, cvs.height - 3);
}

let _pbgCurrentResult = null;

function showProcgenModal() {
  if (editorMode !== 'building') {
    setEditorMode('building');
  }
  // Remove existing modal if any
  const existing = document.querySelector('.pbg-overlay');
  if (existing) existing.remove();

  const ov = document.createElement('div');
  ov.className = 'pbg-overlay';
  ov.innerHTML = `
<div class="pbg-modal">
  <h3>ğŸ—ï¸ Procedural Building Generator</h3>
  <div class="pbg-section">
    <h4>Floor Plan</h4>
    <div class="pbg-row">
      <label>Rooms</label>
      <input type="range" id="pbg-rooms" min="1" max="5" value="2">
      <span class="range-val" id="pbg-rooms-val">2</span>
    </div>
    <div class="pbg-row">
      <label>Room Width</label>
      <input type="number" id="pbg-minw" value="4" min="2" max="10" style="width:50px"> â€“
      <input type="number" id="pbg-maxw" value="7" min="2" max="12" style="width:50px">
    </div>
    <div class="pbg-row">
      <label>Room Depth</label>
      <input type="number" id="pbg-mind" value="2" min="2" max="6" style="width:50px"> â€“
      <input type="number" id="pbg-maxd" value="3" min="2" max="8" style="width:50px">
    </div>
  </div>
  <div class="pbg-section">
    <h4>Style</h4>
    <div class="pbg-row"><label>Walls</label><select id="pbg-wall">${(() => { const wallBrushes = _nineTileBrushes.map((b,i) => ({b,i})).filter(({b}) => /wall/i.test(b.name)); if (wallBrushes.length) return wallBrushes.map(({b,i}) => '<option value="'+i+'">'+b.name+'</option>').join(''); if (_nineTileBrushes.length) return _nineTileBrushes.map((b,i) => '<option value="'+i+'">'+b.name+'</option>').join(''); return '<option value="-1">(no 9-tile brushes)</option>'; })()}</select></div>
    <div class="pbg-row"><label>Floor</label><select id="pbg-floor">${_PBG_FLOORS.map((f,i) => `<option value="${i}">${f.name}</option>`).join('')}</select></div>
    <div class="pbg-row"><label>Roof</label><select id="pbg-roof">${(() => { const roofBrushes = _nineTileBrushes.map((b,i) => ({b,i})).filter(({b}) => /roof/i.test(b.name)); if (roofBrushes.length) return roofBrushes.map(({b,i}) => '<option value="'+i+'">'+b.name+'</option>').join(''); if (_nineTileBrushes.length) return _nineTileBrushes.map((b,i) => '<option value="'+i+'">'+b.name+'</option>').join(''); return '<option value="-1">(no 9-tile brushes)</option>'; })()}</select></div>
    <div class="pbg-row"><label>Door</label><select id="pbg-door">${(() => { const dOpts = _dcat_getDoorOptions(); if (dOpts) return dOpts.map((d,i) => '<option value="'+i+'">'+d.name+'</option>').join(''); return _PBG_DOORS.map((d,i) => '<option value="'+i+'">'+d.name+'</option>').join(''); })()}</select></div>
    ${!_doorCatalog.filter(d=>d.sheetPath).length ? '<div class="pbg-row" style="color:#8b949e;font-size:10px;margin-top:-2px"><label></label><span>Add doors in the Door Catalog panel â†</span></div>' : ''}
    <div class="pbg-row"><label>Windows</label><select id="pbg-win">${_wcat_getWindowOptions().map((w,i) => `<option value="${i}">${w.name}</option>`).join('')}</select></div>
    ${!_windowCatalog.filter(w=>w.sheetPath).length ? '<div class="pbg-row" style="color:#8b949e;font-size:10px;margin-top:-2px"><label></label><span>Add windows in the Window Catalog panel â†</span></div>' : ''}
    ${!_nineTileBrushes.length ? '<div class="pbg-row" style="color:#d4a05a;font-size:11px">âš  Create 9-tile brushes in the left panel first for walls & roofs</div>' : ''}
    <div class="pbg-row"><label></label><label style="min-width:0"><input type="checkbox" id="pbg-adddoor" checked> Front Door</label></div>
    <div class="pbg-row"><label></label><label style="min-width:0"><input type="checkbox" id="pbg-addwin" checked> Windows</label></div>
  </div>
  <div class="pbg-section">
    <h4>Preview</h4>
    <div class="pbg-preview"><canvas id="pbg-preview-cvs"></canvas></div>
    <div style="text-align:center;margin-top:6px">
      <button onclick="_pbgRegenerate()" style="font-size:11px">ğŸ² Randomize</button>
    </div>
  </div>
  <div class="pbg-btns">
    <button onclick="_pbgClose()">Cancel</button>
    <button class="primary" onclick="_pbgApply()">Apply to Canvas</button>
  </div>
</div>`;
  document.body.appendChild(ov);

  // Click overlay background to close
  ov.addEventListener('click', e => { if (e.target === ov) _pbgClose(); });

  // Range slider live label
  const roomSlider = document.getElementById('pbg-rooms');
  const roomVal = document.getElementById('pbg-rooms-val');
  roomSlider.addEventListener('input', () => { roomVal.textContent = roomSlider.value; _pbgRegenerate(); });

  // Auto-regenerate on any change
  for (const id of ['pbg-minw','pbg-maxw','pbg-mind','pbg-maxd','pbg-wall','pbg-floor','pbg-roof','pbg-door','pbg-win','pbg-adddoor','pbg-addwin']) {
    const el = document.getElementById(id);
    if (el) el.addEventListener('change', () => _pbgRegenerate());
  }

  _pbgRegenerate();
}

function _pbgRegenerate() {
  _pbgSeed = Date.now() ^ (Math.random() * 0xffffffff);
  const rooms    = +document.getElementById('pbg-rooms').value;
  const minW     = +document.getElementById('pbg-minw').value;
  const maxW     = +document.getElementById('pbg-maxw').value;
  const minD     = +document.getElementById('pbg-mind').value;
  const maxD     = +document.getElementById('pbg-maxd').value;
  const wallBrushIdx = +document.getElementById('pbg-wall').value;
  const floorIdx = +document.getElementById('pbg-floor').value;
  const roofBrushIdx = +document.getElementById('pbg-roof').value;
  const doorIdx  = +document.getElementById('pbg-door').value;
  const winIdx   = +document.getElementById('pbg-win').value;
  const addDoor  = document.getElementById('pbg-adddoor').checked;
  const addWin   = document.getElementById('pbg-addwin').checked;

  const sections = _pbgFloorPlan(rooms, Math.max(2,minW), Math.max(minW,maxW), Math.max(2,minD), Math.max(minD,maxD));
  _pbgCurrentResult = _pbgBuild(sections, wallBrushIdx, floorIdx, roofBrushIdx, doorIdx, winIdx, addDoor, addWin);

  const cvs = document.getElementById('pbg-preview-cvs');
  if (cvs) _pbgRenderPreview(cvs, _pbgCurrentResult);
}

function _pbgClose() {
  const ov = document.querySelector('.pbg-overlay');
  if (ov) ov.remove();
  _pbgCurrentResult = null;
}

function _pbgApply() {
  if (!_pbgCurrentResult) return;
  const r = _pbgCurrentResult;

  // Reset editor to building mode
  if (editorMode !== 'building') setEditorMode('building');

  // Set grid size with margin
  const margin = 1;
  gridW = r.width + margin * 2;
  gridH = r.height + margin * 2;
  // Clamp to reasonable sizes
  gridW = Math.max(gridW, 4);
  gridH = Math.max(gridH, 4);

  // Clear layers
  layers = { floor:{}, walls:{}, roof:{}, overlay:{} };
  meta = {};
  undoStack = []; redoStack = [];
  buildingEditIdx = -1;

  // Copy tiles with margin offset
  for (const [key, val] of Object.entries(r.floorLayer)) {
    const [q, rr] = key.split(',').map(Number);
    layers.floor[`${q+margin},${rr+margin}`] = val;
  }
  for (const [key, val] of Object.entries(r.wallsLayer)) {
    const [q, rr] = key.split(',').map(Number);
    layers.walls[`${q+margin},${rr+margin}`] = val;
  }
  for (const [key, val] of Object.entries(r.roofLayer)) {
    const [q, rr] = key.split(',').map(Number);
    layers.roof[`${q+margin},${rr+margin}`] = val;
  }
  for (const [key, val] of Object.entries(r.overlayLayer)) {
    const [q, rr] = key.split(',').map(Number);
    layers.overlay[`${q+margin},${rr+margin}`] = val;
  }
  for (const [key, val] of Object.entries(r.metaOut)) {
    const [q, rr] = key.split(',').map(Number);
    meta[`${q+margin},${rr+margin}`] = val;
  }

  // Set origin at the front door (bottom center)
  _bldOriginQ = r.originQ + margin;
  _bldOriginR = r.originR + margin;

  // Set default name
  document.getElementById('bld-name').value = '';
  document.getElementById('bld-type').value = 'house';
  document.getElementById('bld-tags').value = '';

  // Preload all images then render
  const paths = new Set();
  for (const ly of [layers.floor, layers.walls, layers.roof, layers.overlay]) {
    for (const c of Object.values(ly)) if (c && c.sheetPath) paths.add(c.sheetPath);
  }
  Promise.all([...paths].map(loadImage)).then(() => {
    document.getElementById('grid-w').value = gridW;
    document.getElementById('grid-h').value = gridH;
    fitCanvas();
    renderBuildCanvas();

    // Auto-save the generated building and trigger interior generation
    _pbgAutoSaveAndGenerateInterior(r);
  });

  _pbgClose();
}

/**
 * After a building is generated, auto-save it and ask the interior editor
 * to generate a matching interior linked to this building.
 */
function _pbgAutoSaveAndGenerateInterior(buildResult) {
  // Auto-fill a name if empty
  const nameInput = document.getElementById('bld-name');
  if (!nameInput.value.trim()) {
    const types = ['Cottage','House','Shop','Hall','Lodge','Dwelling','Homestead','Cabin','Manor','Hut'];
    const pick = types[Math.floor(Math.random() * types.length)];
    nameInput.value = pick;
  }
  // Save the building
  saveBuilding();

  // Now trigger interior generation for the saved building
  const bIdx = buildingEditIdx >= 0 ? buildingEditIdx : buildings.length - 1;
  const b = buildings[bIdx];
  if (!b) return;

  // Notify parent so data is synced, then ask for interior generation
  notifyParent();
  try {
    window.parent.postMessage({
      type: 'openBuildingInterior',
      buildingId:     b.id,
      buildingName:   b.name,
      buildingType:   b.buildingType,
      buildingWidth:  b.width,
      buildingHeight: b.height,
      autoGenerate:   true,
    }, '*');
  } catch(e) { /* standalone mode â€” no interior generation from here */ }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BOOT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
init();
// Tell the parent editor we're ready to receive data
try { window.parent.postMessage({ type: 'spriteEditorReady' }, '*'); } catch(e) {}
</script>

<!-- Required Techs Picker Modal -->
<div id="obj-tech-modal" style="position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:500">
  <div style="background:var(--panel);border:1px solid var(--border2);border-radius:10px;width:380px;max-height:70vh;display:flex;flex-direction:column;overflow:hidden">
    <h3 style="padding:12px 16px;font-size:12px;border-bottom:1px solid var(--border);margin:0">Select Required Technologies</h3>
    <div id="obj-tech-list" style="flex:1;overflow-y:auto;padding:8px 12px"></div>
    <div style="display:flex;justify-content:flex-end;padding:10px 16px;border-top:1px solid var(--border);gap:8px">
      <button onclick="closeObjTechPicker()">Done</button>
    </div>
  </div>
</div>

</body>
</html>
